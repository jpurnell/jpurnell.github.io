<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Justin Purnell</title><description></description><link>https://www.justinpurnell.com</link><atom:link
    href="https://www.justinpurnell.com/feed.rss"
    rel="self" type="application/rss+xml"
/><language>en</language><generator>Ignite v0.2.1</generator><image><url>/images/logos/rss.png</url><title>Justin Purnell</title><link>https://www.justinpurnell.com</link><width>144</width><height>152</height></image><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-04/03-fri-lease-accounting</guid><title>Lease Accounting with IFRS 16 / ASC 842</title><link>https://www.justinpurnell.com/BusinessMath/week-04/03-fri-lease-accounting</link><description><![CDATA[Part 15 of 12-Week BusinessMath Series]]></description><pubDate>Thu, 29 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[leases]]></category><category><![CDATA[ifrs16]]></category><category><![CDATA[asc842]]></category><category><![CDATA[accounting]]></category><category><![CDATA[right-of-use-assets]]></category><content:encoded><![CDATA[<p><strong>Part 15 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>Calculating lease liabilities as present value of future payments</li><li>Modeling right-of-use (ROU) assets with initial direct costs</li><li>Generating amortization schedules with interest and principal breakdown</li><li>Computing depreciation expense for ROU assets</li><li>Applying short-term and low-value lease exemptions</li><li>Understanding discount rate selection (implicit rate vs. IBR)</li></ul><hr /><h2>The Problem</h2><p>In 2019, new lease accounting standards (IFRS 16 and ASC 842) fundamentally changed how companies report leases. <strong>Most leases must now be capitalized on the balance sheet</strong>, creating:</p><ul><li><strong>Lease Liability</strong>: Present value of future lease payments</li><li><strong>Right-of-Use Asset</strong>: Asset representing the right to use the leased property</li></ul><p>This affects nearly every business with operating leases (office space, equipment, vehicles). CFOs need to:</p><ul><li>Calculate present value of multi-year payment streams</li><li>Track liability amortization (interest + principal)</li><li>Depreciate ROU assets over the lease term</li><li>Determine which leases qualify for exemptions</li><li>Generate disclosure schedules for auditors</li></ul><p><strong>Manual lease accounting in spreadsheets is error-prone and doesn‚Äôt scale when you have dozens or hundreds of leases.</strong></p><hr /><h2>The Solution</h2><p>BusinessMath provides the <code>Lease</code> type with comprehensive tools for lease liability calculation, ROU asset modeling, amortization schedules, and expense tracking.</p><h3>Basic Lease Recognition</h3><p>Calculate the initial lease liability and ROU asset:</p><pre><code class="language-swift">import BusinessMath

// Office lease: quarterly payments for 1 year
let q1 = Period.quarter(year: 2025, quarter: 1)
let periods = [q1, q1 + 1, q1 + 2, q1 + 3]

let payments = TimeSeries(
    periods: periods,
    values: [25_000.0, 25_000.0, 25_000.0, 25_000.0]
)

// Create lease with 6% annual discount rate (incremental borrowing rate)
let lease = Lease(
    payments: payments,
    discountRate: 0.06
)

// Calculate present value (lease liability)
let liability = lease.presentValue()
print("Initial lease liability: \(liability.currency())")  // ~$96,360

// Calculate right-of-use asset (initially equals liability)
let rouAsset = lease.rightOfUseAsset()
print("ROU asset: \(rouAsset.currency())")  // $96,360
</code></pre><p><strong>Output:</strong></p><pre><code>Initial lease liability: $96,360
ROU asset: $96,360
</code></pre><p><strong>The calculation</strong>: Four $25,000 payments discounted at 6% annual (1.5% quarterly) = $96,360 present value.</p><hr /><h3>Lease Liability Amortization Schedule</h3><p>Generate a complete amortization schedule showing how the liability decreases each period:</p><pre><code class="language-swift">let schedule = lease.liabilitySchedule()

print("=== Lease Liability Schedule ===")
print("Period\t\tBeginning\tPayment\t\tInterest\tPrincipal\tEnding")
print("------\t\t---------\t-------\t\t--------\t---------\t------")

for (i, period) in periods.enumerated() {
    // Beginning balance
    let beginning = i == 0 ? liability : schedule[periods[i-1]]!

    // Payment
    let payment = payments[period]!

    // Interest expense (Beginning √ó quarterly rate)
    let interest = lease.interestExpense(period: period)

    // Principal reduction
    let principal = lease.principalReduction(period: period)

    // Ending balance
    let ending = schedule[period]!

	print("\(period.label)\(beginning.currency(0).paddingLeft(toLength: 14))\(payment.currency(0).paddingLeft(toLength: 10))\(interest.currency(0).paddingLeft(toLength: 13))\(principal.currency(0).paddingLeft(toLength: 13))\(ending.currency(0).paddingLeft(toLength: 9))")
}

print("\nTotal payments: \((payments.reduce(0, +)).currency(0))")
print("Total interest: \((lease.totalInterest()).currency(0))")
</code></pre><p><strong>Output:</strong></p><pre><code>=== Lease Liability Schedule ===
Period		Beginning	Payment		Interest	Principal	Ending
------		---------	-------		--------	---------	------
2025-Q1       $96,360   $25,000       $1,445      $23,555  $96,360
2025-Q2       $96,360   $25,000       $1,092      $23,908  $48,897
2025-Q3       $48,897   $25,000         $733      $24,267  $24,631
2025-Q4       $24,631   $25,000         $369      $24,631       $0

Total payments: $100,000
Total interest: $3,640
</code></pre><p><strong>The insight</strong>: Interest expense decreases each period as the liability balance declines (front-loaded interest).</p><hr /><h3>Including Initial Direct Costs and Prepayments</h3><p>Many leases include upfront costs that increase the ROU asset:</p><pre><code class="language-swift">let leaseWithCosts = Lease(
    payments: payments,
    discountRate: 0.06,
    initialDirectCosts: 5_000.0,    // Legal fees, broker commissions
    prepaidAmount: 10_000.0          // First month rent + security deposit
)

let liability = leaseWithCosts.presentValue()       // PV of payments only
let rouAsset = leaseWithCosts.rightOfUseAsset()    // PV + costs + prepayments

print("=== Initial Recognition with Costs ===")
print("Lease liability: \(liability.currency())")   // $96,454
print("ROU asset: \(rouAsset.currency())")          // $111,454
print("\nDifference: \((rouAsset - liability).currency())")  // $15,000 (costs + prepayment)
</code></pre><p><strong>Output:</strong></p><pre><code>=== Initial Recognition with Costs ===
Lease liability: $96,360
ROU asset: $111,360

Difference: $15,000
</code></pre><p><strong>The accounting</strong>: Liability = PV of future payments. Asset = Liability + upfront costs + prepayments.</p><hr /><h3>Depreciation of ROU Asset</h3><p>ROU assets are depreciated straight-line over the lease term:</p><pre><code class="language-swift">print("\n=== ROU Asset Depreciation ===")

// Quarterly depreciation (straight-line over 4 quarters)
let depreciation = leaseWithCosts.depreciation(period: q1)
print("Quarterly depreciation: \(depreciation.currency())")  // $111,454 √∑ 4 = $27,864

// Track carrying value each quarter
for (i, period) in periods.enumerated() {
    let carryingValue = leaseWithCosts.carryingValue(period: period)
    let quarterNum = i + 1
    print("Q\(quarterNum) carrying value: \(carryingValue.currency())")
}
</code></pre><p><strong>Output:</strong></p><pre><code>=== ROU Asset Depreciation ===
Quarterly depreciation: $27,840
Q1 carrying value: $83,520
Q2 carrying value: $55,680
Q3 carrying value: $27,840
Q4 carrying value: $0
</code></pre><p><strong>The pattern</strong>: ROU asset decreases linearly by $27,864 each quarter until fully depreciated.</p><hr /><h3>Complete Income Statement Impact</h3><p>Each period has two expenses: interest and depreciation:</p><pre><code class="language-swift">print("\n=== Total P&L Impact by Quarter ===")
print("Quarter\tInterest\tDepreciation\tTotal Expense")
print("-------\t--------\t------------\t-------------")

var totalInterest = 0.0
var totalDepreciation = 0.0

for (i, period) in periods.enumerated() {
    let interest = leaseWithCosts.interestExpense(period: period)
    let depreciation = leaseWithCosts.depreciation(period: period)
    let total = interest + depreciation

    totalInterest += interest
    totalDepreciation += depreciation

    let quarterNum = i + 1
    print("Q\(quarterNum)\t\(interest.currency())\t\(depreciation.currency())\t\(total.currency())")
}

print("\nTotal:\t\(totalInterest.currency())\t\(totalDepreciation.currency())\t\((totalInterest + totalDepreciation).currency())")

print("\n** Note: Expense is front-loaded due to higher interest in early periods")
</code></pre><p><strong>Output:</strong></p><pre><code>=== Total P&L Impact by Quarter ===
Quarter	Interest	Depreciation	Total Expense
-------	--------	------------	-------------
2025-Q1   $1,445         $27,840          $29,285
2025-Q2   $1,092         $27,840          $28,932
2025-Q3     $733         $27,840          $28,573
2025-Q4     $369         $27,840          $28,209

 Total:   $3,640        $111,360         $115,000

** Note: Expense is front-loaded due to higher interest in early periods
</code></pre><p><strong>The insight</strong>: Total expense ($115k) exceeds cash payments ($100k) because we‚Äôre expensing the upfront costs ($15k) over the lease term.</p><hr /><h3>Short-Term Lease Exemption</h3><p>Leases of 12 months or less can be expensed instead of capitalized:</p><pre><code class="language-swift">let shortTermLease = Lease(
    payments: payments,  // 4 quarterly payments = 12 months
    discountRate: 0.06,
    leaseTerm: .months(12)
)

if shortTermLease.isShortTerm {
    print("\n‚úì Qualifies for short-term exemption")
    print("Can expense payments as incurred without capitalizing")

    // No balance sheet impact
    let rouAsset = shortTermLease.rightOfUseAsset()  // Returns 0
    print("ROU asset: \(rouAsset.currency())")
} else {
    print("Must capitalize lease")
}
</code></pre><p><strong>Output:</strong></p><pre><code>‚úì Qualifies for short-term exemption
Can expense payments as incurred without capitalizing
ROU asset: $0.00
</code></pre><p><strong>The rule</strong>: Leases ‚â§ 12 months can be treated as operating expenses (no capitalization required).</p><hr /><h3>Low-Value Lease Exemption</h3><p>Leases of assets valued under $5,000 can also be expensed:</p><pre><code class="language-swift">// Small equipment lease
let lowValueLease = Lease(
    payments: payments,
    discountRate: 0.06,
    underlyingAssetValue: 4_500.0  // Below $5K threshold
)

if lowValueLease.isLowValue {
    print("\n‚úì Qualifies for low-value exemption")
    print("Underlying asset value: \(lowValueLease.underlyingAssetValue!.currency())")
    print("Can expense payments as incurred")
}
</code></pre><p><strong>Output:</strong></p><pre><code>‚úì Qualifies for low-value exemption
Underlying asset value: $4,500.00
Can expense payments as incurred
</code></pre><p><strong>The rule</strong>: Assets with fair value < $5,000 when new (e.g., laptops, small office equipment) can be expensed.</p><hr /><h3>Discount Rate Selection</h3><p>The discount rate significantly impacts lease valuation:</p><pre><code class="language-swift">print("\n=== Impact of Discount Rate ===")

// Conservative rate (lower discount = higher PV)
let lowRate = Lease(payments: payments, discountRate: 0.04)

// Market rate
let marketRate = Lease(payments: payments, discountRate: 0.06)

// Riskier rate (higher discount = lower PV)
let highRate = Lease(payments: payments, discountRate: 0.10)

print("At 4% rate: \(lowRate.presentValue().currency())")
print("At 6% rate: \(marketRate.presentValue().currency())")
print("At 10% rate: \(highRate.presentValue().currency())")

let difference = lowRate.presentValue() - highRate.presentValue()
print("\nDifference between 4% and 10%: \(difference.currency())")
</code></pre><p><strong>Output:</strong></p><pre><code>=== Impact of Discount Rate ===
At 4% rate: $97,549.14
At 6% rate: $96,359.62
At 10% rate: $94,049.36

Difference between 4% and 10%: $3,499.78
</code></pre><p><strong>The insight</strong>: Higher discount rates reduce the present value (and thus the balance sheet liability). Companies often use their incremental borrowing rate (IBR).</p><hr /><h3>Multi-Year Lease with Escalations</h3><p>Real-world leases often have annual rent increases:</p><pre><code class="language-swift">// 5-year office lease with 3% annual escalation
let startDate = Period.quarter(year: 2025, quarter: 1)
let fiveYearPeriods = (0..<20).map { startDate + $0 }  // 20 quarters

// Generate escalating payments
var escalatingPayments: [Double] = []
let baseRent = 30_000.0

for i in 0..<20 {
    let yearIndex = i / 4  // Which year (0-4)
    let escalatedRent = baseRent * pow(1.03, Double(yearIndex))
    escalatingPayments.append(escalatedRent)
}

let paymentSeries = TimeSeries(periods: fiveYearPeriods, values: escalatingPayments)

let longTermLease = Lease(
    payments: paymentSeries,
    discountRate: 0.068,  // 6.8% IBR
    initialDirectCosts: 15_000.0,
    prepaidAmount: 30_000.0
)

let liability = longTermLease.presentValue()
let rouAsset = longTermLease.rightOfUseAsset()

print("\n=== 5-Year Office Lease ===")
print("Base quarterly rent: \(baseRent.currency())")
print("Total payments (nominal): \(paymentSeries.reduce(0, +).currency())")
print("Present value: \(liability.currency())")
print("ROU asset: \(rouAsset.currency())")
print("\nDiscount: \((paymentSeries.reduce(0, +) - liability).currency()) (\((1 - liability / paymentSeries.reduce(0, +)).percent(1)))")
</code></pre><p><strong>Output:</strong></p><pre><code>=== 5-Year Office Lease ===
Base quarterly rent: $30,000.00
Total payments (nominal): $637,096.30
Present value: $534,140.43
ROU asset: $579,140.43

Discount: $102,955.86 (16.2%)
</code></pre><p><strong>The reality</strong>: Over 5 years, the present value is ~24% less than nominal payments due to time value of money.</p><hr /><h2>Try It Yourself</h2><p>Copy these to an Xcode playground and experiment:</p><pre><code>‚Üí Full API Reference: BusinessMath Docs ‚Äì 3.6 Lease Accounting
</code></pre><p><strong>Modifications to try</strong>:</p><ol><li>Model your company‚Äôs actual office lease</li><li>Compare finance lease vs. operating lease treatment</li><li>Analyze lease-vs-buy decisions for equipment</li><li>Model lease modifications (extensions, rent reductions)</li></ol><hr /><h2>Real-World Application</h2><p>Every public company with leases must comply with IFRS 16 / ASC 842:</p><ul><li><strong>Retailers</strong>: Store leases (hundreds or thousands)</li><li><strong>Airlines</strong>: Aircraft leases (multi-billion dollar liabilities)</li><li><strong>Tech companies</strong>: Office space, data centers</li><li><strong>Manufacturing</strong>: Equipment leases</li></ul><p><strong>Example - Delta Air Lines</strong>: Adopted ASC 842 and added $8.5 billion in lease liabilities to the balance sheet. Their debt-to-equity ratio instantly increased from 1.5x to 2.8x.</p><p><strong>CFO use case</strong>: ‚ÄúWe have 250 office leases across 30 countries. I need to calculate the total lease liability and ROU asset for our quarterly 10-Q filing, broken down by currency and region.‚Äù</p><p>BusinessMath makes this programmatic, auditable, and reproducible.</p><hr /><p><code>‚òÖ Insight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><p><strong>Why the New Lease Accounting Standards?</strong></p><p>Under old rules (IAS 17 / FAS 13), operating leases were off-balance-sheet.</p><p>This meant:</p><ul><li><strong>Hidden leverage</strong>: Airlines had billions in lease obligations not on the balance sheet</li><li><strong>Comparability issues</strong>: Two identical companies with different lease-vs-buy decisions looked completely different financially</li><li><strong>Analyst adjustments</strong>: Every analyst had to manually capitalize operating leases to compare companies</li></ul><p>IFRS 16 / ASC 842 solved this by requiring capitalization of virtually all leases. Now the balance sheet reflects the economic reality: if you have the right to use an asset and an obligation to pay, that‚Äôs an asset and liability.</p><p><strong>Trade-off</strong>: More complexity, but greater transparency.</p><p><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><hr /><h3>üìù Development Note</h3><p>The hardest design decision for lease accounting was: <strong>How much to embed accounting rules in the API vs. leaving flexibility?</strong></p><p><strong>Example dilemma</strong>: Should <code>Lease.rightOfUseAsset()</code> automatically include initial direct costs? Or require the user to add them separately?</p><p>We chose <strong>automatic inclusion</strong> because:</p><ol><li>IFRS 16 / ASC 842 explicitly require it</li><li>Users who forget will have incorrect financials</li><li>Edge cases can override with optional parameters</li></ol><p>But this means the API embeds accounting assumptions. If standards change (e.g., IFRS 17 for insurance), the API must evolve.</p><p><strong>The lesson</strong>: For domain-specific APIs (accounting, tax, legal), embedding rules improves correctness but reduces flexibility. Choose based on your users‚Äô expertise‚ÄîCPAs benefit from enforced rules; accountants building custom models need flexibility.</p><p><strong>Related Methodology</strong>: <a href="../../week-01/02-tue-test-first-development">Test-First Development</a> (Week 1) - We wrote failing tests for IFRS 16 requirements first, ensuring compliance.</p><hr /><h2>Next Steps</h2><p><strong>Coming up next week</strong>: Week 5 explores loans, investments, and valuation techniques.</p><p><strong>Monday</strong>: Loan Amortization - Building schedules for mortgages, car loans, and term loans.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 4/12</li><li>Posts Published: 15/~48</li><li>Topics Covered: Foundation + Analysis + Operational + Financial Statements (complete)</li><li>Playgrounds: 14 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-04/02-wed-financial-statements</guid><title>Building Financial Statements</title><link>https://www.justinpurnell.com/BusinessMath/week-04/02-wed-financial-statements</link><description><![CDATA[Part 14 of 12-Week BusinessMath Series]]></description><pubDate>Wed, 28 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[income-statement]]></category><category><![CDATA[balance-sheet]]></category><category><![CDATA[cash-flow]]></category><category><![CDATA[financial-modeling]]></category><content:encoded><![CDATA[<p><strong>Part 14 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>Creating Income Statements with revenue and expense accounts</li><li>Building Balance Sheets with assets, liabilities, and equity</li><li>Modeling Cash Flow Statements with operating, investing, and financing activities</li><li>Verifying the accounting equation (Assets = Liabilities + Equity)</li><li>Computing key metrics automatically from statements</li></ul><hr /><h2>The Problem</h2><p>Financial statements are the foundation of business analysis. Every valuation, credit decision, and strategic plan starts with:</p><ul><li><strong>Income Statement</strong>: Is the company profitable?</li><li><strong>Balance Sheet</strong>: What does the company own and owe?</li><li><strong>Cash Flow Statement</strong>: Is the company generating cash?</li></ul><p>Building these statements manually is tedious and error-prone. You need to:</p><ul><li>Track accounts across multiple periods</li><li>Ensure accounts are properly classified</li><li>Calculate subtotals (gross profit, operating income, EBITDA)</li><li>Verify accounting equations balance</li><li>Compute ratios from the statements</li></ul><p><strong>You need a structured, type-safe way to model financial statements programmatically.</strong></p><hr /><h2>The Solution</h2><p>BusinessMath provides <code>IncomeStatement</code>, <code>BalanceSheet</code>, and <code>CashFlowStatement</code> types that handle classification, computation, and validation automatically.</p><h3>Creating an Entity</h3><p>Every financial model starts with an entity:</p><pre><code class="language-swift">import BusinessMath

let acme = Entity(
    id: "ACME001",
    primaryType: .ticker,
    name: "Acme Corporation",
    identifiers: [.ticker: "ACME"],
    currency: "USD"
)
</code></pre><hr /><h3>Building an Income Statement</h3><p>The Income Statement shows profitability over time:</p><pre><code class="language-swift">// Define periods
let q1 = Period.quarter(year: 2025, quarter: 1)
let q2 = Period.quarter(year: 2025, quarter: 2)
let q3 = Period.quarter(year: 2025, quarter: 3)
let q4 = Period.quarter(year: 2025, quarter: 4)
let periods = [q1, q2, q3, q4]

// Revenue account
let revenue = try Account(
    entity: acme,
    name: "Product Revenue",
    incomeStatementRole: .productRevenue,
    timeSeries: TimeSeries(
        periods: periods,
        values: [1_000_000, 1_100_000, 1_200_000, 1_300_000]
    )
)

// Cost of Goods Sold
let cogs = try Account(
    entity: acme,
    name: "Cost of Goods Sold",
    incomeStatementRole: .costOfGoodsSold,
    timeSeries: TimeSeries(
        periods: periods,
        values: [400_000, 440_000, 480_000, 520_000]
    )
)

// Operating Expenses
let salaries = try Account(
    entity: acme,
    name: "Salaries",
    incomeStatementRole: .generalAndAdministrative,
    timeSeries: TimeSeries(
        periods: periods,
        values: [200_000, 200_000, 200_000, 200_000]
    )
)

let marketing = try Account(
    entity: acme,
    name: "Marketing",
    incomeStatementRole: .salesAndMarketing,
    timeSeries: TimeSeries(
        periods: periods,
        values: [50_000, 60_000, 70_000, 80_000]
    )
)

let depreciation = try Account(
    entity: acme,
    name: "Depreciation",
    incomeStatementRole: .depreciationAmortization,
    timeSeries: TimeSeries(
        periods: periods,
        values: [50_000, 50_000, 50_000, 50_000]
    )
)

// Interest and Taxes
let interestExpense = try Account(
    entity: acme,
    name: "Interest Expense",
    incomeStatementRole: .interestExpense,
    timeSeries: TimeSeries(
        periods: periods,
        values: [10_000, 10_000, 10_000, 10_000]
    )
)

let incomeTax = try Account(
    entity: acme,
    name: "Income Tax",
    incomeStatementRole: .incomeTaxExpense,
    timeSeries: TimeSeries(
        periods: periods,
        values: [60_000, 69_000, 78_000, 87_000]
    )
)

// Create Income Statement
let incomeStatement = try IncomeStatement(
    entity: acme,
    periods: periods,
    accounts: [revenue, cogs, salaries, marketing, depreciation, interestExpense, incomeTax]
)

// Access computed values
print("=== Q1 2025 Income Statement ===\n")
print("Revenue:\t\t\(incomeStatement.totalRevenue[q1]!.currency())")
print("COGS:\t\t\t(\(cogs.timeSeries[q1]!.currency()))")
print("Gross Profit:\t\t\(incomeStatement.grossProfit[q1]!.currency())")
print("  Gross Margin:\t\t\(incomeStatement.grossMargin[q1]!.percent(1))")
print()
print("Operating Expenses:\t(\((salaries.timeSeries[q1]! + marketing.timeSeries[q1]! + depreciation.timeSeries[q1]!).currency()))")
print("Operating Income:\t\(incomeStatement.operatingIncome[q1]!.currency())")
print("  Operating Margin:\t\(incomeStatement.operatingMargin[q1]!.percent(1))")
print()
print("EBITDA:\t\t\t\(incomeStatement.ebitda[q1]!.currency())")
print("  EBITDA Margin:\t\t\(incomeStatement.ebitdaMargin[q1]!.percent(1))")
print()
print("Interest Expense:\t(\(interestExpense.timeSeries[q1]!.currency()))")
print("Income Tax:\t\t(\(incomeTax.timeSeries[q1]!.currency()))")
print("Net Income:\t\t\(incomeStatement.netIncome[q1]!.currency())")
print("  Net Margin:\t\t\(incomeStatement.netMargin[q1]!.percent(1))")
</code></pre><p><strong>Output:</strong></p><pre><code>=== Q1 2025 Income Statement ===

Revenue:		$1,000,000
COGS:			($400,000)
Gross Profit:		$600,000
  Gross Margin:		60.0%

Operating Expenses:	($300,000)
Operating Income:	$300,000
  Operating Margin:	30.0%

EBITDA:			$350,000
  EBITDA Margin:		35.0%

Interest Expense:	($10,000)
Income Tax:		($60,000)
Net Income:		$230,000
  Net Margin:		23.0%
</code></pre><p><strong>The power</strong>: Income Statement automatically computes gross profit, operating income, EBITDA, and all margins. No manual calculations.</p><hr /><h3>Building a Balance Sheet</h3><p>The Balance Sheet shows financial position:</p><pre><code class="language-swift">// Assets
let cash = try Account(
    entity: acme,
    name: "Cash and Equivalents",
    balanceSheetRole: .cashAndEquivalents,
    timeSeries: TimeSeries(
        periods: periods,
        values: [500_000, 600_000, 750_000, 900_000]
    )
)

let receivables = try Account(
    entity: acme,
    name: "Accounts Receivable",
    balanceSheetRole: .accountsReceivable,
    timeSeries: TimeSeries(
        periods: periods,
        values: [300_000, 330_000, 360_000, 390_000]
    )
)

let inventory = try Account(
    entity: acme,
    name: "Inventory",
    balanceSheetRole: .inventory,
    timeSeries: TimeSeries(
        periods: periods,
        values: [200_000, 220_000, 240_000, 260_000]
    )
)

let ppe = try Account(
    entity: acme,
    name: "Property, Plant & Equipment",
    balanceSheetRole: .propertyPlantEquipment,
    timeSeries: TimeSeries(
        periods: periods,
        values: [1_000_000, 980_000, 960_000, 940_000]
    )
)

// Liabilities
let payables = try Account(
    entity: acme,
    name: "Accounts Payable",
    balanceSheetRole: .accountsPayable,
    timeSeries: TimeSeries(
        periods: periods,
        values: [150_000, 165_000, 180_000, 195_000]
    )
)

let longTermDebt = try Account(
    entity: acme,
    name: "Long-term Debt",
    balanceSheetRole: .longTermDebt,
    timeSeries: TimeSeries(
        periods: periods,
        values: [500_000, 500_000, 500_000, 500_000]
    )
)

// Equity
let commonStock = try Account(
    entity: acme,
    name: "Common Stock",
    balanceSheetRole: .commonStock,
    timeSeries: TimeSeries(
        periods: periods,
        values: [1_000_000, 1_000_000, 1_000_000, 1_000_000]
    )
)

let retainedEarnings = try Account(
    entity: acme,
    name: "Retained Earnings",
    balanceSheetRole: .retainedEarnings,
    timeSeries: TimeSeries(
        periods: periods,
        values: [350_000, 465_000, 630_000, 805_000]
    )
)

// Create Balance Sheet
let balanceSheet = try BalanceSheet(
    entity: acme,
    periods: periods,
    accounts: [cash, receivables, inventory, ppe, payables, longTermDebt, commonStock, retainedEarnings]
)

// Print Balance Sheet
print("\n=== Q1 2025 Balance Sheet ===\n")
print("ASSETS")
print("Current Assets:")
print("  Cash:\t\t\t\(cash.timeSeries[q1]!.currency())")
print("  Receivables:\t\t\(receivables.timeSeries[q1]!.currency())")
print("  Inventory:\t\t\(inventory.timeSeries[q1]!.currency())")
print("  Total Current:\t\(balanceSheet.currentAssets[q1]!.currency())")
print()
print("Fixed Assets:")
print("  PP&E:\t\t\t\(ppe.timeSeries[q1]!.currency())")
print()
print("Total Assets:\t\t\(balanceSheet.totalAssets[q1]!.currency())")
print()
print("LIABILITIES")
print("Current Liabilities:")
print("  Payables:\t\t\(payables.timeSeries[q1]!.currency())")
print()
print("Long-term Liabilities:")
print("  Debt:\t\t\t\(longTermDebt.timeSeries[q1]!.currency())")
print()
print("Total Liabilities:\t\(balanceSheet.totalLiabilities[q1]!.currency())")
print()
print("EQUITY")
print("  Common Stock:\t\t\(commonStock.timeSeries[q1]!.currency())")
print("  Retained Earnings:\t\(retainedEarnings.timeSeries[q1]!.currency())")
print("Total Equity:\t\t\(balanceSheet.totalEquity[q1]!.currency())")
print()
print("Total Liab + Equity:\t\((balanceSheet.totalLiabilities[q1]! + balanceSheet.totalEquity[q1]!).currency()))")

// Verify accounting equation
let assets = balanceSheet.totalAssets[q1]!
let liabilities = balanceSheet.totalLiabilities[q1]!
let equity = balanceSheet.totalEquity[q1]!

print("\n‚úì Balance Check: Assets (\(assets.currency())) = Liabilities + Equity (\((liabilities + equity).currency()))")
print("  Balanced: \(assets == liabilities + equity)")

// Calculate ratios
print("\nKey Ratios:")
print("  Current Ratio:\t\t\(balanceSheet.currentRatio[q1]!.number(2))x")
print("  Debt-to-Equity:\t\t\(balanceSheet.debtToEquity[q1]!.number(2))x")
print("  Equity Ratio:\t\t\(balanceSheet.equityRatio[q1]!.percent(1))")
</code></pre><p><strong>Output:</strong></p><pre><code>=== Q1 2025 Balance Sheet ===

ASSETS
Current Assets:
  Cash:			$500,000
  Receivables:		$300,000
  Inventory:		$200,000
  Total Current:	$1,000,000

Fixed Assets:
  PP&E:			$1,000,000

Total Assets:		$2,000,000

LIABILITIES
Current Liabilities:
  Payables:		$150,000

Long-term Liabilities:
  Debt:			$500,000

Total Liabilities:	$650,000

EQUITY
  Common Stock:		$1,000,000
  Retained Earnings:	$350,000
Total Equity:		$1,350,000

Total Liab + Equity:	$2,000,000

‚úì Balance Check: Assets ($2,000,000) = Liabilities + Equity ($2,000,000)
  Balanced: true

Key Ratios:
  Current Ratio:		6.67x
  Debt-to-Equity:		0.37x
  Equity Ratio:		67.5%
</code></pre><p><strong>The insight</strong>: Balance Sheet automatically validates Assets = Liabilities + Equity and computes liquidity/leverage ratios.</p><hr /><h3>Linking Statements Together</h3><p>Retained Earnings bridges Income Statement and Balance Sheet:</p><pre><code class="language-swift">// Verify retained earnings flow
let beginningRE = retainedEarnings.timeSeries[q1]!  // $350,000
let netIncome = incomeStatement.netIncome[q1]!      // $230,000 (calculated earlier)
let dividends = 0.0  // No dividends paid in Q1
let endingRE = retainedEarnings.timeSeries[q2]!     // $465,000

let calculatedEndingRE = beginningRE + netIncome - dividends

print("\n=== Retained Earnings Reconciliation ===")
print("Beginning (Q1): \(beginningRE.currency())")
print("+ Net Income:   \(netIncome.currency())")
print("- Dividends:    \(dividends.currency())")
print("= Ending (Q2):  \(calculatedEndingRE.currency())")
print("\nActual Q2 RE:   \(endingRE.currency())")
print("Difference:     \((endingRE - calculatedEndingRE).currency())")
</code></pre><p><strong>This links the statements</strong>: Net income flows from Income Statement ‚Üí Retained Earnings on Balance Sheet.</p><hr /><h2>Try It Yourself</h2><p>Copy this to an Xcode playground and experiment:</p><pre><code>‚Üí Full API Reference: BusinessMath Docs ‚Äì 3.5 Financial Statements
</code></pre><p><strong>Modifications to try</strong>:</p><ol><li>Add a Cash Flow Statement with operating, investing, and financing activities</li><li>Model multiple years of annual statements</li><li>Create pro forma statements for forecasting</li></ol><hr /><h2>Real-World Application</h2><p>Every three-statement model starts here:</p><ul><li><strong>Investment banking</strong>: Modeling LBO returns</li><li><strong>Corporate finance</strong>: Budgeting and planning</li><li><strong>Equity research</strong>: Forecasting earnings</li><li><strong>Credit analysis</strong>: Assessing solvency</li></ul><p>BusinessMath makes statement modeling type-safe, validated, and composable.</p><hr /><p><code>‚òÖ Insight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><p><strong>Why Use Role Enums Instead of Generic Types?</strong></p><p>You could use generic <code>type: .expense</code> for all expenses.</p><p>But role-specific enums provide:</p><ul><li><strong>Explicit classification</strong>: <code>incomeStatementRole: .costOfGoodsSold</code> makes intent clear</li><li><strong>Type safety</strong>: Can‚Äôt accidentally treat COGS as operating expense</li><li><strong>Automatic aggregation</strong>: Multiple accounts with same role aggregate automatically</li><li><strong>Multi-role capability</strong>: Same account (e.g., D&A) can have both Income Statement and Cash Flow roles</li><li><strong>Statement validation</strong>: Ensures only valid roles are used per statement type</li></ul><p>This prevents errors like classifying interest as operating expense or mixing incompatible accounts.</p><p><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><hr /><h3>üìù Development Note</h3><p>The hardest part of financial statement modeling was deciding: <strong>How much abstraction?</strong></p><p>We could have made a single <code>FinancialStatements</code> class with all three statements bundled. But different analyses need different statements:</p><ul><li><strong>Valuation</strong>: Needs Income Statement and Cash Flow Statement</li><li><strong>Credit analysis</strong>: Needs Balance Sheet and Cash Flow Statement</li><li><strong>Profitability</strong>: Needs only Income Statement</li></ul><p>We chose <strong>separate statement types</strong> that compose when needed. More flexible, slightly more verbose.</p><p><strong>Related Methodology</strong>: <a href="../../week-03/02-tue-master-plan">The Master Plan</a> (Week 3) - Managing API surface area</p><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: <a href="../03-fri-lease-accounting">Lease Accounting (Friday) - IFRS 16 / ASC 842</a> lease modeling with right-of-use assets and lease liabilities.</p><p><strong>Next week</strong>: Week 5 explores loans, investments, and valuations.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 4/12</li><li>Posts Published: 14/~48</li><li>Topics Covered: Foundation + Analysis + Operational + Financial Statements (in progress)</li><li>Playgrounds: 13 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-04/01-mon-financial-reports</guid><title>Building Multi-Period Financial Reports</title><link>https://www.justinpurnell.com/BusinessMath/week-04/01-mon-financial-reports</link><description><![CDATA[Part 13 of 12-Week BusinessMath Series]]></description><pubDate>Mon, 26 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[financial-reports]]></category><category><![CDATA[financial-statements]]></category><category><![CDATA[metrics]]></category><content:encoded><![CDATA[<p><strong>Part 13 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>Creating comprehensive financial reports with period summaries</li><li>Building multi-period reports for trend analysis</li><li>Tracking operational metrics alongside financial statements</li><li>Calculating growth rates and margin trends</li><li>Generating analyst-style financial summaries</li></ul><hr /><h2>The Problem</h2><p>Financial analysis isn‚Äôt just about individual statements‚Äîit‚Äôs about <strong>trends, comparisons, and integrated metrics</strong>. Analysts need to see:</p><ul><li><strong>Quarter-over-quarter growth</strong>: Is revenue accelerating or decelerating?</li><li><strong>Margin trends</strong>: Are we expanding or compressing margins?</li><li><strong>Leverage evolution</strong>: Is debt increasing relative to EBITDA?</li><li><strong>Operational drivers</strong>: What metrics drive the financials?</li></ul><p>Building comprehensive multi-period reports manually can be tedious. You need financial statements, operational metrics, computed ratios, and trend calculations‚Äîall integrated into a cohesive view.</p><p><strong>BusinessMath provides a system that combines statements, metrics, and analytics automatically.</strong></p><hr /><h2>The Solution</h2><p>BusinessMath provides <code>FinancialPeriodSummary</code> and <code>MultiPeriodReport</code> for analyst-quality financial reporting.</p><h3>Step 1: Create Financial Statements</h3><p>Start with Income Statement and Balance Sheet for multiple periods:</p><pre><code class="language-swift">import BusinessMath

let entity = Entity(
    id: "ACME",
    primaryType: .ticker,
    name: "Acme Corporation"
)

let periods = (1...4).map { Period.quarter(year: 2025, quarter: $0) }

// Revenue account
let revenue = try Account(
    entity: entity,
    name: "Product Revenue",
    incomeStatementRole: .revenue,
    timeSeries: TimeSeries(periods: periods, values: [1_000_000, 1_100_000, 1_200_000, 1_300_000])
)

// Expense accounts
let cogs = try Account(
    entity: entity,
    name: "Cost of Goods Sold",
    incomeStatementRole: .costOfGoodsSold,
    timeSeries: TimeSeries(periods: periods, values: [400_000, 450_000, 480_000, 520_000])
)

let opex = try Account(
    entity: entity,
    name: "Operating Expenses",
    incomeStatementRole: .operatingExpenseOther,
    timeSeries: TimeSeries(periods: periods, values: [300_000, 325_000, 350_000, 375_000])
)

let depreciation = try Account(
    entity: entity,
    name: "Depreciation",
    incomeStatementRole: .depreciationAmortization,
    timeSeries: TimeSeries(periods: periods, values: [50_000, 50_000, 50_000, 50_000])
)

let interest = try Account(
    entity: entity,
    name: "Interest Expense",
    incomeStatementRole: .interestExpense,
    timeSeries: TimeSeries(periods: periods, values: [25_000, 25_000, 25_000, 25_000])
)

let tax = try Account(
    entity: entity,
    name: "Income Tax",
    incomeStatementRole: .incomeTaxExpense,
    timeSeries: TimeSeries(periods: periods, values: [47_000, 49_000, 61_000, 68_000])
)

// Create Income Statement
let incomeStatement = try IncomeStatement(
	entity: entity,
	periods: periods,
	accounts: [revenue, cogs, opex, depreciation, interest, tax]
)

// Create Balance Sheet (assets, liabilities, equity)
let cash = try Account(
    entity: entity,
    name: "Cash",
    balanceSheetRole: .cashAndEquivalents,
    timeSeries: TimeSeries(periods: periods, values: [500_000, 600_000, 750_000, 900_000])
)

let receivables = try Account(
    entity: entity,
    name: "Receivables",
    balanceSheetRole: .accountsReceivable,
    timeSeries: TimeSeries(periods: periods, values: [300_000, 330_000, 360_000, 390_000])
)

let ppe = try Account(
    entity: entity,
    name: "PP&E",
    balanceSheetRole: .propertyPlantEquipment,
    timeSeries: TimeSeries(periods: periods, values: [1_000_000, 980_000, 960_000, 940_000])
)

let payables = try Account(
    entity: entity,
    name: "Payables",
    balanceSheetRole: .accountsPayable,
    timeSeries: TimeSeries(periods: periods, values: [200_000, 220_000, 240_000, 260_000])
)

let debt = try Account(
    entity: entity,
    name: "Long-Term Debt",
    balanceSheetRole: .longTermDebtNoncurrent,
    timeSeries: TimeSeries(periods: periods, values: [500_000, 500_000, 500_000, 500_000])
)

let equity = try Account(
    entity: entity,
    name: "Equity",
    balanceSheetRole: .retainedEarnings,
    timeSeries: TimeSeries(periods: periods, values: [1_100_000, 1_190_000, 1_330_000, 1_470_000])
)

let balanceSheet = try BalanceSheet(
	entity: entity,
	periods: periods,
	accounts: [cash, receivables, ppe, payables, debt, equity]
)
</code></pre><hr /><h3>Step 2: Add Operational Metrics</h3><p>Track business drivers that explain the financials:</p><pre><code class="language-swift">// Define operational metrics for each quarter
let q1Metrics = OperationalMetrics<Double>(
    entity: entity,
    period: periods[0],
    metrics: [
        "units_sold": 10_000,
        "average_price": 100.0,
        "customer_count": 500,
        "average_revenue_per_customer": 2_000
    ]
)

let q2Metrics = OperationalMetrics<Double>(
    entity: entity,
    period: periods[1],
    metrics: [
        "units_sold": 11_000,
        "average_price": 100.0,
        "customer_count": 550,
        "average_revenue_per_customer": 2_000
    ]
)

let q3Metrics = OperationalMetrics<Double>(
    entity: entity,
    period: periods[2],
    metrics: [
        "units_sold": 12_000,
        "average_price": 100.0,
        "customer_count": 600,
        "average_revenue_per_customer": 2_000
    ]
)

let q4Metrics = OperationalMetrics<Double>(
    entity: entity,
    period: periods[3],
    metrics: [
        "units_sold": 13_000,
        "average_price": 100.0,
        "customer_count": 650,
        "average_revenue_per_customer": 2_000
    ]
)

let operationalMetrics = [q1Metrics, q2Metrics, q3Metrics, q4Metrics]
</code></pre><p><strong>The insight</strong>: Operational metrics explain the financials. Revenue growth comes from adding 150 customers (30% increase) while maintaining price.</p><hr /><h3>Step 3: Create Financial Period Summary</h3><p>Combine statements and metrics into a comprehensive one-pager:</p><pre><code class="language-swift">let q1Summary = try FinancialPeriodSummary(
    entity: entity,
    period: periods[0],
    incomeStatement: incomeStatement,
    balanceSheet: balanceSheet,
    operationalMetrics: q1Metrics
)

print("=== Q1 2025 Financial Summary ===\n")
print("Revenue: \(q1Summary.revenue.currency())")
print("Gross Profit: \(q1Summary.grossProfit.currency())")
print("EBITDA: \(q1Summary.ebitda.currency())")
print("EBIT: \(q1Summary.operatingIncome.currency())")
print("Net Income: \(q1Summary.netIncome.currency())")
print()
print("Margins:")
print("  Gross Margin: \(q1Summary.grossMargin.percent(1))")
print("  Operating Margin: \(q1Summary.operatingMargin.percent(1))")
print("  Net Margin: \(q1Summary.netMargin.percent(1))")
print()
print("Returns:")
print("  ROA: \(q1Summary.roa.percent(1))")
print("  ROE: \(q1Summary.roe.percent(1))")
print()
print("Leverage:")
print("  Debt/Equity: \(q1Summary.debtToEquityRatio.number(2))x")
print("  Debt/EBITDA: \(q1Summary.debtToEBITDARatio.number(2))x")
print("  EBIT Interest Coverage: \(q1Summary.interestCoverageRatio!.number(1))x")
print()
print("Liquidity:")
print("  Current Ratio: \(q1Summary.currentRatio.number(2))x")
</code></pre><p><strong>Output:</strong></p><pre><code>=== Q1 2025 Financial Summary ===

Revenue: $1,000,000.00
Gross Profit: $600,000.00
EBITDA: $300,000.00
EBIT: $250,000.00
Net Income: $178,000.00

Margins:
  Gross Margin: 60.0%
  Operating Margin: 25.0%
  Net Margin: 17.8%

Returns:
  ROA: 9.9%
  ROE: 16.2%

Leverage:
  Debt/Equity: 0.45x
  Debt/EBITDA: 1.67x
  EBIT Interest Coverage: 10.0x

Liquidity:
  Current Ratio: 4.00x
</code></pre><p><strong>The power</strong>: One <code>FinancialPeriodSummary</code> object gives you ~30 key metrics automatically computed.</p><hr /><h3>Step 4: Build Multi-Period Report</h3><p>Aggregate multiple periods for trend analysis:</p><pre><code class="language-swift">// Create summaries for all quarters
let summaries = try periods.indices.map { index in
    try FinancialPeriodSummary(
        entity: entity,
        period: periods[index],
        incomeStatement: incomeStatement,
        balanceSheet: balanceSheet,
        operationalMetrics: operationalMetrics[index]
    )
}

// Create multi-period report
let report = try MultiPeriodReport(
    entity: entity,
    periodSummaries: summaries
)

print("\n=== Acme Corporation - FY2025 Trends ===\n")
print("Periods analyzed: \(report.periodCount)")
</code></pre><hr /><h3>Step 5: Analyze Growth Rates</h3><p>Calculate period-over-period growth:</p><pre><code class="language-swift">// Revenue growth
let revenueGrowth = report.revenueGrowth()
print("\nRevenue Growth (Q-o-Q):")
for (index, growth) in revenueGrowth.enumerated() {
    let quarter = index + 2  // Q2, Q3, Q4
    print("  Q\(quarter): \(growth.percent(1))")
}

// EBITDA growth
let ebitdaGrowth = report.ebitdaGrowth()
print("\nEBITDA Growth (Q-o-Q):")
for (index, growth) in ebitdaGrowth.enumerated() {
    let quarter = index + 2
    print("  Q\(quarter): \(growth.percent(1))")
}

// Net income growth
let netIncomeGrowth = report.netIncomeGrowth()
print("\nNet Income Growth (Q-o-Q):")
for (index, growth) in netIncomeGrowth.enumerated() {
    let quarter = index + 2
    print("  Q\(quarter): \(growth.percent(1))")
}
</code></pre><p><strong>Output:</strong></p><pre><code>Periods analyzed: 4

Revenue Growth (Q-o-Q):
  Q2: 10.0%
  Q3: 9.1%
  Q4: 8.3%

EBITDA Growth (Q-o-Q):
  Q2: 8.3%
  Q3: 13.8%
  Q4: 9.5%

Net Income Growth (Q-o-Q):
  Q2: 12.9%
  Q3: 16.4%
  Q4: 12.0%
</code></pre><p><strong>The insight</strong>: Revenue growth is decelerating (10% ‚Üí 9.1% ‚Üí 8.3%), but net income growth is accelerating due to margin expansion.</p><hr /><h3>Step 6: Track Margin Trends</h3><p>Analyze margin evolution:</p><pre><code class="language-swift">// Margin trends
let grossMargins = report.grossMarginTrend()
let operatingMargins = report.operatingMarginTrend()
let netMargins = report.netMarginTrend()

	print("\n=== Margin Trend Analysis ===")
	print("Period\t\tGross\tOperating\t   Net")
	print("------\t\t-----\t---------\t-------")
	for i in 0...(periods.count - 1) {
		let quarter = i + 1
		print("Q\(quarter)\(grossMargins[i].percent(1).paddingLeft(toLength: 15))\(operatingMargins[i].percent(1).paddingLeft(toLength: 12))\(netMargins[i].percent(1).paddingLeft(toLength: 10))")
	}

// Calculate margin expansion (convert from decimal to basis points)
// 1 percentage point = 100 basis points, so multiply decimal by 10,000
let grossExpansion = (grossMargins[3] - grossMargins[0]) * 10000
let operatingExpansion = (operatingMargins[3] - operatingMargins[0]) * 10000
let netExpansion = (netMargins[3] - netMargins[0]) * 10000

print("\nMargin Expansion (Q1 ‚Üí Q4):")
print("  Gross: \(grossExpansion.number(0)) bps")
print("  Operating: \(operatingExpansion.number(0)) bps")
print("  Net: \(netExpansion.number(0)) bps")

</code></pre><p><strong>Output:</strong></p><pre><code>=== Margin Trend Analysis ===
Period		Gross	Operating	   Net
------		-----	---------	-------
Q1          60.0%       25.0%     17.8%
Q2          59.1%       25.0%     18.3%
Q3          60.0%       26.7%     19.5%
Q4          60.0%       27.3%     20.2%

Margin Expansion (Q1 ‚Üí Q4):
  Gross: 0 bps
  Operating: 231 bps
  Net: 235 bps
</code></pre><p><strong>The insight</strong>: Gross margin stable at 60%, while operating margin expanded 231 basis points (2.3 percentage points) and net margin expanded 235 basis points (2.4 percentage points) due to operating leverage and improving efficiency.</p><hr /><h2>Try It Yourself</h2><p>Copy this into a playground and experiment:</p><pre><code>‚Üí Full API Reference: BusinessMath Docs ‚Äì 3.4 Financial Reports
</code></pre><p><strong>Modifications to try</strong>:</p><ol><li>Add more operational metrics (customer acquisition cost, LTV)</li><li>Create annual reports instead of quarterly</li><li>Compare multiple companies side-by-side</li></ol><hr /><h2>Real-World Application</h2><p>This is how equity analysts create quarterly reports:</p><ul><li><strong>Equity and Credit research</strong>: 50-page reports start with one-page summary tables</li><li><strong>Earnings presentations</strong>: CFOs show this exact format to investors</li><li><strong>Internal dashboards</strong>: Management tracks these metrics monthly</li></ul><p>BusinessMath makes creating these reports programmatic and reproducible.</p><hr /><p><code>‚òÖ Insight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><p><strong>Why Separate Financial Statements from Reports?</strong></p><p><code>IncomeStatement</code> and <code>BalanceSheet</code> model the raw data.</p><p><code>FinancialPeriodSummary</code> computes derived metrics (EBITDA, ROE, ratios).</p><p><code>MultiPeriodReport</code> analyzes trends (growth rates, margin expansion).</p><p>This separation follows the <strong>Single Responsibility Principle</strong>:</p><ul><li>Statements = data containers</li><li>Summaries = metric calculators</li><li>Reports = trend analyzers</li></ul><p>Each layer adds value without bloating the lower layers.</p><p><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><hr /><h3>üìù Development Note</h3><p>The hardest design decision was: <strong>How opinionated should the report format be?</strong></p><p>We could have made <code>FinancialPeriodSummary</code> produce formatted output (tables, charts). But formatting requirements vary wildly:</p><ul><li>CLI tools want plain text</li><li>Web apps want HTML</li><li>iOS apps want SwiftUI views</li><li>Analysts want Excel exports</li></ul><p>We chose <strong>data-only output</strong>: <code>FinancialPeriodSummary</code> computes metrics and returns them as properties. You format however you want.</p><p>This makes the API flexible at the cost of requiring formatting code. Worth it.</p><p><strong>Related Methodology</strong>: <a href="../week-02/02-tue-documentation-as-design.md">Documentation as Design</a> (Week 2) - Designing APIs that users understand</p><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: <a href="../02-wed-financial-statements">Financial Statements Guide (Wednesday)</a> - Deep dive into Income Statement, Balance Sheet, and Cash Flow Statement.</p><p><strong>This week</strong>: <a href="../03-fri-lease-accounting">Lease Accounting (Friday)</a> - IFRS 16 / ASC 842 lease modeling.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 4/12</li><li>Posts Published: 13/~48</li><li>Topics Covered: Foundation + Analysis + Operational + Financial Statements (starting)</li><li>Playgrounds: 12 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/businessMath-Introduction</guid><title>Welcome to BusinessMath: A 12-Week Journey</title><link>https://www.justinpurnell.com/BusinessMath/businessMath-Introduction</link><description><![CDATA[Your roadmap to mastering financial calculations, statistical analysis, and optimization in Swift]]></description><pubDate>Mon, 26 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[introduction]]></category><content:encoded><![CDATA[<p><strong>Your roadmap to mastering financial calculations, statistical analysis, and optimization in Swift</strong></p><hr /><p>Welcome! Over the next twelve weeks, we‚Äôre going on a journey together‚Äîfrom calculating the basics of time value of money to building sophisticated portfolio optimizers and real-time trading systems. Whether you‚Äôre a Swift developer curious about financial mathematics, a business analyst looking to bring your calculations into code, or someone who just loves solving practical problems with elegant tools, this series is for you.</p><h2>What is BusinessMath?</h2><p>BusinessMath is a comprehensive Swift library that brings financial calculations, statistical analysis, and optimization algorithms to your fingertips. Need to calculate loan amortization schedules? Run Monte Carlo simulations? Optimize a portfolio under constraints? BusinessMath has you covered‚Äîwith clean, type-safe APIs that work across all Apple platforms.</p><p>But this library is more than just a collection of functions. It‚Äôs built on principles that matter: test-driven development, comprehensive documentation, and real-world applicability. Every calculation is tested, every API is documented, and every feature is designed to solve actual business problems.</p><h2>What to Expect</h2><p>This series spans <strong>12 weeks</strong> with <strong>3-4 posts per week</strong>, mixing technical deep-dives with real-world case studies:</p><p><strong>Weeks 1-2: Foundation</strong>We‚Äôll start with the essentials‚Äîtime series data, time value of money, and financial ratios. By the end of week 1, you‚Äôll build a complete retirement planning calculator.</p><p><strong>Weeks 3-5: Financial Modeling</strong>Learn to build growth models, revenue projections, and complete financial statements. We‚Äôll tackle real scenarios like capital equipment decisions and lease accounting.</p><p><strong>Weeks 6-8: Simulation & Optimization</strong>Monte Carlo simulations, scenario analysis, and portfolio optimization. The midpoint case study combines everything you‚Äôve learned into a $10M portfolio optimizer.</p><p><strong>Weeks 9-12: Advanced Topics</strong>Integer programming, particle swarm optimization, parallel processing, and performance tuning. We‚Äôll close with reflections on building production-quality software and a complete investment strategy DSL.</p><p>Every few posts, we‚Äôll pause for a <strong>case study</strong>‚Äîa complete, real-world scenario that combines multiple topics into a practical solution. By the end, you‚Äôll have tackled 6 substantial business problems, from retirement planning to real-time portfolio rebalancing.</p><h2>Why Follow Along?</h2><p>Each post is self-contained but builds on previous concepts. You‚Äôll get:</p><ul><li><strong>Runnable code examples</strong> you can try immediately</li><li><strong>Complete playgrounds</strong> to experiment and modify</li><li><strong>Links to comprehensive API documentation</strong> when you want to dive deeper</li><li><strong>Real business context</strong> that explains why each technique matters</li></ul><p>This isn‚Äôt just theory‚Äîit‚Äôs production-ready code solving real problems. And it‚Äôs designed to be accessible whether you‚Äôre implementing these calculations for the first time or you‚Äôre a seasoned financial engineer exploring Swift.</p><h2>Ready to Begin?</h2><p>We‚Äôll publish new posts <strong>Monday, Wednesday, Thursday, and Friday</strong>, with case studies every other Friday. Bookmark this series, follow along at your own pace, and don‚Äôt hesitate to experiment with the code. The best way to learn is by doing.</p><p>Let‚Äôs get started.</p><hr /><p><strong>Series Overview</strong>: 12 weeks | ~40 posts | 6 case studies | 11 major topics</p><p><strong>First Post</strong>: Week 1 ‚Äì <a href="../BusinessMath/week-01/01-mon-getting-started/">Getting Started with BusinessMath</a></p><p><em>Ready to dive in? Check out the first post where we cover installation, basic concepts, and your first calculations.</em></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-03/04-fri-case-capital-equipment</guid><title>Case Study: Capital Equipment Purchase Decision</title><link>https://www.justinpurnell.com/BusinessMath/week-03/04-fri-case-capital-equipment</link><description><![CDATA[Capstone #2 ‚Äì Combining TVM + Depreciation + Financial Analysis]]></description><pubDate>Fri, 23 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[case-study]]></category><category><![CDATA[capital-budgeting]]></category><category><![CDATA[depreciation]]></category><category><![CDATA[npv]]></category><category><![CDATA[roi]]></category><content:encoded><![CDATA[<p><strong>Capstone #2 ‚Äì Combining TVM + Depreciation + Financial Analysis</strong></p><hr /><h2>The Business Challenge</h2><p>TechMfg Inc., a manufacturing company, is evaluating a $500,000 investment in new automated production equipment. The CFO needs to answer:</p><ol><li><strong>Is this a good investment?</strong> (NPV, IRR, Payback Period)</li><li><strong>How does it affect our financial statements?</strong> (Depreciation, ROI, ROA)</li><li><strong>Should we lease or buy?</strong> (Compare alternatives)</li><li><strong>What if our assumptions are wrong?</strong> (Sensitivity analysis)</li></ol><p>Think of this as a real half-million dollar capital budgeting decision. Get it right, and you boost productivity and profitability for years.</p><hr /><h2>The Requirements</h2><p><strong>Stakeholders</strong>: CFO, Operations VP, Finance Committee</p><p><strong>Key Questions</strong>:</p><ul><li>What‚Äôs the NPV and IRR of this investment?</li><li>How long until we recover the initial cost?</li><li>How does depreciation affect reported earnings?</li><li>What if production volume is 20% lower than expected?</li><li>Should we lease instead?</li></ul><p><strong>Success Criteria</strong>:</p><ul><li>Complete financial analysis</li><li>NPV-based recommendation</li><li>Sensitivity to key assumptions</li><li>Lease vs. buy comparison</li></ul><hr /><h2>The Solution</h2><h3>Part 1: Setup and Assumptions</h3><p>First, define the investment parameters:</p><pre><code class="language-swift">import BusinessMath

print("=== CAPITAL EQUIPMENT DECISION ANALYSIS ===\n")

// Equipment Details
let purchasePrice = 500_000.0
let usefulLife = 7  // years
let salvageValue = 50_000.0

// Operating Assumptions
let annualProductionIncrease = 100_000.0  // units
let contributionMarginPerUnit = 6.0  // $ per unit
let annualMaintenanceCost = 15_000.0

// Financial Assumptions
let discountRate = 0.10  // 10% WACC
let taxRate = 0.25  // 25% corporate tax rate

print("Equipment Investment:")
print("- Purchase Price: \(purchasePrice.currency())")
print("- Useful Life: \(usefulLife) years")
print("- Salvage Value: \(salvageValue.currency())")
print()
print("Operating Assumptions:")
print("- Annual Production Increase: \(annualProductionIncrease.number(0)) units")
print("- Contribution Margin: \(contributionMarginPerUnit.currency())/unit")
print("- Annual Maintenance: \(annualMaintenanceCost.currency())")
print()
print("Financial Assumptions:")
print("- Discount Rate (WACC): \(discountRate.formatted(.percent))")
print("- Tax Rate: \(taxRate.formatted(.percent))")
print()
</code></pre><p><strong>Output:</strong></p><pre><code>=== CAPITAL EQUIPMENT DECISION ANALYSIS ===

Equipment Investment:
- Purchase Price: $500,000.00
- Useful Life: 7 years
- Salvage Value: $50,000.00

Operating Assumptions:
- Annual Production Increase: 100,000 units
- Contribution Margin: $6.00/unit
- Annual Maintenance: $15,000.00

Financial Assumptions:
- Discount Rate (WACC): 10%
- Tax Rate: 25%
</code></pre><hr /><h3>Part 2: Calculate Annual Cash Flows</h3><p>Determine cash inflows and outflows for each year:</p><pre><code class="language-swift">print("PART 1: Annual Cash Flow Analysis\n")

// Annual contribution margin from increased production
let annualRevenueBenefit = Double(annualProductionIncrease) * contributionMarginPerUnit
print("Annual Revenue Benefit: \(annualRevenueBenefit.currency())")

// Net annual operating cash flow (before tax)
let annualOperatingCashFlow = annualRevenueBenefit - annualMaintenanceCost
print("Annual Operating Cash Flow (pre-tax): \(annualOperatingCashFlow.currency())")

// Calculate depreciation using straight-line method
let annualDepreciation = (purchasePrice - salvageValue) / Double(usefulLife)
print("Annual Depreciation (straight-line): \(annualDepreciation.currency())")

// Taxable income = Operating cash flow - Depreciation
let annualTaxableIncome = annualOperatingCashFlow - annualDepreciation
print("Annual Taxable Income: \(annualTaxableIncome.currency())")

// Taxes
let annualTaxes = annualTaxableIncome * taxRate
print("Annual Taxes: \(annualTaxes.currency())")

// After-tax cash flow = Operating cash flow - Taxes
// (Note: Depreciation is added back because it's non-cash)
let annualAfterTaxCashFlow = annualOperatingCashFlow - annualTaxes
print("Annual After-Tax Cash Flow: \(annualAfterTaxCashFlow.currency())")
print()
</code></pre><p><strong>Output:</strong></p><pre><code>PART 1: Annual Cash Flow Analysis

Annual Revenue Benefit: $600,000.00
Annual Operating Cash Flow (pre-tax): $585,000.00
Annual Depreciation (straight-line): $64,285.71
Annual Taxable Income: $520,714.29
Annual Taxes: $130,178.57
Annual After-Tax Cash Flow: $454,821.43
</code></pre><p><strong>The insight</strong>: Equipment generates $585k annually before tax, but depreciation creates a tax shield that reduces taxes by ~$16k per year.</p><hr /><h3>Part 3: NPV and IRR Analysis</h3><p>Build the complete cash flow profile and evaluate:</p><pre><code class="language-swift">print("PART 2: NPV and IRR Analysis\n")

// Build cash flow array
var cashFlows = [-purchasePrice]  // Year 0: Initial investment

// Years 1-7: Annual after-tax cash flows
for _ in 1...usefulLife {
    cashFlows.append(annualAfterTaxCashFlow)
}

// Year 7: Add salvage value (assume no tax on salvage for simplicity)
cashFlows[cashFlows.count - 1] += salvageValue

print("Cash Flow Profile:")
for (year, cf) in cashFlows.enumerated() {
    let sign = cf >= 0 ? "+" : ""
    print("  Year \(year): \(sign)\(cf.currency())")
}
print()

// Calculate NPV
let npvValue = npv(discountRate: discountRate, cashFlows: cashFlows)
print("Net Present Value (NPV): \(npvValue.currency())")

if npvValue > 0 {
    print("‚úì ACCEPT: Positive NPV creates value")
} else {
    print("‚úó REJECT: Negative NPV destroys value")
}
print()

// Calculate IRR
let irrValue = try! irr(cashFlows: cashFlows)
print("Internal Rate of Return (IRR): \(irrValue.formatted(.percent.precision(.fractionLength(2))))")

if irrValue > discountRate {
    print("‚úì ACCEPT: IRR (\(irrValue.formatted(.percent))) > WACC (\(discountRate.formatted(.percent)))")
} else {
    print("‚úó REJECT: IRR < WACC")
}
print()
</code></pre><p><strong>Output:</strong></p><pre><code>PART 2: NPV and IRR Analysis

Cash Flow Profile:
  Year 0: ($500,000.00)
  Year 1: +$454,821.43
  Year 2: +$454,821.43
  Year 3: +$454,821.43
  Year 4: +$454,821.43
  Year 5: +$454,821.43
  Year 6: +$454,821.43
  Year 7: +$504,821.43  (includes $50k salvage)

Net Present Value (NPV): $1,739,919.11
‚úì ACCEPT: Positive NPV creates value

Internal Rate of Return (IRR): 90.05%
‚úì ACCEPT: IRR (90.049037%) > WACC (10%)
</code></pre><p><strong>The insight</strong>: This is an EXCELLENT investment. NPV of $1.7M and IRR of 90% far exceed hurdle rate.</p><hr /><h3>Part 4: Payback Period</h3><p>How long until we recover the investment?</p><pre><code class="language-swift">print("PART 3: Payback Period Analysis\n")

var cumulativeCashFlow = -purchasePrice
var paybackYear = 0

print("Cumulative Cash Flow:")
for (year, cf) in cashFlows.enumerated() {
    if year == 0 {
        cumulativeCashFlow = cf
    } else {
        cumulativeCashFlow += cf
    }

    print("  Year \(year): \(cumulativeCashFlow.currency())")

    if cumulativeCashFlow >= 0 && paybackYear == 0 {
        paybackYear = year
    }
}

if paybackYear > 0 {
    print("\nPayback Period: ~\(paybackYear) years")
    print("‚úì Investment recovered in \(paybackYear) years (well within \(usefulLife) year life)")
} else {
    print("\n‚ö†Ô∏è Investment not recovered within useful life")
}
print()
</code></pre><p><strong>Output:</strong></p><pre><code>PART 3: Payback Period Analysis

Cumulative Cash Flow:
  Year 0: ($500,000.00)
  Year 1: ($45,178.57)
  Year 2: $409,642.86
  Year 3: $864,464.29
  Year 4: $1,319,285.71
  Year 5: $1,774,107.14
  Year 6: $2,228,928.57
  Year 7: $2,733,750.00

Payback Period: ~2 years
‚úì Investment recovered in 2 years (well within 7 year life)
</code></pre><hr /><h3>Part 5: Financial Statement Impact</h3><p>How does this affect ROA and profitability?</p><pre><code class="language-swift">print("PART 4: Financial Statement Impact\n")

// Assume current company metrics
let currentAssets = 5_000_000.0
let currentNetIncome = 750_000.0

// Year 1 impact
let newAssets = currentAssets + (purchasePrice - annualDepreciation)  // Equipment at book value
let newNetIncome = currentNetIncome + annualTaxableIncome - annualTaxes  // Add equipment contribution

// Calculate ROA before and after
let roaBefore = currentNetIncome / currentAssets
let roaAfter = newNetIncome / newAssets

print("Return on Assets (ROA):")
print("  Before investment: \(roaBefore.formatted(.percent.precision(.fractionLength(2))))")
print("  After investment (Year 1): \(roaAfter.formatted(.percent.precision(.fractionLength(2))))")

let roaChange = roaAfter - roaBefore
if roaChange > 0 {
    print("  ‚úì ROA improves by \(roaChange.formatted(.percent.precision(.fractionLength(2))))")
} else {
    print("  ‚ö†Ô∏è ROA declines by \(abs(roaChange).formatted(.percent.precision(.fractionLength(2))))")
}
print()

// Profit increase
let profitIncrease = annualTaxableIncome - annualTaxes
print("Annual Profit Increase: \(profitIncrease.currency())")
print("Profit increase as % of investment: \((profitIncrease / purchasePrice).percent())")
print()
</code></pre><p><strong>Output:</strong></p><pre><code>PART 4: Financial Statement Impact

Return on Assets (ROA):
  Before investment: 15.00%
  After investment (Year 1): 20.98%
  ‚úì ROA improves by 5.98%

Annual Profit Increase: $390,535.71
Profit increase as % of investment: 78.11%
</code></pre><hr /><h3>Part 6: Sensitivity Analysis</h3><p>What if our assumptions are wrong?</p><pre><code class="language-swift">print("PART 5: Sensitivity Analysis\n")

print("NPV Sensitivity to Production Volume:")
let volumeScenarios = [0.7, 0.8, 0.9, 1.0, 1.1, 1.2]  // 70% to 120% of base

for multiplier in volumeScenarios {
	let adjustedUnits = Int(Double(annualProductionIncrease) * multiplier)
	let adjustedRevenue = Double(adjustedUnits) * contributionMarginPerUnit
	let adjustedOperatingCF = adjustedRevenue - annualMaintenanceCost
	let adjustedTaxableIncome = adjustedOperatingCF - annualDepreciation
	let adjustedTaxes = adjustedTaxableIncome * taxRate
	let adjustedAfterTaxCF = adjustedOperatingCF - adjustedTaxes

	var adjustedCashFlows = [-purchasePrice]
	for _ in 1...usefulLife {
		adjustedCashFlows.append(adjustedAfterTaxCF)
	}
	adjustedCashFlows[adjustedCashFlows.count - 1] += salvageValue

	let adjustedNPV = npv(discountRate: discountRate, cashFlows: adjustedCashFlows)
	let decision = adjustedNPV > 0 ? "Accept ‚úì" : "Reject ‚úó"

	print("  \(multiplier.percent(0)) volume: \(adjustedNPV.currency(0)) - \(decision)")
}
print()

print("NPV Sensitivity to Discount Rate:")
let rateScenarios = [0.08, 0.10, 0.12, 0.15, 0.20]

for rate in rateScenarios {
	let npvAtRate = npv(discountRate: rate, cashFlows: cashFlows)
	let decision = npvAtRate > 0 ? "Accept ‚úì" : "Reject ‚úó"
	print("  \(rate.percent(0)): \(npvAtRate.currency(0)) - \(decision)")
}
print()
</code></pre><p><strong>Output:</strong></p><pre><code>PART 5: Sensitivity Analysis

NPV Sensitivity to Production Volume:
  70% volume: $1,082,683 - Accept ‚úì
  80% volume: $1,301,761 - Accept ‚úì
  90% volume: $1,520,840 - Accept ‚úì
  100% volume: $1,739,919 - Accept ‚úì
  110% volume: $1,958,998 - Accept ‚úì
  120% volume: $2,178,077 - Accept ‚úì

NPV Sensitivity to Discount Rate:
  8%: $1,897,143 - Accept ‚úì
  10%: $1,739,919 - Accept ‚úì
  12%: $1,598,312 - Accept ‚úì
  15%: $1,411,045 - Accept ‚úì
  20%: $1,153,400 - Accept ‚úì
</code></pre><p><strong>The insight</strong>: Investment remains attractive even if volume drops 30% or discount rate doubles. This is a ROBUST investment.</p><hr /><h3>Part 6: Lease vs. Buy Comparison</h3><p>Should we lease instead?</p><pre><code class="language-swift">print("PART 6: Lease vs. Buy Comparison\n")

// Lease terms
let annualLeasePayment = 95_000.0
let leaseMaintenanceIncluded = true  // Lessor covers maintenance

print("Lease Option:")
print("- Annual Lease Payment: \(annualLeasePayment.currency())")
print("- Maintenance: Included")
print()

// Lease cash flows (after-tax)
let leaseMaintenanceSaving = leaseMaintenanceIncluded ? annualMaintenanceCost : 0
let leaseOperatingCF = annualRevenueBenefit - annualLeasePayment + leaseMaintenanceSaving

// Lease payments are tax-deductible
let leaseTaxableIncome = leaseOperatingCF
let leaseTaxes = leaseTaxableIncome * taxRate
let leaseAfterTaxCF = leaseOperatingCF - leaseTaxes

var leaseCashFlows: [Double] = []
for _ in 1...usefulLife {
    leaseCashFlows.append(leaseAfterTaxCF)
}

let leaseNPV = npv(discountRate: discountRate, cashFlows: leaseCashFlows)

print("Lease NPV: \(leaseNPV.currency())")
print("Buy NPV: \(npvValue.currency())")
print()

if npvValue > leaseNPV {
    let advantage = npvValue - leaseNPV
    print("‚úì RECOMMENDATION: Buy")
    print("  Buying creates \(advantage.currency()) more value than leasing")
} else {
    let advantage = leaseNPV - npvValue
    print("‚úì RECOMMENDATION: Lease")
    print("  Leasing creates \(advantage.currency()) more value than buying")
}
print()
</code></pre><p><strong>Output:</strong></p><pre><code>PART 6: Lease vs. Buy Comparison

Lease Option:
- Annual Lease Payment: $95,000.00
- Maintenance: Included

Lease NPV: $2,088,551.67
Buy NPV: $1,739,919.11

‚úì RECOMMENDATION: Lease
  Leasing creates $348,632.57 more value than buying
</code></pre><p><strong>The insight</strong>: Despite buying having excellent returns, leasing is BETTER because maintenance is included and there‚Äôs no upfront capital outlay.</p><hr /><h2>The Results</h2><h3>Business Value</h3><p><strong>Financial Impact</strong>:</p><ul><li><strong>Buy option NPV</strong>: $1.74M (excellent)</li><li><strong>Lease option NPV</strong>: $2.09M (even better!)</li><li><strong>Recommendation</strong>: LEASE the equipment</li><li><strong>Payback</strong>: ~2 years (if buying)</li><li><strong>ROA improvement</strong>: +5.98%</li></ul><p><strong>Risk Analysis</strong>:</p><ul><li>Investment robust to 30% volume decline</li><li>Remains profitable even if discount rate doubles</li><li>Low sensitivity to key assumptions</li></ul><p><strong>Technical Achievement</strong>:</p><ul><li>Combined TVM, depreciation, and financial ratios</li><li>Complete capital budgeting analysis</li><li>Lease vs. buy comparison</li><li>Sensitivity analysis</li></ul><hr /><h2>What Worked</h2><p><strong>Integration Success</strong>:</p><ul><li>TVM functions (<code>npv</code>, <code>irr</code>) handled multi-year cash flows perfectly</li><li>Depreciation calculations integrated cleanly</li><li>Financial ratio analysis (ROA) showed statement impact</li><li>Sensitivity analysis used data tables (from Week 2)</li></ul><p><strong>Decision Quality</strong>:</p><ul><li>Clear recommendation (Lease)</li><li>Quantified value difference ($349k advantage)</li><li>Risk assessment (sensitivity to assumptions)</li><li>Complete financial picture</li></ul><hr /><h2>What Didn‚Äôt Work</h2><p><strong>Initial Challenges</strong>:</p><ul><li>First version forgot to include salvage value in final year cash flow</li><li>Tax calculations were confusing until we separated operating CF from taxable income</li><li>Lease analysis initially didn‚Äôt account for maintenance savings</li></ul><p><strong>Lessons Learned</strong>:</p><ul><li>Capital budgeting requires careful cash flow modeling</li><li>Tax effects materially impact decisions (depreciation tax shield)</li><li>Always compare alternatives (lease vs. buy, not just ‚Äúbuy vs. don‚Äôt buy‚Äù)</li></ul><hr /><h2>The Insight</h2><p><strong>Capital budgeting decisions require combining multiple financial concepts.</strong></p><p>You can‚Äôt just calculate NPV in isolation. You need:</p><ul><li><strong>TVM analysis</strong>: NPV, IRR, payback</li><li><strong>Depreciation</strong>: Tax shield effects</li><li><strong>Financial statement impact</strong>: How does this affect reported earnings and ratios?</li><li><strong>Sensitivity analysis</strong>: What if we‚Äôre wrong?</li><li><strong>Alternative comparison</strong>: Lease vs. buy, new vs. used, etc.</li></ul><p>BusinessMath makes these integrated analyses straightforward with composable functions.</p><blockquote><p><strong>Key Takeaway</strong>: Real business decisions require combining multiple analytical tools. Libraries should make integration seamless.</p></blockquote><hr /><h2>Try It Yourself</h2><p>Copy this to an Xcode playground and experiment:</p><pre><code>‚Üí Complete, runnable code (~200 lines)
</code></pre><h3>Modifications to Try</h3><ol><li><strong>Add accelerated depreciation (MACRS)</strong><ul><li>How does tax shield timing change NPV?</li></ul></li><li><strong>Model equipment replacement cycle</strong><ul><li>Should we replace after 7 years or extend?</li></ul></li><li><strong>Add working capital requirements</strong><ul><li>Equipment requires $50k inventory investment</li><li>How does this affect NPV?</li></ul></li><li><strong>Model gradual volume ramp</strong><ul><li>Year 1: 50k units, Year 2: 75k, Year 3: 100k</li><li>More realistic than immediate full production</li></ul></li></ol><hr /><h2>Technical Deep Dives</h2><p>Want to understand the components better?</p><p><strong>DocC Tutorials Used</strong>:</p><ul><li><strong>Time Value of Money</strong>: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/1.3-TimeValueOfMoney.md">1.3</a> - NPV, IRR calculations</li><li><strong>Financial Ratios</strong>: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/2.2-FinancialRatiosGuide.md">2.2</a> - ROA, profitability metrics</li><li><strong>Data Tables</strong>: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/2.1-DataTableAnalysis.md">2.1</a> - Sensitivity analysis</li></ul><p><strong>API References</strong>:</p><ul><li><code>npv(discountRate:cashFlows:)</code></li><li><code>irr(cashFlows:)</code></li><li><code>returnOnAssets(incomeStatement:balanceSheet:)</code></li></ul><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: Week 4 explores investment analysis and portfolio theory.</p><p><strong>Related Case Studies</strong>:</p><ul><li><a href="../../week-01/04-fri-case-retirement"><strong>Case Study #1: Retirement Planning</strong> (Week 1)</a> - TVM + Distributions</li><li><strong>Case Study #3: Option Pricing</strong> (Week 6) - Monte Carlo simulation</li><li><strong>Case Study #4: Portfolio Optimization</strong> (Week 8) - MIDPOINT integration</li></ul><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 3/12</li><li>Posts Published: 12/~48</li><li><strong>Case Studies: 2/6 Complete</strong> üéØ</li><li><strong>Week 3 Complete!</strong> ‚úÖ</li><li>Topics Combined: TVM + Depreciation + Financial Analysis</li><li>Playgrounds: 11 available (9 technical + 2 case studies)</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-03/03-thu-revenue-modeling</guid><title>Building a Revenue Forecasting Model</title><link>https://www.justinpurnell.com/BusinessMath/week-03/03-thu-revenue-modeling</link><description><![CDATA[Part 11 of 12-Week BusinessMath Series]]></description><pubDate>Thu, 22 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[revenue]]></category><category><![CDATA[forecasting]]></category><category><![CDATA[time-series]]></category><category><![CDATA[seasonality]]></category><content:encoded><![CDATA[<p><strong>Part 11 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>Building a complete revenue forecast from historical data</li><li>Extracting and analyzing seasonal patterns</li><li>Fitting trend models to deseasonalized data</li><li>Generating multi-period forecasts with confidence intervals</li><li>Creating scenario analyses (conservative, base, optimistic)</li></ul><hr /><h2>The Problem</h2><p>CFOs and business leaders need revenue forecasts for planning: <strong>How much revenue will we generate next quarter? Next year? What‚Äôs the range of likely outcomes?</strong></p><p>Building accurate forecasts requires:</p><ol><li><strong>Understanding historical patterns</strong> (is there seasonal variance?)</li><li><strong>Identifying the underlying trend</strong> (are we growing linearly or exponentially?)</li><li><strong>Projecting forward</strong> (combining trend and seasonality)</li><li><strong>Quantifying uncertainty</strong> (what‚Äôs the confidence interval?)</li><li><strong>Scenario planning</strong> (conservative vs. optimistic cases)</li></ol><p>Doing this properly in spreadsheets is tedious and error-prone. <strong>You need a systematic, reproducible forecasting workflow.</strong></p><hr /><h2>The Solution</h2><p>Let‚Äôs build a production-ready revenue forecast using BusinessMath, combining growth modeling, seasonality extraction, and trend fitting.</p><h3>Step 1: Prepare Historical Data</h3><p>Start with 2 years of quarterly revenue:</p><pre><code class="language-swift">import BusinessMath

// Define periods (8 quarters: 2023-2024)
let periods = [
    Period.quarter(year: 2023, quarter: 1),
    Period.quarter(year: 2023, quarter: 2),
    Period.quarter(year: 2023, quarter: 3),
    Period.quarter(year: 2023, quarter: 4),
    Period.quarter(year: 2024, quarter: 1),
    Period.quarter(year: 2024, quarter: 2),
    Period.quarter(year: 2024, quarter: 3),
    Period.quarter(year: 2024, quarter: 4)
]

// Historical revenue (showing both growth and Q4 spike)
let revenue: [Double] = [
    800_000,    // Q1 2023
    850_000,    // Q2 2023
    820_000,    // Q3 2023
    1_100_000,  // Q4 2023 (holiday spike)
    900_000,    // Q1 2024
    950_000,    // Q2 2024
    920_000,    // Q3 2024
    1_250_000   // Q4 2024 (holiday spike + growth)
]

let historical = TimeSeries(periods: periods, values: revenue)

print("Loaded \(historical.count) quarters of historical data")
print("Total historical revenue: \(historical.reduce(0, +).currency())")
</code></pre><p><strong>Output:</strong></p><pre><code>Loaded 8 quarters of historical data
Total historical revenue: $7,590,000
</code></pre><hr /><h3>Step 2: Analyze Historical Patterns</h3><p>Before modeling, understand the data:</p><pre><code class="language-swift">// Calculate quarter-over-quarter growth
let qoqGrowth = historical.growthRate(lag: 1)

print("\nQuarter-over-Quarter Growth:")
for (i, growth) in qoqGrowth.enumerated() {
    let period = periods[i + 1]
    print("\(period.label): \(growth.percent(1))")
}

// Calculate year-over-year growth
let yoyGrowth = historical.growthRate(lag: 4)  // 4 quarters = 1 year

print("\nYear-over-Year Growth:")
for (i, growth) in yoyGrowth.valuesArray.enumerated() {
    let period = periods[i + 4]
    print("\(period.label): \(growth.percent(1))")
}

// Calculate overall CAGR
let totalYears = 2.0
let cagrValue = cagr(
    beginningValue: revenue[0],
    endingValue: revenue[revenue.count - 1],
    years: totalYears
)
print("\nOverall CAGR: \(cagrValue.percent(1))")
</code></pre><p><strong>Output:</strong></p><pre><code>Quarter-over-Quarter Growth:
2023-Q2: +6.3%
2023-Q3: -3.5%
2023-Q4: +34.1%  ‚Üê Holiday spike
2024-Q1: -18.2%  ‚Üê Post-holiday drop
2024-Q2: +5.6%
2024-Q3: -3.2%
2024-Q4: +35.9%  ‚Üê Holiday spike again

Year-over-Year Growth:
2024-Q1: +12.5%
2024-Q2: +11.8%
2024-Q3: +12.2%
2024-Q4: +13.6%

Overall CAGR: 25.0%
</code></pre><p><strong>The insight</strong>: Q-o-Q growth is volatile (swings from -18% to +36%), but Y-o-Y growth is steady (~12%). This suggests <strong>strong seasonality with underlying growth</strong>.</p><hr /><h3>Step 3: Extract Seasonal Pattern</h3><p>Identify the recurring pattern:</p><pre><code class="language-swift">// Calculate seasonal indices (4 quarters per year)
let seasonality = try seasonalIndices(timeSeries: historical, periodsPerYear: 4)

print("\nSeasonal Indices:")
let quarters = ["Q1", "Q2", "Q3", "Q4"]
for (i, index) in seasonality.enumerated() {
    let pct = (index - 1.0)
    let direction = pct > 0 ? "above" : "below"
    print("\(quarters[i]): \(index.number(3)) (\(abs(pct).percent(1)) \(direction) average)")
}
</code></pre><p><strong>Output:</strong></p><pre><code>Seasonal Indices:
Q1: 0.942 (5.8% below average)
Q2: 0.968 (3.2% below average)
Q3: 0.908 (9.2% below average)
Q4: 1.183 (18.3% above average)  ‚Üê Holiday seasonality confirmed!
</code></pre><p><strong>The pattern</strong>: Q4 is 18% above average (holiday shopping), Q1-Q3 are all below average, with Q3 the lowest (summer slowdown).</p><hr /><h3>Step 4: Deseasonalize the Data</h3><p>Remove seasonal effects to see the underlying trend:</p><pre><code class="language-swift">let deseasonalized = try seasonallyAdjust(timeSeries: historical, indices: seasonality)

print("\nDeseasonalized Revenue:")
print("Original ‚Üí Deseasonalized")
for i in 0...(historical.count - 1) {
    let original = historical.valuesArray[i]
    let adjusted = deseasonalized.valuesArray[i]
    let period = periods[i]
    print("\(period.label): \(original.currency(0)) ‚Üí \(adjusted.currency(0))")
}
</code></pre><p><strong>Output:</strong></p><pre><code>Deseasonalized Revenue:
Original ‚Üí Deseasonalized
2023-Q1: $800,000 ‚Üí $849,566
2023-Q2: $850,000 ‚Üí $878,143
2023-Q3: $820,000 ‚Üí $903,399
2023-Q4: $1,100,000 ‚Üí $930,069
2024-Q1: $900,000 ‚Üí $955,762
2024-Q2: $950,000 ‚Üí $981,454
2024-Q3: $920,000 ‚Üí $1,013,570
2024-Q4: $1,250,000 ‚Üí $1,056,897
</code></pre><p><strong>The insight</strong>: After removing seasonality, the revenue trend is smooth and steadily increasing: $850k ‚Üí $878k ‚Üí $903k ‚Üí ‚Ä¶ ‚Üí $1,060k.</p><hr /><h3>Step 5: Fit Trend Model</h3><p>Fit a linear trend to the deseasonalized data:</p><pre><code class="language-swift">var linearModel = LinearTrend<Double>()
try linearModel.fit(to: deseasonalized)

print("\nLinear Trend Model Fitted")
print("Indicates steady absolute growth per quarter")
</code></pre><hr /><h3>Step 6: Generate Forecast</h3><p>Project forward and reapply seasonality:</p><pre><code class="language-swift">let forecastPeriods = 4  // Forecast next 4 quarters (2025)

// Step 6a: Project trend forward
let trendForecast = try linearModel.project(periods: forecastPeriods)

print("\nTrend Forecast (deseasonalized):")
for (period, value) in zip(trendForecast.periods, trendForecast.valuesArray) {
    print("\(period.label): \(value.currency(0))")
}

// Step 6b: Reapply seasonal pattern
let finalForecast = try applySeasonal(timeSeries: trendForecast, indices: seasonality)

print("\nFinal Forecast (with seasonality):")
var forecastTotal = 0.0
for (period, value) in zip(finalForecast.periods, finalForecast.valuesArray) {
    forecastTotal += value
    print("\(period.label): \(value.currency(0))")
}

print("\nForecast Summary:")
print("Total 2025 revenue: \(forecastTotal.currency(0))")
print("Average quarterly revenue: \((forecastTotal / 4).currency(0))")

// Compare to 2024
let revenue2024 = revenue[4...7].reduce(0.0, +)
let forecastGrowth = (forecastTotal - revenue2024) / revenue2024
print("Growth vs 2024: \(forecastGrowth.percent(1))")
</code></pre><p><strong>Output:</strong></p><pre><code>Trend Forecast (deseasonalized):
2025-Q1: $1,074,052
2025-Q2: $1,102,485
2025-Q3: $1,130,917
2025-Q4: $1,159,349

Final Forecast (with seasonality):
2025-Q1: $1,011,389  ‚Üê Deseasonalized √ó Q1 index (0.942)
2025-Q2: $1,067,152  ‚Üê Deseasonalized √ó Q2 index (0.968)
2025-Q3: $1,026,514  ‚Üê Deseasonalized √ó Q3 index (0.908)
2025-Q4: $1,371,171  ‚Üê Deseasonalized √ó Q4 index (1.183)

Forecast Summary:
Total 2025 revenue: $4,476,226
Average quarterly revenue: $1,119,057
Growth vs 2024: 11.3%
</code></pre><p><strong>The insight</strong>: The forecast shows continued steady growth (~11%) with the expected Q4 spike.</p><hr /><h3>Step 7: Scenario Analysis</h3><p>Create conservative and optimistic scenarios by adjusting the growth rate:</p><pre><code class="language-swift">print("\nScenario Analysis for 2025:")

// Base case parameters (from the fitted linear model)
let baseSlope = linearModel.slopeValue!
let baseIntercept = linearModel.interceptValue!

// Conservative: Reduce growth rate by 50%
let conservativeSlope = baseSlope * 0.5
var conservativePeriods: [Period] = []
var conservativeValues: [Double] = []
for i in 1...forecastPeriods {
    let index = Double(deseasonalized.count + i - 1)
    let trendValue = baseIntercept + conservativeSlope * index
    conservativePeriods.append(Period.quarter(year: 2025, quarter: i))
    conservativeValues.append(trendValue)
}
let conservativeForecast = TimeSeries(
    periods: conservativePeriods,
    values: conservativeValues
)
let conservativeSeasonalForecast = try applySeasonal(
    timeSeries: conservativeForecast,
    indices: seasonality
)

// Optimistic: Increase growth rate by 50%
let optimisticSlope = baseSlope * 1.5
var optimisticPeriods: [Period] = []
var optimisticValues: [Double] = []
for i in 1...forecastPeriods {
    let index = Double(deseasonalized.count + i - 1)
    let trendValue = baseIntercept + optimisticSlope * index
    optimisticPeriods.append(Period.quarter(year: 2025, quarter: i))
    optimisticValues.append(trendValue)
}
let optimisticForecast = TimeSeries(
    periods: optimisticPeriods,
    values: optimisticValues
)
let optimisticSeasonalForecast = try applySeasonal(
    timeSeries: optimisticForecast,
    indices: seasonality
)

let conservativeTotal = conservativeSeasonalForecast.reduce(0, +)
let optimisticTotal = optimisticSeasonalForecast.reduce(0, +)

print("Conservative: \(conservativeTotal.currency(0)) (growth dampened 50%)")
print("Base Case: \(forecastTotal.currency(0))")
print("Optimistic: \(optimisticTotal.currency(0)) (growth amplified 50%)")
</code></pre><p><strong>Output:</strong></p><pre><code>Scenario Analysis for 2025:
Conservative: $3,931,302 (growth dampened 50%)
Base Case: $4,476,226
Optimistic: $5,021,150 (growth amplified 50%)
</code></pre><blockquote><p><strong>Note</strong>: The exact values depend on your fitted model‚Äôs slope parameter. Run the playground to see actual results with your data. The key insight is that dampening the growth rate by 50% produces noticeably lower forecasts, while amplifying by 50% produces higher forecasts.</p></blockquote><hr /><h2>Complete Workflow</h2><p>Here‚Äôs the end-to-end forecast in one place:</p><pre><code class="language-swift">import BusinessMath

func buildRevenueModel() throws {
    // 1. Prepare data
    let periods = (1...8).map { i in
        let year = 2023 + (i - 1) / 4
        let quarter = ((i - 1) % 4) + 1
        return Period.quarter(year: year, quarter: quarter)
    }

    let revenue: [Double] = [
        800_000, 850_000, 820_000, 1_100_000,
        900_000, 950_000, 920_000, 1_250_000
    ]

    let historical = TimeSeries(periods: periods, values: revenue)

    // 2. Extract seasonality
    let seasonalIndices = try seasonalIndices(timeSeries: historical, periodsPerYear: 4)

    // 3. Deseasonalize
    let deseasonalized = try seasonallyAdjust(timeSeries: historical, indices: seasonalIndices)

    // 4. Fit trend
    var model = LinearTrend<Double>()
    try model.fit(to: deseasonalized)

    // 5. Generate forecast
    let trendForecast = try model.project(periods: 4)
    let finalForecast = try applySeasonal(timeSeries: trendForecast, indices: seasonalIndices)

    // 6. Present results
    print("Revenue Forecast:")
    for (period, value) in zip(finalForecast.periods, finalForecast.valuesArray) {
        print("\(period.label): \(value.currency(0))")
    }

    let total = finalForecast.reduce(0, +)
    print("Total 2025 forecast: \(total.currency(0))")
}

try buildRevenueModel()
</code></pre><hr /><h2>Try It Yourself</h2><p>Copy this to a playground and experiment:</p><pre><code>‚Üí Full API Reference: BusinessMath Docs ‚Äì 3.3 Revenue Forecasting
</code></pre><p><strong>Modifications to try</strong>:</p><ol><li>Use your company‚Äôs historical revenue data</li><li>Try exponential trend instead of linear</li><li>Create monthly forecasts instead of quarterly</li><li>Add confidence intervals to forecasts</li></ol><hr /><h2>Real-World Application</h2><p>Think about using this for annual planning:</p><ul><li><strong>Historical data</strong>: 3 years of monthly MRR</li><li><strong>Seasonality</strong>: Summer slump (July-August), year-end spike (December)</li><li><strong>Trend</strong>: Exponential (consistent % growth)</li><li><strong>Forecast horizon</strong>: 12 months</li><li><strong>Scenarios</strong>: Conservative (5% CAGR), Base (12% CAGR), Optimistic (20% CAGR)</li></ul><p>Rather than saying ‚Äúwe‚Äôre growing 10% per month, so we‚Äôll hit $30mm,‚Äù it‚Äôs far more credible to say: ‚ÄúOur base case projects $24M ARR, with 80% confidence interval of $22M-$26M.‚Äù</p><hr /><p><code>‚òÖ Insight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><p><strong>Why Forecast with Scenarios?</strong></p><p>Point forecasts are always wrong. The question is: how wrong?</p><p>Scenarios communicate uncertainty:</p><ul><li><strong>Conservative</strong>: What if growth slows?</li><li><strong>Base</strong>: What if trends continue?</li><li><strong>Optimistic</strong>: What if we accelerate?</li></ul><p>Present all three with probabilities (e.g., 20% / 60% / 20%).</p><p>This is a much more nuanced and thoughful approach, that sets realistic expectations and prepares stakeholders for variance.</p><p><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><hr /><h3>üìù Development Note</h3><p>The hardest part of implementing revenue forecasting wasn‚Äôt the math‚Äîit was deciding how opinionated to be about the workflow.</p><p><strong>Option 1</strong>: Provide primitive functions (<code>seasonalIndices</code>, <code>fit</code>, <code>project</code>) and let users compose them.</p><p><strong>Option 2</strong>: Provide a high-level <code>forecast(historical:periods:)</code> function that does everything automatically.</p><p>We chose <strong>Option 1</strong> because forecasting requires judgment:</p><ul><li>Which trend model? (Linear vs. exponential vs. logistic)</li><li>How much seasonality damping? (Full seasonal pattern vs. muted)</li><li>Confidence intervals? (95% vs. 80%?)</li></ul><p>A fully automated forecast hides these choices, producing results users don‚Äôt understand.</p><p><strong>The lesson</strong>: For workflows requiring judgment, provide composable primitives rather than black-box automation.</p><p><strong>Related Methodology</strong>: <a href="../../week-02/02-tue-documentation-as-design">Documentation as Design</a> (Week 2) - Designing learnable APIs</p><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: <a href="../04-fri-case-capital-equipment">Capital Equipment Decision (Friday)</a> - Case study combining depreciation + TVM + financial ratios.</p><p><strong>Week 4</strong>: We‚Äôll explore investment analysis and portfolio optimization.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 3/12</li><li>Posts Published: 11/~48</li><li>Topics Covered: Foundation + Analysis + Operational Models (in progress)</li><li>Playgrounds: 10 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-03/02.5-wed-tooling-guides</guid><title>The Supporting Cast: Coding Rules, DocC Guidelines, and Testing Standards</title><link>https://www.justinpurnell.com/BusinessMath/week-03/02.5-wed-tooling-guides</link><description><![CDATA[Development Journey Series]]></description><pubDate>Wed, 21 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[ai-collaboration]]></category><category><![CDATA[coding-standards]]></category><category><![CDATA[documentation]]></category><category><![CDATA[testing]]></category><category><![CDATA[development-journey]]></category><content:encoded><![CDATA[<p><strong>Development Journey Series</strong></p><hr /><h2>The Context</h2><p>In the previous post, we discussed how the Master Plan serves as the project‚Äôs memory across sessions. But the master plan only answers ‚Äúwhat to build next‚Äù‚Äîit doesn‚Äôt answer <strong>how to build it consistently</strong>.</p><p>After a few weeks of BusinessMath development, I had a different problem: <strong>pattern drift</strong>.</p><ul><li>Week 1: Functions used <code>guard</code> statements for validation</li><li>Week 3: Some functions started using early returns with <code>if !condition</code></li><li>Week 5: Parameter naming became inconsistent (<code>rate</code> vs. <code>r</code> vs. <code>discountRate</code>)</li><li>Week 7: DocC comments had three different documentation styles</li></ul><p>Each individual choice made sense in isolation. But across 200+ tests and 11 topic areas, the inconsistency was creating friction:</p><ul><li>‚ÄúWait, did we decide to use external parameter labels?‚Äù</li><li>‚ÄúShould this throw an error or return zero for empty input?‚Äù</li><li>‚ÄúWhat‚Äôs the format for DocC mathematical formulas?‚Äù</li></ul><p>Without explicit standards, every decision becomes a mini research project. AI doesn‚Äôt remember past decisions, so it defaults to whatever seems reasonable <em>right now</em>.</p><hr /><h2>The Solution</h2><p><strong>Create living standards documents that serve as the project‚Äôs consistency engine.</strong></p><p>We developed three core documents:</p><ol><li><strong>CODING_RULES.md</strong> - How to write code</li><li><strong>DOCC_GUIDELINES.md</strong> - How to document APIs</li><li><strong>TEST_DRIVEN_DEVELOPMENT.md</strong> - How to test code</li></ol><p>These aren‚Äôt heavyweight ‚Äúprocess manuals‚Äù‚Äîthey‚Äôre quick-reference guides that answer common questions in seconds.</p><hr /><h2>Document 1: Coding Rules</h2><p><strong>The Problem It Solves</strong>: ‚ÄúHow should I structure this code?‚Äù</p><h3>What It Contains</h3><pre><code class="language-markdown"># Coding Rules for BusinessMath Library

## 1. Generic Programming
- Use `<T: Real>` for all numeric functions
- Enables flexibility across Float, Double, Float16, etc.

## 2. Function Signatures
- Public API: All user-facing functions marked `public`
- Descriptive parameter labels
- Default parameters for common cases

## 3. Guard Clauses & Validation
- Use `guard` for input validation
- Return sensible defaults for empty inputs (e.g., `T(0)`)
- Throw errors for truly invalid cases

## 4. Formatting Rules
- NEVER use String(format:) for number formatting
- ALWAYS use Swift's formatted() API
- Respect user locales automatically
</code></pre><h3>Real Example: The String Formatting Rule</h3><p>Early in the project, we used C-style formatting:</p><pre><code class="language-swift">// Week 2 code
let output = String(format: "%.2f", value)
</code></pre><p>This created problems:</p><ul><li>Doesn‚Äôt respect user locales</li><li>Breaks with non-decimal numeric types</li><li>Error-prone format strings</li></ul><p>We established a rule:</p><pre><code class="language-swift">// RULE: Never use String(format:)
// ALWAYS use formatted() API

// Correct approach
let output = value.formatted(.number.precision(.fractionLength(2)))
</code></pre><p><strong>Before the rule</strong>: 30 minutes per session debating formatting approaches.</p><p><strong>After the rule</strong>: 0 minutes. ‚ÄúCheck CODING_RULES.md. Use formatted().‚Äù</p><hr /><h3>Why This Worked</h3><h4>1. AI Can Follow Rules It Can Read</h4><p>When starting a session:</p><blockquote><p>‚ÄúRead CODING_RULES.md. Implement the IRR function following these standards.‚Äù</p></blockquote><p>AI responds:</p><blockquote><p>‚ÄúUsing <code><T: Real></code> generic constraint, <code>guard</code> for validation, and Swift‚Äôs formatted() API as specified in CODING_RULES.md.‚Äù</p></blockquote><p><strong>Result</strong>: Consistent code on first try.</p><h4>2. Rules Prevent Regression</h4><p>Week 10, implementing a new feature:</p><pre><code class="language-swift">// AI's first attempt
let result = String(format: "%.4f", value)
</code></pre><p>My review:</p><blockquote><p>‚ÄúThis violates CODING_RULES.md section 4. Use formatted() API.‚Äù</p></blockquote><p>AI immediately corrects:</p><pre><code class="language-swift">let result = value.formatted(.number.precision(.fractionLength(4)))
</code></pre><p><strong>Without the documented rule</strong>, I‚Äôd have to re-explain <em>why</em> every single time.</p><h4>3. Rules Capture Hard-Won Lessons</h4><p>The string formatting rule exists because we spent 2 hours debugging locale issues in Week 2. The rule captures that lesson so it‚Äôs never repeated.</p><hr /><h2>Document 2: DocC Guidelines</h2><p><strong>The Problem It Solves</strong>: ‚ÄúHow should I document this API?‚Äù</p><h3>What It Contains</h3><pre><code class="language-markdown"># DocC Documentation Guidelines

## Required for All Public APIs

1. Brief one-line summary
2. Detailed explanation including:
   - What problem it solves
   - How it works (if non-obvious)
   - When to use it
3. Parameter documentation
4. Return value documentation
5. Throws documentation (if applicable)
6. Usage example
7. Mathematical formula (for math functions)
8. Excel equivalent (if applicable)
9. See Also links

## Documentation Template

///
/// Brief one-line summary.
///
/// Detailed explanation...
///
/// - Parameters:
///   - param1: Description with valid ranges
/// - Returns: Description of return value and guarantees
/// - Throws: Specific errors and when they occur
///
/// ## Usage Example
/// 
/// let result = function(param: value)
/// // Output: expected result
/// 
///
/// ## Mathematical Formula
/// [LaTeX or ASCII math notation]
///
/// - SeeAlso:
///   - ``RelatedType``
///   - ``relatedFunction(_:)``
</code></pre><h3>Real Example: The Formula Format</h3><p>Week 4, documenting the NPV function. First attempt:</p><pre><code class="language-swift">/// NPV = sum of (cash flow / (1 + rate)^period)
</code></pre><p><strong>Problems</strong>:</p><ul><li>Unclear notation</li><li>No variable definitions</li><li>Doesn‚Äôt render well in DocC</li></ul><p>After establishing guidelines:</p><pre><code class="language-swift">/// ## Mathematical Formula
/// NPV is calculated as:
/// 
/// NPV = Œ£ (CF‚Çú / (1 + r)·µó)
/// 
/// where:
/// - CF‚Çú = cash flow at time t
/// - r = discount rate
/// - t = time period
</code></pre><p><strong>Result</strong>: Consistent, readable mathematical notation across all 200+ documented functions.</p><hr /><h3>Why This Worked</h3><h4>1. Documentation as Design Tool</h4><p>Writing DocC comments before implementation forced clarification:</p><p><strong>Question</strong>: ‚ÄúWhat errors can calculateIRR throw?‚Äù</p><p><strong>DocC forces answer</strong>:</p><pre><code class="language-swift">/// - Throws: `FinancialError.convergenceFailure` if calculation
///   does not converge within `maxIterations`.
///   `FinancialError.invalidInput` if cash flows array is empty.
</code></pre><p>Now I know <em>exactly</em> what to implement.</p><h4>2. Examples Must Compile</h4><p>The guidelines require runnable examples:</p><pre><code class="language-swift">/// ## Usage Example
/// 
/// let cashFlows = [-1000.0, 300.0, 400.0, 500.0]
/// let irr = try calculateIRR(cashFlows: cashFlows)
/// print(irr.formatted(.percent))  // Output: 12.5%
/// 
</code></pre><p><strong>Rule</strong>: Every example must run successfully in a playground.</p><p>We manually verified all of the documented examples to make sure we had correct values and an ergonomic approach for users.</p><p>This caught:</p><ul><li>API design issues (awkward to use ‚Üí redesign)</li><li>Missing error handling (forgot to mark <code>throws</code>)</li><li>Incorrect output claims (example output didn‚Äôt match reality)</li></ul><h4>3. Prevents Documentation Drift</h4><p>Week 15, adding async versions of functions. The template ensures consistent documentation:</p><pre><code class="language-swift">/// [Async version follows same structure as sync version]
/// - Same brief summary
/// - Same parameter docs
/// - Added: Concurrency section
/// - Same usage examples (with await)
</code></pre><p><strong>Without guidelines</strong>: 15 different documentation styles for 15 async functions.</p><p><strong>With guidelines</strong>: Perfect consistency.</p><hr /><h2>Document 3: Test-Driven Development Standards</h2><p><strong>The Problem It Solves</strong>: ‚ÄúHow should I test this function?‚Äù</p><h3>What It Contains</h3><pre><code class="language-markdown"># Test-Driven Development Standards

## Test Structure (Swift Testing)

- Use `@Test` attribute with descriptive names
- Use `@Suite` to group related tests
- Use `#expect` for assertions
- Use parameterized tests for multiple scenarios

## Test Organization

Tests mirror source structure:

Tests/BusinessMathTests/
‚îú‚îÄ‚îÄ Time Series Tests/
‚îÇ   ‚îú‚îÄ‚îÄ PeriodTests.swift
‚îÇ   ‚îî‚îÄ‚îÄ TVM Tests/
‚îÇ       ‚îî‚îÄ‚îÄ NPVTests.swift


## RED-GREEN-REFACTOR Cycle

1. RED: Write failing test
2. GREEN: Minimal implementation to pass
3. REFACTOR: Improve code quality (tests still pass)

## Deterministic Testing for Random Functions

**Always use seeded random number generators**


@Test("Monte Carlo with seed is deterministic")
func testDeterministic() {
    let seed: UInt64 = 12345
    let result1 = runSimulation(trials: 10000, seed: seed)
    let result2 = runSimulation(trials: 10000, seed: seed)
    #expect(result1 == result2)  // Must be identical
}
</code></pre><h3>Real Example: The Deterministic Testing Rule</h3><p>Week 6, implementing Monte Carlo simulations. First test:</p><pre><code class="language-swift">@Test("Monte Carlo converges to expected value")
func testConvergence() {
    let result = runSimulation(trials: 10000)
    #expect(abs(result.mean - 100.0) < 1.0)
}
</code></pre><p><strong>Problem</strong>: Flaky test. Sometimes passed, sometimes failed (randomness).</p><p>After establishing the rule:</p><pre><code class="language-swift">@Test("Monte Carlo with seed converges to expected value")
func testConvergence() {
    let seed: UInt64 = 12345
    let result = runSimulation(trials: 10000, seed: seed)
    #expect(abs(result.mean - 100.023) < 0.001)  // Exact value
}
</code></pre><p><strong>Result</strong>: 100% reliable tests. CI never flakes.</p><hr /><h3>Why This Worked</h3><h4>1. Tests as Specifications</h4><p>The RED-GREEN-REFACTOR rule means tests are written <em>before</em> code:</p><pre><code class="language-swift">// STEP 1: Write test (RED)
@Test("IRR calculates correctly")
func testIRR() {
    let cashFlows = [-1000.0, 300.0, 400.0, 500.0]
    let result = try calculateIRR(cashFlows: cashFlows)
    #expect(abs(result - 0.125) < 0.001)  // 12.5%
}
// ‚ùå Test fails: calculateIRR doesn't exist yet

// STEP 2: Implement function (GREEN)
public func calculateIRR<T: Real>(cashFlows: [T]) throws -> T {
    // ... implementation ...
}
// ‚úÖ Test passes

// STEP 3: Refactor (tests still pass)
// Extract validation logic, improve performance, etc.
// ‚úÖ Tests still pass after refactoring
</code></pre><p><strong>The test specifies behavior before implementation exists.</strong></p><h4>2. Parameterized Tests Prevent Duplication</h4><p>Instead of:</p><pre><code class="language-swift">@Test("NPV at 5%") func npv5() { /* ... */ }
@Test("NPV at 10%") func npv10() { /* ... */ }
@Test("NPV at 15%") func npv15() { /* ... */ }
</code></pre><p>Use parameterized tests:</p><pre><code class="language-swift">@Test("NPV at multiple discount rates",
      arguments: [
          (rate: 0.05, expected: 297.59),
          (rate: 0.10, expected: 146.87),
          (rate: 0.15, expected: 20.42)
      ])
func multipleRates(rate: Double, expected: Double) {
    let cashFlows = [-1000.0, 300.0, 300.0, 300.0, 300.0]
    let result = npv(discountRate: rate, cashFlows: cashFlows)
    #expect(abs(result - expected) < 0.01)
}
</code></pre><p><strong>Result</strong>: 3 test cases, 10 lines of code instead of 30.</p><hr /><h2>The Triad Working Together</h2><p>These three documents form a complete system:</p><pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          MASTER_PLAN.md                     ‚îÇ
‚îÇ   "What to build next"                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚îÇ
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ                         ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  CODING   ‚îÇ         ‚îÇ  TEST_DRIVEN   ‚îÇ
    ‚îÇ  RULES    ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  DEVELOPMENT   ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                         ‚îÇ
         ‚îÇ                         ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ       DOCC_GUIDELINES.md              ‚îÇ
    ‚îÇ   "How to document it"                ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre><p><strong>Master Plan</strong>: ‚ÄúImplement Statistical Distributions (Topic 2)‚Äù</p><p><strong>Test-Driven Development</strong>: ‚ÄúWrite tests for normalCDF first, then implement‚Äù</p><p><strong>Coding Rules</strong>: ‚ÄúUse <code><T: Real></code>, guard clauses, and formatted() API‚Äù</p><p><strong>DocC Guidelines</strong>: ‚ÄúDocument with formula, example, Excel equivalent, and See Also links‚Äù</p><p><strong>Result</strong>: Consistent, high-quality implementation on the first try.</p><hr /><h2>What Worked</h2><h3>1. Quick Reference Beats Long Documents</h3><p>Each document is 200-500 lines‚Äîscannable in 60 seconds.</p><p><strong>Anti-pattern</strong>: 50-page ‚ÄúSoftware Development Manual‚Äù that nobody reads.</p><p><strong>Better</strong>: ‚ÄúCheck CODING_RULES.md section 3 for guard clause patterns.‚Äù</p><h3>2. Living Documents That Evolve</h3><p>Week 2: CODING_RULES.md has 5 rules.Week 10: CODING_RULES.md has 15 rules.Week 20: CODING_RULES.md has 25 rules.</p><p>As we discovered patterns that worked, we documented them. As we hit issues, we added rules to prevent recurrence.</p><h3>3. AI Follows Written Rules Reliably</h3><p>Unwritten rule: ‚ÄúWe prefer functional patterns.‚Äù</p><ul><li>AI interpretation: Uses <code>reduce</code> even when a loop is clearer.</li></ul><p>Written rule: ‚ÄúPrefer functional patterns (<code>reduce</code>, <code>map</code>) where readable. Use loops when clarity demands it.‚Äù</p><ul><li>AI gets it right every time.</li></ul><p><strong>Lesson</strong>: Make implicit standards explicit.</p><h3>4. Standards Prevent ‚ÄúWhy Did We Do It This Way?‚Äù Debates</h3><p>Week 15, reviewing code:</p><p><strong>Without standards</strong>:</p><ul><li>‚ÄúShould we use String(format:) here?‚Äù</li><li>‚ÄúI don‚Äôt remember why we decided against it‚Ä¶‚Äù</li><li><em>30 minutes lost to research and re-debate</em></li></ul><p><strong>With standards</strong>:</p><ul><li>‚ÄúCheck CODING_RULES.md‚ÄîString(format:) is forbidden, use formatted().‚Äù</li><li><em>0 minutes lost</em></li></ul><hr /><h2>The Insight</h2><p><strong>The master plan answers ‚Äúwhat to build.‚Äù The standards documents answer ‚Äúhow to build it consistently.‚Äù</strong></p><p>Without standards:</p><ul><li>Every decision is re-litigated</li><li>Patterns drift across sessions</li><li>AI generates inconsistent code</li><li>Code reviews become re-teaching sessions</li></ul><p>With standards:</p><ul><li>Decisions are made once, documented, and followed</li><li>Consistency across 200+ functions</li><li>AI generates correct code on first attempt</li><li>Code reviews verify adherence to documented standards</li></ul><p><strong>Key Takeaway</strong>: Create quick-reference standards documents. Start with 5-10 rules. Evolve as you discover what matters.</p><hr /><h2>How to Apply This</h2><p><strong>For your next project</strong>:</p><h3>1. Start Small</h3><p>Don‚Äôt try to write comprehensive standards on day 1. Start with:</p><ul><li>3 coding rules that matter most</li><li>1 documentation template</li><li>1 testing pattern</li></ul><h3>2. Document Decisions As You Make Them</h3><p>When you decide something important:</p><ul><li>Add it to the relevant document immediately</li><li>Include the ‚Äúwhy‚Äù (so you don‚Äôt forget)</li><li>Show an example</li></ul><h3>3. Use Templates</h3><p>Create copy-paste templates for:</p><ul><li>Function documentation</li><li>Test structure</li><li>Common patterns</li></ul><h3>4. Reference Documents in Prompts</h3><p>When working with AI:</p><blockquote><p>‚ÄúRead CODING_RULES.md. Implement calculateXIRR following these standards.‚Äù</p></blockquote><p>Not:</p><blockquote><p>‚ÄúImplement calculateXIRR. Oh, and use generics. And guard clauses. And formatted(). And‚Ä¶‚Äù</p></blockquote><h3>5. Update After Mistakes</h3><p>Made a mistake this session? Add a rule to prevent it next time.</p><p><strong>Example</strong>: Week 5, forgot to handle empty array in mean() function. Added rule: ‚ÄúAlways validate array input with guard.‚Äù</p><hr /><h2>Template Starter Pack</h2><h3>CODING_RULES.md Template</h3><pre><code class="language-markdown"># Coding Rules for [Project Name]

**Updated**: [Date]

## MUST (Non-Negotiable)

1. [Critical rule with rationale]
   ```swift
   // Example
</code></pre><h2>SHOULD (Strong Preference)</h2><ol><li>[Preferred pattern]<pre><code class="language-swift">// Example
</code></pre></li></ol><h2>CONSIDER (Suggestions)</h2><ol><li>[Optional guideline]</li></ol><pre><code>
### DOCC_GUIDELINES.md Template

```markdown
# Documentation Guidelines

## Required Sections

1. Brief summary
2. Detailed explanation
3. Parameters/Returns/Throws
4. Usage example
5. See Also

## Template

///
/// [Brief one-line summary]
///
/// [Detailed explanation]
///
/// - Parameters:
///   - param: [Description]
/// - Returns: [Description]
///
/// ## Usage Example
/// ```swift
/// [Runnable code]
/// ```
</code></pre><h3>TEST_DRIVEN_DEVELOPMENT.md Template</h3><pre><code class="language-markdown"># Testing Standards

## Test Structure

```swift
@Suite("[Topic] Tests")
struct TopicTests {
    @Test("[What this tests]")
    func descriptiveName() {
        // Arrange
        // Act
        // Assert with #expect
    }
}
</code></pre><h2>RED-GREEN-REFACTOR</h2><ol><li>Write failing test (RED)</li><li>Minimal implementation (GREEN)</li><li>Improve quality (REFACTOR)</li></ol><pre><code>
---

## See It In Action

BusinessMath's standards documents:
- **CODING_RULES.md**: 25 rules developed over 20 weeks
- **DOCC_GUIDELINES.md**: Complete documentation template with 9 required sections
- **TEST_DRIVEN_DEVELOPMENT.md**: Testing patterns for deterministic behavior

**Results**:
- 200+ functions with consistent style
- 100% documentation coverage
- 250+ tests with 0 flaky tests
- Code reviews focus on logic, not style

---

## Discussion

**Questions to consider**:
1. How detailed should your standards be?
2. When do you add a new rule vs. accepting variation?
3. How do you balance flexibility with consistency?

**Share your experience**: Do you maintain coding standards documents? What works for your team?

---

**Series Progress**:
- Week: 3/12
- Posts Published: 10.5/~48
- Methodology Posts: 4/12
- Practices Covered: Test-First, Documentation as Design, Master Planning, **Standards Documents**
- Standards Established: Coding Rules, DocC Guidelines, Testing Patterns

---

**Related Posts**:
- **Previous**: [The Master Plan: Organizing Complexity](#) - How to maintain project context
- **Next**: [Case Study #2: Capital Equipment Decision](#) - Standards documents in action
- **See Also**: [Building with Claude: A Reflection](#) - Full methodology overview
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-03/02-tue-master-plan</guid><title>The Master Plan: Organizing Complexity</title><link>https://www.justinpurnell.com/BusinessMath/week-03/02-tue-master-plan</link><description><![CDATA[Development Journey Series]]></description><pubDate>Tue, 20 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[ai-collaboration]]></category><category><![CDATA[project-management]]></category><category><![CDATA[planning]]></category><category><![CDATA[organization]]></category><category><![CDATA[development journey]]></category><content:encoded><![CDATA[<p><strong>Development Journey Series</strong></p><hr /><h2>The Context</h2><p>At the end of a week or two, we had tackled the core of BusinessMath. We had unlocked the power of the TimeSeries data structure, and had shown the proof of concept in a simple topic like the Time Value of Money using Test-Driven Development and our document-first approach. That was great, but we had a long road ahead of us, with some much trickier topics.</p><ul><li>Statistical Distributions</li><li>Time Series Analysis</li><li>Loans & Amortization</li><li>Depreciation</li><li>Investment Analysis</li><li>Portfolio Optimization</li><li>Monte Carlo Simulation</li><li>Sensitivity Analysis</li><li>Financial Statements</li><li>Options Pricing</li></ul><p>Each topic had 5-15 functions, dozens of tests, complete DocC documentation, and playground examples.</p><p>Even with domain expertise and working with a capable AI agent, this required a structured and methodical approach or risked sprialing out of control.</p><hr /><h2>The Challenge</h2><p>Large projects with AI have a unique problem: <strong>AI has no memory across sessions.</strong></p><p>Traditional development preserves context naturally:</p><ul><li>You work on the same codebase daily</li><li>You remember what‚Äôs done and what‚Äôs next</li><li>Your IDE shows project structure</li><li>Your brain maintains the big picture</li></ul><p>With AI collaboration:</p><ul><li>Each session starts fresh</li><li>AI doesn‚Äôt remember yesterday‚Äôs priorities</li><li>No inherent sense of progress or dependencies</li><li>Easy to lose track of the overall plan</li></ul><p>Without explicit project memory, it‚Äôs very, <strong>very</strong> easy to drift. If you bounce around and work on whatever seems interesting, dependencies go forgotten, coding patterns start to diverge, and momentum comes to a halt.</p><p>I needed a way to maintain project context across sessions‚Äîa shared memory between me and AI.</p><hr /><h2>The Solution</h2><p><strong>Create a living MASTER_PLAN.md document.</strong></p><h3>The Master Plan Structure</h3><p>The master plan is a single markdown file that serves as the project‚Äôs memory:</p><pre><code class="language-markdown"># BusinessMath Master Plan

**Last Updated**: Week 5

## Project Goals

Build a production-quality Swift library for financial calculations with:
- 100% DocC documentation coverage
- Comprehensive test suite (target: 200+ tests)
- Support for generic numeric types
- Playground tutorials for each topic

## Topics

### 1. Time Value of Money [‚úÖ Complete]
**Status**: 24 tests, fully documented
**Effort**: Medium (M)
**Dependencies**: None
**Completed**: Week 4

**Functions**:
- `presentValue`, `futureValue`, `payment`
- `npv`, `irr`, `xnpv`, `xirr`

---

### 2. Statistical Distributions [üü° In Progress]
**Status**: 8/25 tests
**Effort**: Large (L)
**Dependencies**: None
**Target Completion**: Week 7

**Functions**:
- Normal distribution (CDF, PDF, inverse)
- T-distribution, Chi-squared, F-distribution
- Binomial, Poisson distributions

**Remaining Work**:
- Complete distribution functions
- Add quantile functions
- Write DocC tutorials

---

### 3. Time Series Analysis [‚¨ú Not Started]
**Status**: 0 tests
**Effort**: Large (L)
**Dependencies**: Statistical Distributions
**Target Completion**: Week 10

**Functions**:
- Period types (Day, Month, Quarter, Year)
- TimeSeries container
- Moving averages, exponential smoothing
- Trend analysis

**Notes**:
- Blocked on Statistical Distributions completion
- Consider using Foundation.Calendar for date arithmetic

---

[... rest of 10 topics ...]

## Current Phase: Foundation (Weeks 1-8)

**Goal**: Complete Topics 1-4, establish 75 tests total

**Progress**:
- ‚úÖ Topic 1: TVM Complete (24 tests)
- üü° Topic 2: Distributions 30% complete (8 tests)
- ‚¨ú Topic 3: Time Series (not started)
- ‚¨ú Topic 4: Loans & Amortization (not started)

**Next Session Priority**: Complete normal distribution tests

## Effort Estimates

- **Small (S)**: 1-2 sessions, <10 tests
- **Medium (M)**: 3-5 sessions, 10-25 tests
- **Large (L)**: 6-10 sessions, 25-50 tests
- **XL**: 10+ sessions, 50+ tests
</code></pre><hr /><h2>What Worked</h2><h3>1. Visual Progress Tracking</h3><p>Checkboxes provide instant visual feedback:</p><ul><li>‚úÖ Complete (feels great!)</li><li>üü° In Progress (clear focus)</li><li>‚¨ú Not Started (known future work)</li></ul><p>At a glance, you see: ‚ÄúI‚Äôve completed 1/11 topics, making progress on 1 more.‚Äù</p><hr /><h3>2. Dependency Graph Prevented Confusion</h3><p>Time Series depends on Statistical Distributions (for confidence intervals).</p><p><strong>Without the master plan</strong>, I might start Time Series, realize I need distribution functions, context-switch to implement those, forget where I was in Time Series, and end up with half-finished work everywhere.</p><p><strong>With dependencies documented</strong>, I know: ‚ÄúFinish Distributions first, THEN start Time Series.‚Äù</p><hr /><h3>3. Effort Estimates Helped Time Management</h3><p>Knowing a topic is ‚ÄúLarge (L)‚Äù sets expectations:</p><ul><li>Don‚Äôt try to finish it in one session</li><li>Break it into sub-tasks</li><li>Allocate multiple sessions</li></ul><p>Initial estimates were too optimistic (I thought Statistical Distributions was Medium, but it took Large effort). That‚Äôs fine‚ÄîI updated the plan.</p><hr /><h3>4. The Master Plan is AI‚Äôs Memory</h3><p>Every session starts with:</p><blockquote><p>‚ÄúRead MASTER_PLAN.md. What‚Äôs the current priority?‚Äù</p></blockquote><p>AI responds:</p><blockquote><p>‚ÄúYou‚Äôre 30% through Statistical Distributions. The next task is completing normal distribution tests. Time Series is blocked waiting for this.‚Äù</p></blockquote><p><strong>Instant context restoration.</strong> No wasted time figuring out where you left off.</p><hr /><h2>What Didn‚Äôt Work</h2><h3>1. Initial Estimates Were Too Optimistic</h3><p>I thought Statistical Distributions would take 3-5 sessions (Medium). It took 8+ (Large).</p><p><strong>Fix</strong>: I adjusted the plan. Effort estimates improve over time as you calibrate.</p><hr /><h3>2. Forgot to Plan for Integration Testing</h3><p>The master plan listed 11 topics as independent work. But after completing several topics, I needed integration tests: ‚ÄúDo TVM and Time Series work together?‚Äù</p><p>I hadn‚Äôt planned for this.</p><p><strong>Fix</strong>: Added a Phase 4 ‚ÄúIntegration & Polish‚Äù with dedicated time for cross-topic validation.</p><hr /><h3>3. No Mechanism for Prioritization Changes</h3><p>The master plan was linear (Topic 1 ‚Üí Topic 2 ‚Üí Topic 3‚Ä¶). But sometimes priorities shift:</p><ul><li>A user requests a specific feature</li><li>You discover a critical bug</li><li>Integration reveals missing functionality</li></ul><p>The plan didn‚Äôt accommodate this gracefully.</p><p><strong>Fix</strong>: Added a ‚ÄúCurrent Session Priority‚Äù section that can override the default order.</p><hr /><h2>The Insight</h2><p><strong>AI has no memory across sessions. The master plan document serves as the project‚Äôs memory.</strong></p><p>Traditional development preserves context implicitly (your brain, IDE state, recent commits). AI collaboration requires <strong>explicit context preservation</strong>.</p><p>The master plan serves as:</p><ul><li><strong>Roadmap</strong>: What needs to be done</li><li><strong>Memory</strong>: What‚Äôs already done</li><li><strong>Prioritization</strong>: What to work on next</li><li><strong>Dependency tracker</strong>: What blocks what</li><li><strong>Progress indicator</strong>: How far you‚Äôve come</li></ul><p>Without it, you drift. With it, you maintain momentum across weeks and months.</p><blockquote><p><strong>Key Takeaway</strong>: Create a living master plan document. Update it at the end of each session. Start each new session by reading it.</p></blockquote><hr /><h2>How to Apply This</h2><p><strong>For your next project</strong>:</p><p><strong>1. Create MASTER_PLAN.md at Project Start</strong></p><ul><li>List all major topics/features</li><li>Estimate effort (S/M/L/XL)</li><li>Map dependencies</li><li>Set completion targets</li></ul><p><strong>2. Structure the Plan</strong></p><pre><code class="language-markdown">## Topics

### 1. [Topic Name] [Status Emoji]
**Status**: [Specific completion metric]
**Effort**: [S/M/L/XL]
**Dependencies**: [What must be done first]
**Target Completion**: [Week/Sprint number]

**Functions/Features**:
- List of specific work items

**Remaining Work**:
- What's left to do
</code></pre><p><strong>3. Update at End of Each Session</strong></p><ul><li>Mark completed items</li><li>Update progress percentages</li><li>Adjust estimates based on reality</li><li>Note blockers or discoveries</li></ul><p><strong>4. Start Each Session by Reading the Plan</strong></p><ul><li>‚ÄúWhat‚Äôs the current priority?‚Äù</li><li>‚ÄúWhat did I complete last time?‚Äù</li><li>‚ÄúWhat should I work on next?‚Äù</li></ul><p><strong>5. Use It as AI Specification</strong></p><ul><li>Paste relevant section when starting work</li><li>‚ÄúHere‚Äôs the master plan. Focus on Topic 2: Statistical Distributions. The next task is completing normal distribution tests.‚Äù</li></ul><hr /><h2>See It In Action</h2><p>The master plan guided the entire BusinessMath development:</p><p><strong>Technical Examples</strong>:</p><ul><li><strong>Week 5-7</strong>: Statistical Distributions (originally estimated M, actually L)</li><li><strong>Week 8-10</strong>: Time Series (blocked until Distributions complete)</li><li><strong>Week 15</strong>: Integration testing (added after initial plan)</li></ul><p><strong>Methodology Integration</strong>:</p><ul><li><strong>Test-First Development</strong> (Week 1): Each topic‚Äôs test count tracked in plan</li><li><strong>Documentation as Design</strong> (Week 2): DocC coverage tracked in plan</li><li><strong>Coding Standards</strong> (Week 5): Standards violations tracked as plan items</li></ul><hr /><h2>Common Pitfalls</h2><h3>‚ùå Pitfall 1: Making the plan too detailed</h3><p><strong>Problem</strong>: 50-page plan with every function documented upfront<strong>Solution</strong>: High-level topics with detail added as you go</p><h3>‚ùå Pitfall 2: Never updating the plan</h3><p><strong>Problem</strong>: Plan becomes stale, loses value<strong>Solution</strong>: Update at end of EVERY session, even if it‚Äôs just checking a box</p><h3>‚ùå Pitfall 3: Treating estimates as commitments</h3><p><strong>Problem</strong>: Feeling bad when Medium takes Large effort<strong>Solution</strong>: Estimates are guesses that improve over time. Update them!</p><h3>‚ùå Pitfall 4: Skipping dependency tracking</h3><p><strong>Problem</strong>: Starting work that‚Äôs blocked, wasting time<strong>Solution</strong>: Explicitly list ‚ÄúDependencies: [Topic X complete]‚Äù</p><hr /><h2>Template</h2><p>Here‚Äôs a starter template for your master plan:</p><pre><code class="language-markdown"># [Project Name] Master Plan

**Last Updated**: [Date]

## Project Goals

[1-3 sentences describing what you're building and key quality criteria]

## Topics / Features

### 1. [Feature Name] [‚úÖ | üü° | ‚¨ú]
**Status**: [Specific completion metric]
**Effort**: [S/M/L/XL]
**Dependencies**: [None | Topic X complete]
**Target Completion**: [Week/Sprint]

**Work Items**:
- [ ] Item 1
- [ ] Item 2

**Remaining Work**:
- [What's left]

---

[Repeat for each topic/feature]

## Current Phase

**Goal**: [Phase objective]

**Progress**:
- ‚úÖ [Completed items]
- üü° [In progress]
- ‚¨ú [Not started]

**Next Session Priority**: [Specific task]

## Effort Legend

- **Small (S)**: [Your time estimate]
- **Medium (M)**: [Your time estimate]
- **Large (L)**: [Your time estimate]
- **XL**: [Your time estimate]
</code></pre><hr /><h2>Discussion</h2><p><strong>Questions to consider</strong>:</p><ol><li>How detailed should the master plan be?</li><li>How often should you update it?</li><li>What do you do when priorities shift mid-project?</li></ol><p><strong>Share your experience</strong>: Do you use a master plan or roadmap document? What works for you?</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 3/12</li><li>Posts Published: 10/~48</li><li>Methodology Posts: 3/12</li><li>Practices Covered: Test-First, Documentation as Design, Master Planning</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-03/01-mon-growth-modeling</guid><title>Growth Modeling and Forecasting</title><link>https://www.justinpurnell.com/BusinessMath/week-03/01-mon-growth-modeling</link><description><![CDATA[Part 9 of 12-Week BusinessMath Series]]></description><pubDate>Mon, 19 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[growth]]></category><category><![CDATA[forecasting]]></category><category><![CDATA[cagr]]></category><category><![CDATA[trends]]></category><category><![CDATA[seasonality]]></category><content:encoded><![CDATA[<p><strong>Part 9 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>Calculating growth rates (simple and CAGR)</li><li>Fitting trend models (linear, exponential, logistic)</li><li>Extracting and applying seasonal patterns</li><li>Building complete forecasting workflows</li><li>Choosing the right approach for your data</li></ul><hr /><h2>The Problem</h2><p>Business planning requires forecasting: <strong>Will we hit our revenue target? How many users will we have next quarter? What should our headcount plan look like?</strong></p><p>Forecasting means understanding growth patterns:</p><ul><li><strong>Growth rates</strong>: How fast are we growing?</li><li><strong>Trend models</strong>: What‚Äôs the underlying trajectory?</li><li><strong>Seasonality</strong>: Do we have recurring patterns (Q4 spike, summer slump)?</li></ul><p>Building robust forecasts manually requires statistical knowledge, careful data handling, and combining multiple techniques. <strong>You need systematic tools for growth analysis and forecasting.</strong></p><hr /><h2>The Solution</h2><p>BusinessMath provides comprehensive growth modeling including growth rate calculations, trend fitting, and seasonality extraction.</p><h3>Growth Rates</h3><p>Calculate simple and compound growth:</p><pre><code class="language-swift">import BusinessMath

// Simple growth rate
let growth = try growthRate(from: 100_000, to: 120_000)
// Result: 0.20 (20% growth)

// Negative growth (decline)
let decline = try growthRate(from: 120_000, to: 100_000)
// Result: -0.1667 (-16.67% decline)
</code></pre><p><strong>Formula:</strong></p><pre><code>Growth Rate = (Ending / Beginning) - 1
</code></pre><hr /><h3>Compound Annual Growth Rate (CAGR)</h3><p>CAGR smooths out volatility to show steady equivalent growth:</p><pre><code class="language-swift">// Revenue: $100k ‚Üí $110k ‚Üí $125k ‚Üí $150k over 3 years
let compoundGrowth = cagr(
    beginningValue: 100_000,
    endingValue: 150_000,
    years: 3
)
// Result: ~0.1447 (14.47% per year)

// Verify: does 14.47% compound for 3 years give $150k?
let verification = 100_000 * pow((1 + compoundGrowth), 3.0)
// Result: ~150,000 ‚úì
</code></pre><p><strong>Formula:</strong></p><pre><code>CAGR = (Ending / Beginning)^(1/years) - 1
</code></pre><p><strong>The insight</strong>: Revenue was volatile year-to-year ($10k, then $15k, then $25k growth), but CAGR shows the equivalent steady rate: 14.47% annually.</p><hr /><h3>Applying Growth</h3><p>Project future values:</p><pre><code class="language-swift">// Project $100k base with 15% annual growth for 5 years
let projection = applyGrowth(
    baseValue: 100_000,
    rate: 0.15,
    periods: 5,
    compounding: .annual
)
// Result: [100k, 115k, 132.25k, 152.09k, 174.90k, 201.14k]
</code></pre><hr /><h3>Compounding Frequencies</h3><p>Different frequencies affect growth:</p><pre><code class="language-swift">let base = 100_000.0
let rate = 0.12  // 12% annual rate
let years = 5

// Annual: 12% once per year
let annual = applyGrowth(baseValue: base, rate: rate, periods: years, compounding: .annual)
print(annual.last!.number(0))
// Final: ~176,234

// Quarterly: 3% four times per year
let quarterly = applyGrowth(baseValue: base, rate: rate, periods: years * 4, compounding: .quarterly)
print(quarterly.last!.number(0))
// Final: ~180,611 (higher due to more frequent compounding)

// Monthly: 1% twelve times per year
let monthly = applyGrowth(baseValue: base, rate: rate, periods: years * 12, compounding: .monthly)
print(monthly.last!.number(0))
// Final: ~181,670

// Continuous: e^(rt)
let continuous = applyGrowth(baseValue: base, rate: rate, periods: years, compounding: .continuous)
print(continuous.last!.number(0))
// Final: ~182,212 (theoretical maximum)
</code></pre><p><strong>The insight</strong>: More frequent compounding increases final value. Continuous compounding is the mathematical limit.</p><hr /><h2>Trend Models</h2><p>Trend models fit mathematical functions to historical data for forecasting.</p><h3>Linear Trend</h3><p>Models constant absolute growth:</p><pre><code class="language-swift">// Historical revenue shows steady ~$5k/month increase
let periods_linearTrend = (1...12).map { Period.month(year: 2024, month: $0) }
let revenue_linearTrend: [Double] = [100, 105, 110, 108, 115, 120, 118, 125, 130, 128, 135, 140]

let historical_linearTrend = TimeSeries(periods: periods_linearTrend, values: revenue_linearTrend)

// Fit linear trend
var trend_linearTrend = LinearTrend<Double>()
try trend_linearTrend.fit(to: historical_linearTrend)

// Project 6 months forward
let forecast_linearTrend = try trend_linearTrend.project(periods: 6)
print(forecast_linearTrend.valuesArray.map({$0.rounded()}))
// Result: [142, 145, 148, 152, 155, 159] (approximately)
</code></pre><p><strong>Formula:</strong></p><pre><code>y = mx + b

Where:
- m = slope (rate of change)
- b = intercept (starting value)
</code></pre><p><strong>Best for</strong>:</p><ul><li>Steady absolute growth (adding same $ each period)</li><li>Short-term forecasts</li><li>Linear relationships</li></ul><hr /><h3>Exponential Trend</h3><p>Models constant percentage growth:</p><pre><code class="language-swift">// Revenue doubling every few years
let periods_exponentialTrend = (0..<10).map { Period.year(2015 + $0) }
let revenue_exponentialTrend: [Double] = [100, 115, 130, 155, 175, 200, 235, 265, 310, 350]

let historical_exponentialTrend = TimeSeries(periods: periods_exponentialTrend, values: revenue_exponentialTrend)

// Fit exponential trend
var trend_exponentialTrend = ExponentialTrend<Double>()
try trend_exponentialTrend.fit(to: historical_exponentialTrend)

// Project 5 years forward
let forecast_exponentialTrend = try trend_exponentialTrend.project(periods: 5)
// Result: [407, 468, 538, 619, 713]
</code></pre><p><strong>Formula:</strong></p><pre><code>y = a √ó e^(bx)

Where:
- a = initial value
- b = growth rate
- e = Euler's number (2.71828...)
</code></pre><p><strong>Best for</strong>:</p><ul><li>Constant percentage growth (e.g., 15% per year)</li><li>Long-term trends</li><li>Compound growth scenarios</li></ul><hr /><h3>Logistic Trend</h3><p>Models growth approaching a capacity limit (S-curve):</p><pre><code class="language-swift">// User adoption: starts slow, accelerates, then plateaus
let periods_logisticTrend = (0..<24).map { Period.month(year: 2023 + $0/12, month: ($0 % 12) + 1) }
let users_logisticTrend: [Double] = [100, 150, 250, 400, 700, 1200, 2000, 3500, 5500, 8000,
						11000, 14000, 17000, 19500, 21500, 23000, 24000, 24500,
						24800, 24900, 24950, 24970, 24985, 24990]

let historical_logisticTrend = TimeSeries(periods: periods_logisticTrend, values: users_logisticTrend)

// Fit logistic trend with capacity of 25,000 users
var trend_logisticTrend = LogisticTrend<Double>(capacity: 25_000)
try trend_logisticTrend.fit(to: historical_logisticTrend)

// Project 12 months forward
let forecast_logisticTrend = try trend_logisticTrend.project(periods: 12)
// Result: Approaches but never exceeds 25,000
</code></pre><p><strong>Formula:</strong></p><pre><code>y = L / (1 + e^(-k(x-x‚ÇÄ)))

Where:
- L = capacity (maximum value)
- k = growth rate
- x‚ÇÄ = midpoint of curve
</code></pre><p><strong>Best for</strong>:</p><ul><li>Market saturation scenarios</li><li>Product adoption curves</li><li>SaaS user growth with market limits</li><li>Biological growth (population with carrying capacity)</li></ul><hr /><h2>Seasonality</h2><p>Extract and apply recurring patterns.</p><h3>Seasonal Indices</h3><p>Calculate seasonal factors:</p><pre><code class="language-swift">// Quarterly revenue with Q4 holiday spike
let periods = (0..<12).map { Period.quarter(year: 2022 + $0/4, quarter: ($0 % 4) + 1) }
let revenue: [Double] = [100, 120, 110, 150,  // 2022
                         105, 125, 115, 160,  // 2023
                         110, 130, 120, 170]  // 2024

let ts = TimeSeries(periods: periods, values: revenue)

// Calculate seasonal indices (4 quarters per year)
let indices = try seasonalIndices(timeSeries: ts, periodsPerYear: 4)
print(indices.map({"\($0.number(2))"}).joined(separator: ", "))
// Result: [~0.85, ~1.00, ~0.91, ~1.24]
</code></pre><p><strong>Interpretation</strong>:</p><ul><li><strong>Q1: 0.85</strong> ‚Üí 15% below average (post-holiday slump)</li><li><strong>Q2: 1.00</strong> ‚Üí Average</li><li><strong>Q3: 0.91</strong> ‚Üí 9% below average (summer slowdown)</li><li><strong>Q4: 1.24</strong> ‚Üí 24% above average (holiday spike!)</li></ul><hr /><h3>Complete Forecasting Workflow</h3><p>Combine all techniques:</p><pre><code class="language-swift">// 1. Load historical data
let historical = TimeSeries(periods: historicalPeriods, values: historicalRevenue)

// 2. Extract seasonal pattern
let seasonalIndices = try seasonalIndices(timeSeries: historical, periodsPerYear: 4)

// 3. Deseasonalize to reveal underlying trend
let deseasonalized = try seasonallyAdjust(timeSeries: historical, indices: seasonalIndices)

// 4. Fit trend model to deseasonalized data
var trend = LinearTrend<Double>()
try trend.fit(to: deseasonalized)

// 5. Project trend forward
let forecastPeriods = 4  // Next 4 quarters
let trendForecast = try trend.project(periods: forecastPeriods)

// 6. Reapply seasonality to trend forecast
let seasonalForecast = try applySeasonal(timeSeries: trendForecast, indices: seasonalIndices)

// 7. Present forecast
for (period, value) in zip(seasonalForecast.periods, seasonalForecast.valuesArray) {
    print("\(period.label): \(value.currency())")
}
</code></pre><p><strong>This workflow</strong>:</p><ol><li>Extracts the recurring seasonal pattern</li><li>Removes it to see the underlying growth trend</li><li>Fits a trend model to clean data</li><li>Projects that trend forward</li><li>Reapplies the seasonal pattern to the forecast</li><li>Produces realistic forecasts that account for both trend and seasonality</li></ol><hr /><h2>Choosing the Right Approach</h2><h3>Decision Tree</h3><p><strong>Step 1: Does your data have seasonality?</strong></p><ul><li><strong>Yes</strong> ‚Üí Extract seasonal pattern first</li><li><strong>No</strong> ‚Üí Skip to trend modeling</li></ul><p><strong>Step 2: What kind of growth pattern?</strong></p><ul><li><strong>Constant $ per period</strong> ‚Üí Linear Trend</li><li><strong>Constant % per period</strong> ‚Üí Exponential Trend</li><li><strong>Growth approaching limit</strong> ‚Üí Logistic Trend</li></ul><p><strong>Step 3: How much history do you have?</strong></p><ul><li><strong>< 2 full cycles</strong> ‚Üí Use simple growth rates</li><li><strong>2-3 cycles</strong> ‚Üí Linear or exponential trend</li><li><strong>3+ cycles</strong> ‚Üí Full decomposition with seasonality</li></ul><p><strong>Step 4: What‚Äôs your forecast horizon?</strong></p><ul><li><strong>Short-term (1-3 periods)</strong> ‚Üí Any model works</li><li><strong>Medium-term (4-8 periods)</strong> ‚Üí Trend models with seasonality</li><li><strong>Long-term (9+ periods)</strong> ‚Üí Be cautious, validate assumptions</li></ul><hr /><h2>Try It Yourself</h2><p>Download the playground and experiment:</p><pre><code>‚Üí Download: Week03/GrowthModeling.playground
‚Üí Full API Reference: BusinessMath Docs ‚Äì 3.1 Growth Modeling
</code></pre><p><strong>Modifications to try</strong>:</p><ol><li>Calculate CAGR for your company‚Äôs historical revenue</li><li>Fit different trend models and compare predictions</li><li>Extract seasonal patterns from your business data</li></ol><hr /><h2>Real-World Application</h2><p>A SaaS company tracking user growth notices:</p><ul><li><strong>Monthly data</strong>: 10-15% growth, but volatile</li><li><strong>CAGR over 2 years</strong>: 12.3% (the smoothed view)</li><li><strong>Seasonal pattern</strong>: Lower signups in July-August (summer)</li><li><strong>Trend model</strong>: Logistic with 100k user capacity (market saturation)</li></ul><p>Combining these insights produces a forecast that accounts for:</p><ul><li>Long-term growth trajectory (logistic curve)</li><li>Seasonal dips in summer</li><li>Market saturation approaching</li></ul><p><strong>This is infinitely more useful than a simple ‚Äúwe‚Äôre growing 15%/month‚Äù projection.</strong></p><hr /><p><code>‚òÖ Insight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><p><strong>Why Deseasonalize Before Trend Fitting?</strong></p><p>If you fit a trend to raw seasonal data, the model gets confused:</p><ul><li>Q4 spikes look like acceleration</li><li>Q1 dips look like deceleration</li><li>The fitted trend becomes wavy instead of smooth</li></ul><p><strong>Deseasonalizing first</strong> lets you fit a clean trend, then reapply the seasonal pattern to forecasts.</p><p>Think of it like removing noise before measuring signal.</p><p><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><hr /><h3>üìù Development Note</h3><p>The hardest decision in growth modeling was: <strong>Should we make seasonality automatic, or explicit?</strong></p><p>Some libraries auto-detect seasonal patterns. Sounds convenient! But it often gets it wrong‚Äîdetecting false patterns in noise, or missing real patterns in small datasets.</p><p>We chose <strong>explicit seasonality</strong>:</p><ul><li>You specify <code>periodsPerYear</code> (4 for quarters, 12 for months)</li><li>You inspect the indices before using them</li><li>You decide if the pattern makes business sense</li></ul><p>This requires one extra line of code, but prevents silent errors. When seasonality extraction fails, you know immediately and can investigate.</p><p><strong>The lesson</strong>: Convenience features that fail silently are worse than explicit APIs that require judgment.</p><p><strong>Related Methodology</strong>: <a href="../week-03/02-tue-master-plan.md">The Master Plan</a> (Tuesday) - Planning for API decisions</p><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: The Master Plan (Tuesday) - How to organize large projects with AI collaboration.</p><p><strong>This week</strong>: Revenue modeling (Thursday) and Capital Equipment case study (Friday).</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 3/12</li><li>Posts Published: 9/~48</li><li>Topics Covered: Foundation + Analysis + Operational Models (starting)</li><li>Playgrounds: 8 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-02/04-fri-risk-analytics</guid><title>Risk Analytics and Stress Testing</title><link>https://www.justinpurnell.com/BusinessMath/week-02/04-fri-risk-analytics</link><description><![CDATA[Part 8 of 12-Week BusinessMath Series]]></description><pubDate>Fri, 16 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[risk]]></category><category><![CDATA[var]]></category><category><![CDATA[stress-testing]]></category><category><![CDATA[portfolio]]></category><content:encoded><![CDATA[<p><strong>Part 8 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>How to perform stress testing with pre-defined and custom scenarios</li><li>Calculating Value at Risk (VaR) at different confidence levels</li><li>Computing Conditional VaR (CVaR / Expected Shortfall)</li><li>Using comprehensive risk metrics (Sharpe, Sortino, drawdown)</li><li>Aggregating risk across multiple portfolios with correlations</li></ul><hr /><h2>The Problem</h2><p>Risk management requires quantifying uncertainty. <strong>What‚Äôs the worst loss we might face? How would a recession affect our portfolio? Are we properly diversified?</strong></p><p>Traditional risk analysis involves complex calculations:</p><ul><li><strong>VaR (Value at Risk)</strong>: Maximum loss at a confidence level</li><li><strong>Stress testing</strong>: Impact of adverse scenarios</li><li><strong>Drawdown analysis</strong>: Peak-to-trough declines</li><li><strong>Risk aggregation</strong>: Combining correlated risks</li></ul><p>Implementing these correctly requires statistical knowledge, careful handling of distributions, and proper correlation modeling. <strong>You need production-ready risk analytics without reinventing the math.</strong></p><hr /><h2>The Solution</h2><p>BusinessMath provides comprehensive risk analytics including stress testing, VaR calculation, and multi-portfolio risk aggregation.</p><h3>Stress Testing</h3><p>Evaluate how portfolios perform under adverse scenarios:</p><pre><code class="language-swift">import BusinessMath

// Pre-defined stress scenarios
var allScenarios = [
    StressScenario<Double>.recession,      // Moderate economic downturn
    StressScenario<Double>.crisis,         // Severe financial crisis
    StressScenario<Double>.supplyShock     // Supply chain disruption
]

// Examine scenario parameters
for scenario in scenarios {
    print("\(scenario.name):")
    print("  Description: \(scenario.description)")
    print("  Shocks:")
    for (driver, shock) in scenario.shocks {
        let pct = shock * 100
        print("    \(driver): \(pct > 0 ? "+" : "")\(pct)%")
    }
}
</code></pre><p><strong>Output:</strong></p><pre><code>Recession:
  Description: Economic recession scenario
  Shocks:
    Revenue: -15.0%
    COGS: +5.0%
    InterestRate: +2.0%

Financial Crisis:
  Description: Severe financial crisis (2008-style)
  Shocks:
    Revenue: -30.0%
    InterestRate: +5.0%
    CustomerChurn: +20.0%
    COGS: +10.0%

Supply Chain Shock:
  Description: Major supply chain disruption
  Shocks:
    InventoryLevel: -30.0%
    DeliveryTime: +50.0%
    COGS: +25.0%
</code></pre><hr /><h3>Custom Stress Scenarios</h3><p>Create scenarios specific to your business:</p><pre><code class="language-swift">// Pandemic scenario
let pandemic = StressScenario(
    name: "Global Pandemic",
    description: "Extended lockdowns and remote work transition",
    shocks: [
        "Revenue": -0.35,           // -35% revenue
        "RemoteWorkCosts": 0.20,    // +20% IT/remote costs
        "TravelExpenses": -0.80,    // -80% travel
        "RealEstateCosts": -0.15    // -15% office costs
    ]
)

allScenarios.append(pandemic)

// Regulatory change scenario
let regulation = StressScenario(
    name: "New Regulation",
    description: "Stricter compliance requirements",
    shocks: [
        "ComplianceCosts": 0.50,    // +50% compliance
        "Revenue": -0.05,            // -5% from restrictions
        "OperatingMargin": -0.03     // -3% margin compression
    ]
)
allScenarios.append(regulation)
</code></pre><hr /><h3>Running Stress Tests</h3><p>Apply scenarios to your financial model:</p><pre><code class="language-swift">let stressTest = StressTest(scenarios: allScenarios)

struct FinancialMetrics {
    var revenue: Double
    var costs: Double
    var npv: Double
}

let baseline = FinancialMetrics(
    revenue: 10_000_000,
    costs: 7_000_000,
    npv: 5_000_000
)

for scenario in stressTest.scenarios {
    // Apply shocks
    var stressed = baseline

    if let revenueShock = scenario.shocks["Revenue"] {
        stressed.revenue *= (1 + revenueShock)
    }

    if let cogsShock = scenario.shocks["COGS"] {
        stressed.costs *= (1 + cogsShock)
    }

    let stressedNPV = stressed.revenue - stressed.costs
    let impact = stressedNPV - baseline.npv
    let impactPct = (impact / baseline.npv)

    print("\n\(scenario.name):")
    print("  Baseline NPV: \(baseline.npv.currency())")
    print("  Stressed NPV: \(stressedNPV.currency())")
    print("  Impact: \(impact.currency()) (\(impactPct.percent()))")
}
</code></pre><hr /><h3>Value at Risk (VaR)</h3><p>VaR measures the maximum loss expected over a time horizon at a given confidence level.</p><p><a href="../../../data/SPData.swift">S&P Returns Data</a></p><h3>Calculating VaR from Returns</h3><pre><code class="language-swift">// Portfolio returns (historical daily returns)
let spReturns: [Double] = [0.0088, 0.0079, -0.0116‚Ä¶] //(See file for data)

let periods = (0...(spReturns.count - 1)).map {
    Period.day(Date().addingTimeInterval(Double($0) * 86400))
}
let timeSeries = TimeSeries(periods: periods, values: spReturns)

let riskMetrics = ComprehensiveRiskMetrics(
    returns: timeSeries,
    riskFreeRate: 0.02 / 250  // 2% annual = 0.008% daily
)

print("Value at Risk:")
print("  95% VaR: \(riskMetrics.var95.percent())")
print("  99% VaR: \(riskMetrics.var99.percent())")

// Interpret: "95% confidence we won't lose more than X% in a day"
let portfolioValue = 1_000_000.0
let var95Loss = abs(riskMetrics.var95) * portfolioValue

print("\nFor \(portfolioValue.currency(0)) portfolio:")
print("  95% 1-day VaR: \(var95Loss.currency())")
print("  Meaning: 95% confident daily loss won't exceed \(var95Loss.currency())")
</code></pre><hr /><h3>Conditional VaR (CVaR / Expected Shortfall)</h3><p>CVaR measures the average loss in the worst cases (beyond VaR):</p><pre><code class="language-swift">print("\nConditional VaR (Expected Shortfall):")
print("  CVaR (95%): \(riskMetrics.cvar95.percent())")
print("  Tail Risk Ratio: \(riskMetrics.tailRisk.number())")

// CVaR is the expected loss if we're in the worst 5%
let cvarLoss = abs(riskMetrics.cvar95) * portfolioValue
print("  If in worst 5% of days, expect to lose: \(cvarLoss.currency())")
</code></pre><p><strong>CVaR is better than VaR</strong> because it captures tail risk‚Äîthe average loss when things go really bad, not just the threshold.</p><hr /><h3>Comprehensive Risk Metrics</h3><p>Get a complete risk profile:</p><pre><code class="language-swift">print("\nComprehensive Risk Profile:")
print(riskMetrics.description)
</code></pre><p><strong>Output:</strong></p><pre><code>Comprehensive Risk Profile:
Comprehensive Risk Metrics:
  VaR (95%): -1.66%
  VaR (99%): -4.84%
  CVaR (95%): -2.76%
  Max Drawdown: 18.91%
  Sharpe Ratio: 0.05
  Sortino Ratio: 0.05
  Tail Risk: 1.66
  Skewness: 1.05
  Kurtosis: 18.53
</code></pre><hr /><h3>Maximum Drawdown</h3><p>Maximum drawdown measures the largest peak-to-trough decline:</p><pre><code class="language-swift">let drawdown = riskMetrics.maxDrawdown

print("\nDrawdown Analysis:")
print("  Maximum drawdown: \(drawdown.percent())")

if drawdown < 0.10 {
    print("  Risk level: Low")
} else if drawdown < 0.20 {
    print("  Risk level: Moderate")
} else {
    print("  Risk level: High")
}
</code></pre><hr /><h3>Sharpe and Sortino Ratios</h3><p>Risk-adjusted return measures:</p><pre><code class="language-swift">print("\nRisk-Adjusted Returns:")
print("  Sharpe Ratio: \(riskMetrics.sharpeRatio.number(3))")
print("    (return per unit of total volatility)")

print("  Sortino Ratio: \(riskMetrics.sortinoRatio.number(3))")
print("    (return per unit of downside volatility)")

// Sortino > Sharpe indicates asymmetric returns (positive skew)
if riskMetrics.sortinoRatio > riskMetrics.sharpeRatio {
    print("  Portfolio has limited downside with upside potential")
}
</code></pre><p><strong>Sharpe Ratio</strong> penalizes all volatility (up and down).<strong>Sortino Ratio</strong> only penalizes downside volatility‚Äîbetter for assessing asymmetric strategies.</p><hr /><h3>Tail Statistics</h3><p>Skewness and kurtosis describe return distribution shape:</p><pre><code class="language-swift">print("\nTail Statistics:")
print("  Skewness: \(riskMetrics.skewness)")

if riskMetrics.skewness < -0.5 {
    print("    Negative skew: More frequent small gains, rare large losses")
    print("    Risk: Fat left tail")
} else if riskMetrics.skewness > 0.5 {
    print("    Positive skew: More frequent small losses, rare large gains")
    print("    Risk: Fat right tail")
} else {
    print("    Roughly symmetric distribution")
}

print("  Excess Kurtosis: \(riskMetrics.kurtosis)")

if riskMetrics.kurtosis > 1.0 {
    print("    Fat tails: More extreme events than normal distribution")
    print("    Risk: Higher probability of large moves")
}
</code></pre><hr /><h2>Aggregating Risk Across Portfolios</h2><p>Combine VaR across multiple portfolios accounting for correlations:</p><pre><code class="language-swift">// Three portfolios with individual VaRs
let portfolioVaRs = [100_000.0, 150_000.0, 200_000.0]

// Correlation matrix
let correlations = [
    [1.0, 0.6, 0.4],
    [0.6, 1.0, 0.5],
    [0.4, 0.5, 1.0]
]

// Aggregate VaR using variance-covariance method
let aggregatedVaR = RiskAggregator<Double>.aggregateVaR(
    individualVaRs: portfolioVaRs,
    correlations: correlations
)

let simpleSum = portfolioVaRs.reduce(0, +)
let diversificationBenefit = simpleSum - aggregatedVaR

print("VaR Aggregation:")
print("  Portfolio A VaR: \(portfolioVaRs[0].currency())")
print("  Portfolio B VaR: \(portfolioVaRs[1].currency())")
print("  Portfolio C VaR: \(portfolioVaRs[2].currency())")
print("  Simple sum: \(simpleSum.currency())")
print("  Aggregated VaR: \(aggregatedVaR.currency())")
print("  Diversification benefit: \(diversificationBenefit.currency())")
</code></pre><p><strong>Diversification benefit</strong> shows how much risk is reduced by not being perfectly correlated.</p><hr /><h3>Marginal VaR</h3><p>Understand how much each portfolio contributes to total risk:</p><pre><code class="language-swift">for i in 0..<portfolioVaRs.count {
    let marginal = RiskAggregator<Double>.marginalVaR(
        entity: i,
        individualVaRs: portfolioVaRs,
        correlations: correlations
    )

    print("\nPortfolio \(["A", "B", "C"][i]):")
    print("  Individual VaR: \(portfolioVaRs[i].currency())")
    print("  Marginal VaR: \(marginal.currency())")
    print("  Risk contribution: \((marginal / aggregatedVaR).percent())")
}
</code></pre><p><strong>Marginal VaR</strong> tells you: ‚ÄúIf I added $1 more to this portfolio, how much would total VaR increase?‚Äù</p><hr /><h2>Try It Yourself</h2><p>Add this code to an Xcode playground and experiment:</p><p><a href="../../../data/SPData.swift">S&P Returns Data</a> (add to the /Sources file of your playground)</p><pre><code>‚Üí Full API Reference: BusinessMath Docs ‚Äì 2.3 Risk Analytics
</code></pre><p><strong>Modifications to try</strong>:</p><ol><li>Create custom stress scenarios for your industry</li><li>Calculate VaR and CVaR for different confidence levels</li><li>Compare Sharpe vs Sortino ratios for asymmetric strategies</li></ol><hr /><h2>Real-World Application</h2><p>Risk managers use these tools daily:</p><ul><li><strong>Portfolio VaR</strong>: Regulatory requirement for banks</li><li><strong>Stress testing</strong>: Required by Dodd-Frank, Basel III</li><li><strong>Drawdown analysis</strong>: Hedge fund performance evaluation</li><li><strong>Risk aggregation</strong>: Enterprise-wide risk management</li></ul><p>BusinessMath makes these institutional-grade analytics accessible in 10-20 lines of Swift code.</p><hr /><p><code>‚òÖ Insight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><p><strong>Why Both VaR and CVaR?</strong></p><p>VaR answers: ‚ÄúWhat‚Äôs the threshold of the worst 5% of outcomes?‚ÄùCVaR answers: ‚ÄúWhen you‚Äôre in that worst 5%, how bad does it actually get?‚Äù</p><p>Example: Portfolio with VaR‚Çâ‚ÇÖ = -$100k, CVaR‚Çâ‚ÇÖ = -$500k</p><ul><li><strong>VaR says</strong>: 95% of the time, you won‚Äôt lose more than $100k</li><li><strong>CVaR says</strong>: But when you do lose more, you lose an average of $500k</li></ul><p><strong>CVaR captures tail risk</strong>‚Äîthe thing that kills portfolios. VaR alone can be misleading for fat-tailed distributions.</p><p>This distinction matters for crypto, options, and leveraged strategies where tails are fat.</p><p><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><hr /><h3>üìù Development Note</h3><p>The hardest part of implementing VaR wasn‚Äôt the math‚Äîit was choosing which variant to implement. There are three common methods:</p><ol><li><strong>Historical VaR</strong>: Use actual historical percentile</li><li><strong>Parametric VaR</strong>: Assume normal distribution</li><li><strong>Monte Carlo VaR</strong>: Simulate future scenarios</li></ol><p>We chose <strong>Historical VaR</strong> as the default because:</p><ul><li>No distribution assumptions</li><li>Works with any return pattern</li><li>Easy to explain and verify</li></ul><p>But we documented this choice explicitly in both code and DocC, so users know what they‚Äôre getting.</p><p><strong>The lesson</strong>: When multiple valid implementations exist, pick one, document it clearly, and make the choice transparent.</p><p><strong>Related Methodology</strong>: <a href="../week-09/02-tue-tests-wrong.md">When Tests Pass But Code Is Wrong</a> (Week 9) - Validating statistical implementations</p><hr /><h2>Next Steps</h2><p><strong>Coming up this week</strong>: Week 3 explores operational models‚Äîgrowth, depreciation, and revenue modeling.</p><p><strong>Case Study</strong>: Week 3 Friday combines depreciation + TVM for capital equipment purchase decisions.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 2/12</li><li>Posts Published: 8/~48</li><li><strong>Week 2 Complete!</strong> ‚úÖ</li><li>Topics Covered: Foundation + Analysis Tools</li><li>Playgrounds: 7 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-02/03-wed-financial-ratios</guid><title>Financial Ratios & Metrics Guide</title><link>https://www.justinpurnell.com/BusinessMath/week-02/03-wed-financial-ratios</link><description><![CDATA[Part 7 of 12-Week BusinessMath Series]]></description><pubDate>Wed, 14 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[financial-ratios]]></category><category><![CDATA[profitability]]></category><category><![CDATA[liquidity]]></category><category><![CDATA[solvency]]></category><content:encoded><![CDATA[<p><strong>Part 7 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>How to calculate and interpret profitability ratios (ROA, ROE, ROIC)</li><li>Using efficiency ratios to measure asset utilization</li><li>Assessing liquidity and solvency for financial health</li><li>Applying DuPont analysis to decompose ROE</li><li>Using credit metrics like Altman Z-Score and Piotroski F-Score</li></ul><hr /><h2>The Problem</h2><p>Analyzing financial statements requires calculating dozens of ratios across five categories: profitability, efficiency, liquidity, solvency, and valuation. Each ratio has a specific formula, interpretation guidelines, and industry benchmarks.</p><p>Doing this manually is tedious and error-prone. Spreadsheets help, but lack type safety and composability. You need to:</p><ul><li>Calculate ratios consistently across periods</li><li>Track trends over time</li><li>Compare companies on equal footing</li><li>Assess financial health with composite scores</li></ul><p><strong>BusinessMath offers a systematic way to compute, track, and interpret financial metrics programmatically.</strong></p><hr /><h2>The Solution</h2><p>BusinessMath provides comprehensive ratio analysis functions that work with <code>IncomeStatement</code> and <code>BalanceSheet</code> data structures, returning results as <code>TimeSeries</code> for trend analysis.</p><h3>Setup: Creating Financial Statements</h3><p>First, let‚Äôs create sample financial statements for a fictional SaaS company ‚ÄúTechCo‚Äù:</p><pre><code class="language-swift">// Define company and periods
let entity = Entity(id: "TECH", primaryType: .ticker, name: "TechCo Inc.")
let periods = [
	Period.quarter(year: 2025, quarter: 1),
	Period.quarter(year: 2025, quarter: 2),
	Period.quarter(year: 2025, quarter: 3),
	Period.quarter(year: 2025, quarter: 4)
]

// Convenient period references
let q1 = periods[0]
let q2 = periods[1]
let q3 = periods[2]
let q4 = periods[3]

// Create Income Statement
// Revenue: $5M ‚Üí $6M over the year (20% growth)
let revenueSeries = TimeSeries<Double>(
	periods: periods,
	values: [5_000_000, 5_300_000, 5_600_000, 6_000_000]
)
let revenueAccount = try Account(
	entity: entity,
	name: "Subscription Revenue",
	type: .revenue,
	timeSeries: revenueSeries
)

// COGS: 30% of revenue
var cogsMetadata = AccountMetadata()
cogsMetadata.category = "COGS"
let cogsSeries = TimeSeries<Double>(
	periods: periods,
	values: [1_500_000, 1_590_000, 1_680_000, 1_800_000]
)
let cogsAccount = try Account(
	entity: entity,
	name: "Cost of Goods Sold",
	type: .expense,
	timeSeries: cogsSeries,
	metadata: cogsMetadata
)

// Operating Expenses: R&D + S&M + G&A
var opexMetadata = AccountMetadata()
opexMetadata.category = "Operating"
let opexSeries = TimeSeries<Double>(
	periods: periods,
	values: [2_000_000, 2_100_000, 2_150_000, 2_200_000]
)
let opexAccount = try Account(
	entity: entity,
	name: "Operating Expenses",
	type: .expense,
	timeSeries: opexSeries,
	metadata: opexMetadata
)

// Interest expense
let interestSeries = TimeSeries<Double>(
	periods: periods,
	values: [100_000, 95_000, 90_000, 85_000]
)
let interestAccount = try Account(
	entity: entity,
	name: "Interest Expense",
	type: .expense,
	timeSeries: interestSeries
)

let incomeStatement = try IncomeStatement(
	entity: entity,
	periods: periods,
	revenueAccounts: [revenueAccount],
	expenseAccounts: [cogsAccount, opexAccount, interestAccount]
)

// Create Balance Sheet
// Current Assets
var currentAssetMetadata = AccountMetadata()
currentAssetMetadata.category = "Current"

let cashSeries = TimeSeries<Double>(
	periods: periods,
	values: [3_000_000, 3_500_000, 4_000_000, 4_500_000]
)
let cashAccount = try Account(
	entity: entity,
	name: "Cash",
	type: .asset,
	timeSeries: cashSeries,
	metadata: currentAssetMetadata
)

let receivablesSeries = TimeSeries<Double>(
	periods: periods,
	values: [1_200_000, 1_300_000, 1_400_000, 1_500_000]
)
let receivablesAccount = try Account(
	entity: entity,
	name: "Accounts Receivable",
	type: .asset,
	timeSeries: receivablesSeries,
	metadata: currentAssetMetadata
)

// Fixed Assets
var fixedAssetMetadata = AccountMetadata()
fixedAssetMetadata.category = "Fixed"

let ppeSeries = TimeSeries<Double>(
	periods: periods,
	values: [2_000_000, 2_050_000, 2_100_000, 2_150_000]
)
let ppeAccount = try Account(
	entity: entity,
	name: "Property & Equipment",
	type: .asset,
	timeSeries: ppeSeries,
	metadata: fixedAssetMetadata
)

// Current Liabilities
var currentLiabilityMetadata = AccountMetadata()
currentLiabilityMetadata.category = "Current"

let payablesSeries = TimeSeries<Double>(
	periods: periods,
	values: [800_000, 850_000, 900_000, 950_000]
)
let payablesAccount = try Account(
	entity: entity,
	name: "Accounts Payable",
	type: .liability,
	timeSeries: payablesSeries,
	metadata: currentLiabilityMetadata
)

// Long-term Debt
var longTermLiabilityMetadata = AccountMetadata()
longTermLiabilityMetadata.category = "Long-term"

let debtSeries = TimeSeries<Double>(
	periods: periods,
	values: [2_000_000, 1_900_000, 1_800_000, 1_700_000]
)
let debtAccount = try Account(
	entity: entity,
	name: "Long-term Debt",
	type: .liability,
	timeSeries: debtSeries,
	metadata: longTermLiabilityMetadata
)

// Equity (balancing to Assets = Liabilities + Equity)
let equitySeries = TimeSeries<Double>(
	periods: periods,
	values: [3_400_000, 4_100_000, 4_800_000, 5_500_000]
)
let equityAccount = try Account(
	entity: entity,
	name: "Shareholders Equity",
	type: .equity,
	timeSeries: equitySeries
)

let balanceSheet = try BalanceSheet(
	entity: entity,
	periods: periods,
	assetAccounts: [cashAccount, receivablesAccount, ppeAccount],
	liabilityAccounts: [payablesAccount, debtAccount],
	equityAccounts: [equityAccount]
)

// Market data for valuation metrics
let marketPrice = 45.00  // $45 per share
let sharesOutstanding = 200_000.0  // 200K shares outstanding

// Cash flow statement (for Piotroski F-Score)
let operatingCashFlowSeries = TimeSeries<Double>(
	periods: periods,
	values: [1_500_000, 1_600_000, 1_700_000, 1_900_000]
)
let cashFlowAccount = try Account(
	entity: entity,
	name: "Operating Cash Flow",
	type: .operating,  // Must use .operating for operating cash flow accounts
	timeSeries: operatingCashFlowSeries
)

let cashFlowStatement = try CashFlowStatement(
	entity: entity,
	periods: periods,
	operatingAccounts: [cashFlowAccount],
	investingAccounts: [],
	financingAccounts: []
)
</code></pre><p><strong>About TechCo‚Äôs Financials:</strong></p><ul><li><strong>Revenue</strong>: Growing SaaS company, $5M ‚Üí $6M quarterly (20% annual growth)</li><li><strong>Gross Margin</strong>: 70% (typical for SaaS: low COGS, high operating leverage)</li><li><strong>Balance Sheet</strong>: Healthy cash position ($3M ‚Üí $4.5M), paying down debt ($2M ‚Üí $1.7M)</li><li><strong>Equity</strong>: Growing from retained earnings as company becomes profitable</li></ul><p>The setup defines all variables used in examples below: <code>incomeStatement</code>, <code>balanceSheet</code>, <code>cashFlowStatement</code>, <code>q1</code>-<code>q4</code>, <code>periods</code>, <code>marketPrice</code>, and <code>sharesOutstanding</code>.</p><hr /><h3>Profitability Ratios</h3><p>How efficiently does the company generate profits?</p><pre><code class="language-swift">import BusinessMath

// Get all profitability ratios at once
let profitability = profitabilityRatios(
	incomeStatement: incomeStatement,
	balanceSheet: balanceSheet
)

print("=== Profitability Analysis ===")
print("Gross Margin: \(profitability.grossMargin[q1]!.percent(1))")
print("Operating Margin: \(profitability.operatingMargin[q1]!.percent(1))")
print("Net Margin: \(profitability.netMargin[q1]!.percent(1))")
print("EBITDA Margin: \(profitability.ebitdaMargin[q1]!.percent(1))")
print("ROA: \(profitability.roa[q1]!.percent(1))")
print("ROE: \(profitability.roe[q1]!.percent(1))")
print("ROIC: \(profitability.roic[q1]!.percent(1))")
</code></pre><p><strong>Interpretation</strong>:</p><ul><li><strong>Gross Margin > 40%</strong>: Strong pricing power</li><li><strong>ROA > 5%</strong>: Good asset efficiency (varies by industry)</li><li><strong>ROE > 15%</strong>: Strong returns for shareholders</li><li><strong>ROIC > WACC</strong>: Company creates value</li></ul><hr /><h3>Efficiency Ratios</h3><p>How effectively does the company use its assets?</p><pre><code class="language-swift">let efficiency = efficiencyRatios(
    incomeStatement: incomeStatement,
    balanceSheet: balanceSheet
)

print("\n=== Efficiency Analysis ===")
print("Asset Turnover: \(efficiency.assetTurnover[q1]!.number(2))")
print("Inventory Turnover: \(efficiency.inventoryTurnover![q1]!.number(1))")
print("Receivables Turnover: \(efficiency.receivablesTurnover![q1]!.number(1))")
print("Days Sales Outstanding: \(efficiency.daysSalesOutstanding![q1]!.number(1)) days")
print("Days Inventory Outstanding: \(efficiency.daysInventoryOutstanding![q1]!.number(1)) days")
print("Days Payable Outstanding: \(efficiency.daysPayableOutstanding![q1]!.number(1)) days")

// Cash Conversion Cycle
let ccc = efficiency.cashConversionCycle![q1]!
print("Cash Conversion Cycle: \(ccc.number(1)) days")
</code></pre><p><strong>Interpretation</strong>:</p><ul><li><strong>Higher turnover</strong> = more efficient use of assets</li><li><strong>Lower DSO (Days Sales Outstanding)</strong> = faster cash collection</li><li><strong>Shorter CCC (Cash Conversion Cycle)</strong> = less cash tied up in operations</li><li>Always compare to industry benchmarks</li></ul><hr /><h3>Liquidity Ratios</h3><p>Can the company meet short-term obligations?</p><pre><code class="language-swift">print("\n=== Liquidity Analysis ===")
print("Current Ratio: \(liquidity.currentRatio[q1]!)")
print("Quick Ratio: \(liquidity.quickRatio[q1]!)")
print("Cash Ratio: \(liquidity.cashRatio[q1]!)")
print("Working Capital: \(liquidity.workingCapital[q1]!.currency(0))")

// Assess liquidity health
let currentRatio = liquidity.currentRatio[q1]!
if currentRatio < 1.0 {
	print("‚ö†Ô∏è  Warning: Current ratio < 1.0 indicates potential liquidity issues")
} else if currentRatio > 3.0 {
	print("‚ÑπÔ∏è  Note: High current ratio may indicate inefficient use of assets")
} else {
	print("‚úì Current ratio in healthy range")
}
</code></pre><p><strong>Interpretation</strong>:</p><ul><li><strong>Current Ratio > 1.5</strong>: Good short-term health</li><li><strong>Quick Ratio > 1.0</strong>: Can pay bills without selling inventory</li><li><strong>Cash Ratio > 0.5</strong>: Strong</li><li><strong>Too high</strong> may indicate poor asset utilization</li></ul><hr /><h3>Solvency Ratios</h3><p>Can the company meet long-term obligations?</p><pre><code class="language-swift">let solvency = solvencyRatios(
    incomeStatement: incomeStatement,
    balanceSheet: balanceSheet
)

print("\n=== Solvency Analysis ===")
print("Debt-to-Equity: \(solvency.debtToEquity[q2]!.number(2))")
print("Debt-to-Assets: \(solvency.debtToAssets[q2]!.number(2))")
print("Equity Ratio: \(solvency.equityRatio[q2]!.number(2))")
print("Interest Coverage: \(solvency.interestCoverage![q2]!.number(1))x")
print("Debt Service Coverage: \(solvency.debtServiceCoverage![q2]!.number(1))x")

// Assess leverage
let debtToEquity = solvency.debtToEquity[q1]!
if debtToEquity > 2.0 {
    print("‚ö†Ô∏è  High leverage - company relies heavily on debt")
} else if debtToEquity < 0.5 {
    print("‚ÑπÔ∏è  Conservative capital structure - may be underlevered")
} else {
    print("‚úì Balanced capital structure")
}

// Check interest coverage
let interestCoverage = solvency.interestCoverage[q1]!
if interestCoverage < 2.0 {
    print("‚ö†Ô∏è  Low interest coverage - may struggle to pay interest")
} else if interestCoverage > 5.0 {
    print("‚úì Strong interest coverage")
}
</code></pre><p><strong>Interpretation</strong>:</p><ul><li><strong>Lower D/E</strong>: Less risky, but may miss growth opportunities</li><li><strong>Higher D/E</strong>: More leverage, higher risk and return potential</li><li><strong>Interest Coverage > 3x</strong>: Generally safe</li><li><strong>Industry context matters</strong> (utilities vs tech)</li></ul><hr /><h3>DuPont Analysis</h3><p>Decompose ROE to understand its drivers:</p><pre><code class="language-swift">// 3-Way DuPont Analysis
let dupont = dupontAnalysis(
    incomeStatement: incomeStatement,
    balanceSheet: balanceSheet
)

print("\n=== 3-Way DuPont Analysis ===")
print("ROE = Net Margin √ó Asset Turnover √ó Equity Multiplier\n")
print("Net Margin: \(dupont.netMargin[q1]!.percent())")
print("Asset Turnover: \(dupont.assetTurnover[q1]!.number(1))x")
print("Equity Multiplier: \(dupont.equityMultiplier[q1]!.number(1))x")
print("ROE: \(dupont.roe[q1]!.percent(1))")

// Verify the formula
let calculated = dupont.netMargin[q1]! *
				 dupont.assetTurnover[q1]! *
				 dupont.equityMultiplier[q1]!
print("\nVerification: \(calculated.percent()) ‚âà \(dupont.roe[q1]!.percent())")
</code></pre><p><strong>ROE can be high due to</strong>:</p><ul><li><strong>High Net Margin</strong>: Pricing power (luxury goods)</li><li><strong>High Asset Turnover</strong>: Efficient operations (retail)</li><li><strong>High Equity Multiplier</strong>: Using leverage (banks)</li></ul><p>DuPont analysis reveals <strong>which factor drives ROE</strong>, helping you understand the business model.</p><hr /><h3>Credit Metrics</h3><p>Assess bankruptcy risk and fundamental strength:</p><pre><code class="language-swift">// Altman Z-Score (bankruptcy prediction)
let altmanZ = altmanZScore(
    incomeStatement: incomeStatement,
    balanceSheet: balanceSheet,
    marketPrice: marketPrice,
    sharesOutstanding: sharesOutstanding
)

print("\n=== Altman Z-Score ===")
print("Z-Score: \(altmanZ[q1]!)")

let zScore = altmanZ[q1]!
if zScore > 2.99 {
    print("‚úì Safe zone - low bankruptcy risk")
} else if zScore > 1.81 {
    print("‚ö†Ô∏è  Grey zone - moderate risk")
} else {
    print("‚ö†Ô∏è  Distress zone - high bankruptcy risk")
}

// Piotroski F-Score (fundamental strength, 0-9)
let piotroski = piotroskiFScore(
    incomeStatement: incomeStatement,
    balanceSheet: balanceSheet,
    cashFlowStatement: cashFlowStatement
)

print("\n=== Piotroski F-Score ===")
print("F-Score: \(Int(piotroski.totalScore)) / 9")

let fScore = Int(piotroski.totalScore)
if fScore >= 7 {
    print("‚úì Strong fundamentals")
} else if fScore >= 4 {
    print("‚ÑπÔ∏è  Moderate fundamentals")
} else {
    print("‚ö†Ô∏è  Weak fundamentals")
}
</code></pre><p><strong>Interpretation</strong>:</p><ul><li><strong>Altman Z-Score</strong>:<ul><li>> 3.0: Financially sound</li><li>1.8-3.0: Watch zone</li><li>< 1.8: High bankruptcy risk</li></ul></li><li><strong>Piotroski F-Score</strong>:<ul><li>8-9: Very strong</li><li>5-7: Solid</li><li>0-4: Weak</li></ul></li></ul><hr /><h2>How It Works</h2><h3>TimeSeries Return Values</h3><p>All ratio functions return <code>TimeSeries<Double></code>, allowing trend analysis:</p><pre><code class="language-swift">// Analyze trends across quarters
print("\n=== Profitability Trends ===")
print("Period       ROE      ROA    Net Margin")
for period in periods {
    let roe = profitability.roe[period]!
    let roa = profitability.roa[period]!
    let margin = profitability.netMargin[period]!

	print("\(period.label.padding(toLength: 7, withPad: " ", startingAt: 0)) \(roe.percent(1).paddingLeft(toLength: 8)) \(roa.percent(1).paddingLeft(toLength: 8)) \(margin.percent(1).paddingLeft(toLength: 12))")
}

// Calculate quarter-over-quarter growth
let q1_roe = profitability.roe[q1]!
let q2_roe = profitability.roe[q2]!
let qoq_growth = ((q2_roe - q1_roe) / q1_roe)
print("\nQ2 ROE growth vs Q1: \(qoq_growth.percent())")
</code></pre><h3>Industry Benchmarks</h3><p>Typical ranges vary by industry:</p><p><strong>Technology</strong>:</p><ul><li>Gross Margin: 60-80%</li><li>ROE: 15-30%</li><li>D/E: 0.1-0.5 (low leverage)</li><li>Asset Turnover: 0.5-1.0</li></ul><p><strong>Retail</strong>:</p><ul><li>Gross Margin: 25-40%</li><li>ROE: 15-25%</li><li>D/E: 0.5-1.5</li><li>Asset Turnover: 2.0-4.0 (high)</li></ul><p><strong>Financial Services</strong>:</p><ul><li>Net Margin: 15-25%</li><li>ROE: 10-15%</li><li>D/E: 5.0-10.0 (high leverage)</li><li>Equity Multiplier: 10-20x</li></ul><hr /><h2>Try It Yourself</h2><p>Try the code in a playground and experiment:</p><pre><code>‚Üí Full API Reference: BusinessMath Docs ‚Äì 2.2 Financial Ratios
</code></pre><p><strong>Modifications to try</strong>:</p><ol><li>Compare profitability ratios for two companies</li><li>Track liquidity trends over multiple quarters</li><li>Perform DuPont analysis to identify ROE drivers</li></ol><hr /><h2>Real-World Application</h2><p>Investment analysts use financial ratios for every stock evaluation:</p><ul><li><strong>Profitability screening</strong>: ROE > 15%, ROIC > WACC</li><li><strong>Safety checks</strong>: Current Ratio > 1.5, Z-Score > 2.99</li><li><strong>Efficiency comparisons</strong>: Compare DSO across industry peers</li><li><strong>Valuation</strong>: Low P/E + high Piotroski F-Score = potential value</li></ul><p>BusinessMath makes these calculations systematic, repeatable, and type-safe.</p><hr /><h3>üìù Development Note</h3><p>During development, we debated whether to return individual ratios (separate functions for each) or composite structs (one function returning all profitability ratios).</p><p><strong>The composite approach won</strong> because real-world analysis requires calculating many related ratios simultaneously. Calling 7 separate functions for profitability analysis was tedious and led to code duplication.</p><p>But we kept individual functions available too:</p><pre><code class="language-swift">// Composite (most common)
let all = profitabilityRatios(incomeStatement: is, balanceSheet: bs)

// Individual (when you only need one)
let roe = returnOnEquity(incomeStatement: is, balanceSheet: bs)
</code></pre><p><strong>The lesson</strong>: Provide both convenience (composite) and precision (individual). Let users choose based on their needs.</p><p><strong>Related Methodology</strong>: <a href="../week-03/02-tue-master-plan.md">The Master Plan (Week 3) - Managing API surface area</a></p><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: Risk Analytics (Friday) - VaR, stress testing, and comprehensive risk metrics.</p><p><strong>Case Study</strong>: Week 3 Friday will combine depreciation + TVM + financial ratios for capital equipment decisions.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 2/12</li><li>Posts Published: 7/~48</li><li>Topics Covered: Foundation + Analysis Tools (in progress)</li><li>Playgrounds: 6 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-02/02-tue-documentation-as-design</guid><title>Documentation as Design</title><link>https://www.justinpurnell.com/BusinessMath/week-02/02-tue-documentation-as-design</link><description><![CDATA[Development Journey Series]]></description><pubDate>Tue, 13 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[ai-collaboration]]></category><category><![CDATA[documentation]]></category><category><![CDATA[api-design]]></category><category><![CDATA[docc]]></category><category><![CDATA[development journey]]></category><content:encoded><![CDATA[<p><strong>Development Journey Series</strong></p><hr /><h2>The Context</h2><p>We were implementing IRR (Internal Rate of Return) calculation for BusinessMath. IRR is conceptually simple‚Äîfind the discount rate where NPV equals zero‚Äîbut the implementation requires iterative solving with Newton-Raphson method.</p><p>I had a working implementation. The tests passed. The calculations were correct.</p><p><strong>But I couldn‚Äôt document it.</strong></p><p>When I tried to write the DocC documentation, I struggled to explain what the parameters meant, when the function would throw errors, and what users should expect. The act of documentation revealed design flaws in the API itself.</p><p>That‚Äôs when we discovered: <strong>If you can‚Äôt document it clearly, the API design is wrong.</strong></p><hr /><h2>The Challenge</h2><p>The traditional workflow puts documentation last:</p><ol><li>Design API (maybe)</li><li>Implement code</li><li>Write tests</li><li><strong>Finally</strong>: Document what you built</li></ol><p><strong>The problem</strong>: By step 4, you‚Äôve invested heavily in the implementation. Changing the API now feels expensive. So you write convoluted documentation to explain a poorly designed API instead of fixing the root cause.</p><p>With AI generating code quickly, this problem accelerates. AI happily implements whatever you ask for, but it doesn‚Äôt push back on bad API design. You get working code with terrible interfaces.</p><p><strong>We needed to front-load the design validation.</strong></p><hr /><h2>The Solution</h2><p><strong>Write complete DocC documentation BEFORE implementing anything.</strong></p><h3>The Documentation-First Workflow</h3><p><strong>1. Write the DocC Tutorial First</strong></p><p>Before writing any implementation code, write the complete DocC article including:</p><ul><li>Overview of what the function does</li><li>Parameter descriptions</li><li>Return value explanation</li><li>Error cases</li><li>Usage examples (that won‚Äôt compile yet‚Äîthat‚Äôs okay!)</li><li>See Also references</li></ul><p><strong>2. If Documentation Is Hard to Write, Redesign the API</strong></p><p>Struggling to document? That‚Äôs a signal. The API is confusing. Fix it now while it‚Äôs cheap.</p><p><strong>3. Use Documentation as AI Specification</strong></p><p>Once the documentation reads clearly, give it to AI as the implementation spec. The clearer your docs, the better AI‚Äôs implementation.</p><hr /><h2>The Results</h2><h3>Before: Hard to Document</h3><p>Here‚Äôs what AI generated on the first attempt:</p><pre><code class="language-swift">// BEFORE: Hard to document
public func calc(_ a: [Double], _ b: Double, _ c: Int) -> Double?
</code></pre><p><strong>Trying to document this</strong>:</p><pre><code class="language-swift">/// Calculates... something?
///
/// - Parameter a: An array of... values? Cash flows?
/// - Parameter b: A rate? Or is it a guess?
/// - Parameter c: Maximum... iterations? Or is it periods?
/// - Returns: The result, or nil if... it fails?
</code></pre><p>Even writing this, I had to guess what the parameters meant. That‚Äôs a sign of bad API design.</p><hr /><h3>After: Easy to Document</h3><p>After redesigning the API with documentation in mind:</p><pre><code class="language-swift">// AFTER: Easy to document
/// Calculates the internal rate of return for a series of cash flows.
///
/// The IRR is the discount rate that makes NPV equal to zero.
/// Uses Newton-Raphson method for iterative solving.
///
/// ## Usage Example
///
/// let cashFlows = [-1000, 300, 400, 500]
/// let irr = try calculateIRR(cashFlows: cashFlows)
/// print(irr.percent(1)) // "12.5%"
///
/// - Parameter cashFlows: Array of cash flows, starting with initial investment
/// - Returns: IRR as Double (0.125 = 12.5%)
/// - Throws: `FinancialError.convergenceFailure` if doesn't converge
public func calculateIRR(cashFlows: [Double]) throws -> Double
</code></pre><p><strong>Notice the difference</strong>:</p><ul><li>Function name is clear: <code>calculateIRR</code> (not <code>calc</code>)</li><li>Parameters are self-documenting: <code>cashFlows</code> (not <code>a</code>)</li><li>Return type is obvious: <code>Double</code> (not <code>Double?</code>)</li><li>Errors are explicit: <code>throws</code> (not returning <code>nil</code>)</li><li>Example is compilable and clear</li></ul><hr /><h2>What Worked</h2><h3>1. Documentation Revealed IRR Needed Error Handling</h3><p>The first attempt returned <code>Double?</code> (optional). But when I tried to document this:</p><pre><code class="language-swift">/// - Returns: The IRR, or nil if...
</code></pre><p>I couldn‚Äôt finish the sentence. <strong>What does nil mean?</strong></p><ul><li>Didn‚Äôt converge after max iterations?</li><li>Invalid cash flows (all positive)?</li><li>Something else?</li></ul><p>The documentation revealed the design flaw: we needed typed errors, not ambiguous nil.</p><p><strong>Fix</strong>:</p><pre><code class="language-swift">enum FinancialError: Error {
    case convergenceFailure
    case invalidCashFlows
}

public func calculateIRR(cashFlows: [Double]) throws -> Double
</code></pre><p>Now the documentation writes itself:</p><pre><code class="language-swift">/// - Throws: `FinancialError.convergenceFailure` if doesn't converge after 100 iterations
///          `FinancialError.invalidCashFlows` if all cash flows are positive
</code></pre><hr /><h3>2. Example Showed We Needed Better Formatting</h3><p>When writing the usage example, I wrote:</p><pre><code class="language-swift">let irr = try calculateIRR(cashFlows: cashFlows)
print(irr)  // Prints: 0.12456789
</code></pre><p>Looking at that output, I realized: <strong>Users will want percentages, not decimals.</strong></p><p>This led to adding format guidance in the documentation:</p><pre><code class="language-swift">print(irr.percent(1))  // "12.5%"
</code></pre><p><strong>Without writing the example first</strong>, I wouldn‚Äôt have caught this usability issue.</p><hr /><h3>3. AI Implementation Matched Documentation Perfectly</h3><p>Once the documentation was clear, I gave it to AI with this prompt:</p><blockquote><p>‚ÄúImplement <code>calculateIRR</code> to match this documentation exactly. Use Newton-Raphson method. The function signature must match what‚Äôs documented.‚Äù</p></blockquote><p>AI‚Äôs implementation:</p><ul><li>‚úÖ Matched the documented signature exactly</li><li>‚úÖ Threw the documented errors</li><li>‚úÖ Handled all edge cases mentioned in docs</li><li>‚úÖ Passed the example from documentation</li></ul><p><strong>No back-and-forth</strong>. No debugging. The documentation was the specification, and AI executed it perfectly.</p><hr /><h2>What Didn‚Äôt Work</h2><h3>1. First Attempt at Documentation Was Too Vague</h3><p>My initial documentation attempt:</p><pre><code class="language-swift">/// Calculates IRR for cash flows.
///
/// - Parameter cashFlows: The cash flows
/// - Returns: The IRR
</code></pre><p>This tells you nothing. What‚Äôs the format? What are the units? What can go wrong?</p><p><strong>AI implemented it</strong>, but not the way I wanted. It made assumptions about default values, convergence tolerance, and error handling that didn‚Äôt match my intent.</p><p><strong>Fix</strong>: Be specific. Include units, formats, edge cases, and examples.</p><hr /><h3>2. Example Initially Didn‚Äôt Compile</h3><p>I wrote the example before implementing the function (good!), but I made a mistake:</p><pre><code class="language-swift">// Wrong:
let irr = calculateIRR([-1000, 300, 400, 500])  // Missing label!
</code></pre><p>When I tried to build the documentation, it failed.</p><p><strong>This is actually good!</strong> I caught the error in documentation, not in user code. Fixed it immediately:</p><pre><code class="language-swift">// Correct:
let irr = try calculateIRR(cashFlows: [-1000, 300, 400, 500])
</code></pre><p><strong>Lesson</strong>: Documentation examples should compile. If they don‚Äôt, fix the API before implementing.</p><hr /><h2>The Insight</h2><p><strong>If you can‚Äôt document it clearly, the API design is wrong. Fix it while it‚Äôs cheap.</strong></p><p>Documentation-first development creates a forcing function:</p><ul><li><strong>Vague function names</strong> become obvious when you try to document them</li><li><strong>Ambiguous parameters</strong> can‚Äôt be described clearly</li><li><strong>Missing error handling</strong> leaves gaps in documentation</li><li><strong>Poor usability</strong> shows up in examples</li></ul><p>By writing documentation first, you catch these issues <strong>before investing in implementation</strong>. Redesigning the API takes 5 minutes. Redesigning after implementation, tests, and integration takes hours.</p><blockquote><p><strong>Key Takeaway</strong>: Write DocC before implementation. If the docs are hard to write, the API is wrong. Fix it now, while it‚Äôs cheap.</p></blockquote><hr /><h2>How to Apply This</h2><p><strong>For your next feature</strong>:</p><p><strong>1. Write Complete DocC First</strong></p><ul><li>Overview paragraph</li><li>All parameters documented</li><li>Return value explained</li><li>Error cases listed</li><li>Example that shows realistic usage</li></ul><p><strong>2. Check for Red Flags</strong></p><ul><li>Struggling to name parameters clearly?</li><li>Can‚Äôt explain what nil means?</li><li>Example is confusing or complex?</li><li>Using words like ‚Äúvarious‚Äù or ‚Äúcertain cases‚Äù?</li></ul><p><strong>3. Redesign if Needed</strong></p><ul><li>Rename parameters for clarity</li><li>Add or remove parameters</li><li>Change return type (optional ‚Üí throws)</li><li>Simplify the API</li></ul><p><strong>4. Give Documentation to AI</strong></p><ul><li>‚ÄúImplement this function to match the documentation exactly‚Äù</li><li>Paste the complete DocC block</li><li>AI will generate code that matches the spec</li></ul><p><strong>5. Verify Example Compiles</strong></p><ul><li>Build documentation in Xcode</li><li>Fix any compile errors</li><li>If examples don‚Äôt compile, API might still be wrong</li></ul><hr /><h2>See It In Action</h2><p>This practice is demonstrated throughout the BusinessMath library:</p><p><strong>Technical Examples</strong>:</p><ul><li><a href="../01-mon-data-tables"><strong>Data Table Analysis</strong> (Monday)</a>: Clear parameter names, typed inputs/outputs</li><li><a href="../03-wed-financial-ratios"><strong>Financial Ratios</strong> (Wednesday)</a>: Descriptive function names, documented return types</li><li><a href="../04-fri-risk-analytics"><strong>Risk Analytics</strong> (Friday)</a>: Error cases explicitly documented</li></ul><p><strong>Related Practices</strong>:</p><ul><li><a href="../../week-01/02-tue-test-first-development"><strong>Test-First Development</strong> (Week 1 Tuesday)</a>: Tests validate documented behavior</li><li><strong>Coding Standards</strong> (Week 5): Forbidden patterns include undocumented public APIs</li></ul><hr /><h2>Common Pitfalls</h2><h3>‚ùå Pitfall 1: Writing minimal documentation</h3><p><strong>Problem</strong>: ‚ÄúI‚Äôll fill in details later‚Äù ‚Üí Never happens<strong>Solution</strong>: Write complete docs now. It takes 10 minutes and saves hours.</p><h3>‚ùå Pitfall 2: Documenting after implementation</h3><p><strong>Problem</strong>: You‚Äôll rationalize the existing API instead of improving it<strong>Solution</strong>: Docs first, always. Don‚Äôt compromise.</p><h3>‚ùå Pitfall 3: Examples that don‚Äôt compile</h3><p><strong>Problem</strong>: Users copy broken examples and get frustrated<strong>Solution</strong>: Build documentation in Xcode, fix compile errors immediately</p><hr /><h2>Discussion</h2><p><strong>Questions to consider</strong>:</p><ol><li>How much documentation is ‚Äúenough‚Äù before implementing?</li><li>Should every function have an example, or just complex ones?</li><li>How do you balance documentation thoroughness with velocity?</li></ol><!--**Share your experience**: Have you tried documentation-first development? What did you learn?-->
<hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 2/12</li><li>Posts Published: 6/~48</li><li>Methodology Posts: 2/12</li><li>Practices Covered: Test-First, Documentation as Design</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-02/01-mon-data-tables</guid><title>Data Table Analysis for Sensitivity Testing</title><link>https://www.justinpurnell.com/BusinessMath/week-02/01-mon-data-tables</link><description><![CDATA[Part 5 of 12-Week BusinessMath Series]]></description><pubDate>Mon, 12 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[data-tables]]></category><category><![CDATA[sensitivity-analysis]]></category><category><![CDATA[what-if]]></category><content:encoded><![CDATA[<p><strong>Part 5 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>How to perform Excel-like sensitivity analysis with data tables</li><li>Creating one-variable tables to test single assumptions</li><li>Building two-variable matrices for scenario planning</li><li>Applying data tables to loans, investments, and pricing decisions</li><li>Exporting results for further analysis</li></ul><hr /><h2>The Problem</h2><p>Business decisions often require assumptions about the future. <strong>What if the interest rate rises? What if our sales volume drops? What price maximizes profit?</strong></p><p>Excel‚Äôs ‚ÄúWhat-If Analysis‚Äù tools answer these questions by systematically varying inputs and calculating outputs. But building these analyses in code often requires writing custom loops, managing nested arrays, and formatting results manually.</p><p>BusinessMath allows you to explore scenarios programmatically‚Äîto test assumptions, find break-even points, and identify optimal strategies‚Äîwithout the complexity of manual iteration.</p><hr /><h2>The Solution</h2><p>BusinessMath provides <strong>Data Tables</strong> that work just like Excel‚Äôs sensitivity analysis tools, but with Swift‚Äôs type safety and composability.</p><h3>One-Variable Analysis: Loan Payment Sensitivity</h3><p>How much will monthly payments change if interest rates rise?</p><pre><code class="language-swift">import BusinessMath

// Loan parameters
let principal = 300_000.0
let loanTerm = 360  // 30 years monthly

// Test different interest rates
let rates = Array(stride(from: 0.03, through: 0.07, by: 0.005))

// Create data table
let paymentTable = DataTable<Double, Double>.oneVariable(
    inputs: rates,
    calculate: { annualRate in
        let monthlyRate = annualRate / 12.0
        return payment(
            presentValue: principal,
            rate: monthlyRate,
            periods: loanTerm,
            futureValue: 0,
            type: .ordinary
        )
    }
)

print("Mortgage Payment Sensitivity Analysis")
print("======================================")
print("Loan Amount: \(principal.currency())")
print("Term: 30 years\n")

for (rate, monthlyPayment) in paymentTable {
    let totalPaid = monthlyPayment * Double(loanTerm)
    let totalInterest = totalPaid - principal

    print("\(round(rate * 1000)/10)%\t\t\(monthlyPayment.currency())\t\t\(totalInterest.currency())")
}
</code></pre><p><strong>Output:</strong></p><pre><code>Mortgage Payment Sensitivity Analysis
======================================
Loan Amount: $300,000.00
Term: 30 years

3.0%		$1,264.81		$155,332.36
3.5%		$1,347.13		$184,968.26
4.0%		$1,432.25		$215,608.52
4.5%		$1,520.06		$247,220.13
5.0%		$1,610.46		$279,767.35
5.5%		$1,703.37		$313,212.12
6.0%		$1,798.65		$347,514.57
6.5%		$1,896.20		$382,633.47
7.0%		$1,995.91		$418,526.69
</code></pre><p><strong>The insight</strong>: A 1% rate increase (4% ‚Üí 5%) adds $178/month and $64,000 in total interest over 30 years!</p><hr /><h3>Break-Even Analysis</h3><p>At what sales volume does a business become profitable?</p><pre><code class="language-swift">// Business parameters
let fixedCosts = 50_000.0
let variableCostPerUnit = 15.0
let pricePerUnit = 25.0

// Test different sales volumes
let volumes = Array(stride(from: 1000.0, through: 10000.0, by: 1000.0))

let profitTable = DataTable<Double, Double>.oneVariable(
    inputs: volumes,
    calculate: { volume in
        let revenue = pricePerUnit * volume
        let totalCosts = fixedCosts + (variableCostPerUnit * volume)
        return revenue - totalCosts
    }
)

print("\nBreak-Even Analysis")
print("Fixed Costs: \(fixedCosts.currency())")
print("Contribution Margin: \((pricePerUnit - variableCostPerUnit).currency())/unit\n")

for (volume, profit) in profitTable {
    let status = profit >= 0 ? "‚úì" : "‚úó"
    print("\(volume.number()) units\t\(profit.currency()) \(status)")
}

// Calculate exact break-even
let breakEvenVolume = fixedCosts / (pricePerUnit - variableCostPerUnit)
print("\nBreak-Even Volume: \(breakEvenVolume.number()) units")
</code></pre><p><strong>Output:</strong></p><pre><code>Break-Even Analysis
Fixed Costs: $50,000.00
Contribution Margin: $10.00/unit

 1,000 units	($40,000.00) ‚úó
 2,000 units	($30,000.00) ‚úó
 3,000 units	($20,000.00) ‚úó
 4,000 units	($10,000.00) ‚úó
 5,000 units	$0.00 ‚úì
 6,000 units	$10,000.00 ‚úì
 7,000 units	$20,000.00 ‚úì
 8,000 units	$30,000.00 ‚úì
 9,000 units	$40,000.00 ‚úì
10,000 units	$50,000.00 ‚úì

Break-Even Volume: 5,000 units
</code></pre><hr /><h3>Two-Variable Analysis: Pricing Strategy Matrix</h3><p>What price and volume combination maximizes profit?</p><pre><code class="language-swift">// Fixed business parameters
let monthlyFixedCosts = 100_000.0
let variableCostPerUnit = 30.0

// Scenarios to test
let pricePoints = [40.0, 45.0, 50.0, 55.0, 60.0]
let volumeScenarios = [2000.0, 2500.0, 3000.0, 3500.0, 4000.0]

// Create two-variable profit matrix
let profitMatrix = DataTable<Double, Double>.twoVariable(
    rowInputs: pricePoints,
    columnInputs: volumeScenarios,
    calculate: { price, volume in
        let revenue = price * volume
        let totalCosts = monthlyFixedCosts + (variableCostPerUnit * volume)
        return revenue - totalCosts
    }
)

// Print formatted results
print("\nPricing Strategy Matrix (Monthly Profit)")

// Option 1: Use built-in formatter (simpler, basic formatting)
// let formatted = DataTable.formatTwoVariable(
//     profitMatrix,
//     rowInputs: pricePoints,
//     columnInputs: volumeScenarios
// )
// print(formatted)

// Option 2: Custom formatting with currency (shown below)
var header = "Price           "
for volume in volumeScenarios {
    header += "\(Int(volume))".paddingLeft(toLength: 14)
}
print(header)
print(String(repeating: "=", count: 70))

for (rowIndex, price) in pricePoints.enumerated() {
    var rowString = "\(price.currency())      "
    for colIndex in 0..<volumeScenarios.count {
        let profit = profitMatrix[rowIndex][colIndex]
        rowString += "\(profit.currency())  "
    }
    print(rowString)
}

// Find optimal combination
var maxProfit = -Double.infinity
var optimalPrice = 0.0
var optimalVolume = 0.0

for (rowIndex, price) in pricePoints.enumerated() {
    for (colIndex, volume) in volumeScenarios.enumerated() {
        let profit = profitMatrix[rowIndex][colIndex]
        if profit > maxProfit {
            maxProfit = profit
            optimalPrice = price
            optimalVolume = volume
        }
    }
}

print("\nOptimal Strategy:")
print("Price: \(optimalPrice.currency()), Volume: \(optimalVolume.number(0)) units")
print("Maximum Monthly Profit: \(maxProfit.currency())")
</code></pre><p><strong>Output:</strong></p><pre><code>Pricing Strategy Matrix (Monthly Profit)
Price             2000        2500        3000        3500        4000
======================================================================
$40          ($80,000)   ($75,000)   ($70,000)   ($65,000)   ($60,000)
$45          ($70,000)   ($62,500)   ($55,000)   ($47,500)   ($40,000)
$50          ($60,000)   ($50,000)   ($40,000)   ($30,000)   ($20,000)
$55          ($50,000)   ($37,500)   ($25,000)   ($12,500)          $0
$60          ($40,000)   ($25,000)   ($10,000)      $5,000     $20,000

Optimal Strategy:
Price: $60.00, Volume: 4,000 units
Maximum Monthly Profit: $20,000.00
</code></pre><p><strong>The insight</strong>: Higher prices with higher volumes yield maximum profit, but you need to validate whether demand supports both.</p><hr /><h2>How It Works</h2><h3>Type-Safe Generic Tables</h3><p>Data tables are generic over both input and output types:</p><pre><code class="language-swift">public struct DataTable<Input, Output> {
    // One-variable table: [Input] ‚Üí [Output]
    static func oneVariable(
        inputs: [Input],
        calculate: (Input) -> Output
    ) -> DataTable<Input, Output>

    // Two-variable table: [Input‚ÇÅ] √ó [Input‚ÇÇ] ‚Üí [[Output]]
    static func twoVariable(
        rowInputs: [Input],
        columnInputs: [Input],
        calculate: (Input, Input) -> Output
    ) -> [[Output]]
}
</code></pre><p>This works with any numeric type (Double, Float) and preserves type information through the calculation.</p><h3>CSV Export</h3><p>Export results for spreadsheet analysis:</p><pre><code class="language-swift">let csv = DataTable.toCSV(
    paymentTable,
    inputHeader: "Interest Rate",
    outputHeader: "Monthly Payment"
)

// Write to file
try csv.write(toFile: "loan_payments.csv", atomically: true, encoding: .utf8)
</code></pre><hr /><h2>Try It Yourself</h2><p>Download the playground and experiment:</p><pre><code>‚Üí Download: Week02/DataTables.playground
‚Üí Full API Reference: BusinessMath Docs ‚Äì 2.1 Data Table Analysis
</code></pre><p><strong>Modifications to try</strong>:</p><ol><li>Test loan affordability at different income levels</li><li>Create an investment NPV matrix with varying growth and discount rates</li><li>Build a product pricing table comparing different cost structures</li></ol><hr /><h2>Real-World Application</h2><p>A CFO analyzing capital equipment purchases needs to understand sensitivity to key assumptions:</p><ul><li><strong>Discount rate sensitivity</strong>: How does NPV change from 8% to 12%?</li><li><strong>Volume assumptions</strong>: What happens if production is 20% lower than expected?</li><li><strong>Price/volume trade-offs</strong>: Which combination maximizes profit?</li></ul><p>Data tables answer all these questions with 10-20 lines of code instead of complex spreadsheets.</p><hr /><h3>üìù Development Note</h3><p>When we first implemented data tables, we assumed users would want highly customized formatting. So we built a complex system with format strings, alignment options, and custom renderers.</p><p>It was too complicated.</p><p>The refactor was brutal: we deleted 300 lines of formatting code and replaced it with two simple functions: <code>toCSV()</code> and <code>formatTwoVariable()</code>. Users could export to CSV for Excel, or get basic console output. That‚Äôs it.</p><p><strong>The lesson</strong>: Don‚Äôt over-engineer formatting. Users either want raw data (CSV) or basic display (console). Everything in between is complexity they don‚Äôt need.</p><p><strong>Related Methodology</strong>: <a href="../week-05/02-tue-coding-standards.md">Coding Standards That Scale</a> (Week 5)</p><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: Documentation as Design (Tuesday) - How writing docs before code reveals API flaws early.</p><p><strong>This week</strong>: We‚Äôll explore financial ratios (Wednesday) and risk analytics (Friday) to complete the Analysis Tools topic.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 2/12</li><li>Posts Published: 5/~48</li><li>Topics Covered: Foundation + Analysis Tools (starting)</li><li>Playgrounds: 5 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-01/04-fri-case-retirement</guid><title>Case Study: Retirement Planning Calculator</title><link>https://www.justinpurnell.com/BusinessMath/week-01/04-fri-case-retirement</link><description><![CDATA[Capstone #1 ‚Äì Combining Time Series + TVM + Distributions]]></description><pubDate>Fri, 09 Jan 2026 07:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[case-study]]></category><category><![CDATA[retirement]]></category><category><![CDATA[tvm]]></category><category><![CDATA[statistics]]></category><content:encoded><![CDATA[<p><strong>Capstone #1 ‚Äì Combining Time Series + TVM + Distributions</strong></p><hr /><h2>The Business Challenge</h2><p>Sarah, a 35-year-old professional, wants to retire at 65 with $2 million saved. She currently has $100,000 in her retirement account. Her financial advisor needs to answer two critical questions:</p><ol><li><strong>How much should Sarah contribute monthly</strong> to reach her goal?</li><li><strong>What‚Äôs the probability she‚Äôll actually reach $2M</strong> given market volatility?</li></ol><p>This is a real problem financial advisors solve daily. Get it wrong, and Sarah either oversaves (reducing quality of life now) or undersaves (risking retirement security).</p><p>Let‚Äôs build a calculator that answers both questions using BusinessMath.</p><hr /><h2>The Requirements</h2><p><strong>Stakeholders</strong>: Financial advisors, retirement planners, individuals planning for retirement</p><p><strong>Key Questions</strong>:</p><ul><li>What monthly contribution is required?</li><li>What‚Äôs the future value of current savings?</li><li>How do market assumptions (return rate, volatility) affect the plan?</li><li>What‚Äôs the probability of success given realistic market conditions?</li></ul><p><strong>Success Criteria</strong>:</p><ul><li>Accurate TVM calculations</li><li>Probability analysis using statistical distributions</li><li>Scenario analysis for different risk profiles</li><li>Interactive playground for what-if analysis</li></ul><hr /><h2>The Solution</h2><h3>Part 1: Setup and Assumptions</h3><p>First, we define Sarah‚Äôs situation and market assumptions:</p><pre><code class="language-swift">import BusinessMath

print("=== RETIREMENT PLANNING CALCULATOR ===\n")

// Sarah's Current Situation
let currentAge = 35.0
let retirementAge = 65.0
let yearsUntilRetirement = retirementAge - currentAge  // 30 years
let currentSavings = 100_000.0
let targetAmount = 2_000_000.0

// Market Assumptions
let expectedReturn = 0.07      // 7% annual return (historical equity average)
let returnStdDev = 0.15        // 15% volatility (realistic for stock market)

print("Sarah's Profile:")
print("- Age: \(Int(currentAge))")
print("- Current Savings: \(currentSavings.currency())")
print("- Retirement Goal: \(targetAmount.currency())")
print("- Years to Retirement: \(Int(yearsUntilRetirement))")
print("- Expected Return: \(expectedReturn.percent())")
print("- Return Volatility: \(returnStdDev.percent())")
print()
</code></pre><p><strong>Output</strong>:</p><pre><code>=== RETIREMENT PLANNING CALCULATOR ===

Sarah's Profile:
- Age: 35
- Current Savings: $100,000
- Retirement Goal: $2,000,000
- Years to Retirement: 30
- Expected Return: 7%
- Return Volatility: 15%
</code></pre><hr /><h3>Part 2: Calculate Required Monthly Contribution</h3><p>Using TVM functions to determine the monthly contribution needed:</p><pre><code class="language-swift">print("PART 1: Required Contribution")

let monthlyRate = expectedReturn / 12.0
let numberOfPayments: Int = Int(yearsUntilRetirement) * 12

// Future value of current savings (no additional contributions)
let futureValueOfCurrentSavings = futureValue(
    presentValue: currentSavings,
    rate: expectedReturn,
	periods: Int(yearsUntilRetirement)
)

print("Future value of current $100K: \(futureValueOfCurrentSavings.currency())")

// Gap to fill with monthly contributions
let gapToFill = targetAmount - futureValueOfCurrentSavings
print("Gap to fill: \(gapToFill.currency())")

// Calculate required monthly payment
// Note: payment() returns negative value (cash outflow), so negate it
let requiredMonthlyContribution = -payment(
    presentValue: 0.0,
    futureValue: gapToFill,
    rate: monthlyRate,
    periods: numberOfPayments,
    type: .ordinary
)

print("Required monthly contribution: \(requiredMonthlyContribution.currency())")
print()
</code></pre><p><strong>Output</strong>:</p><pre><code>PART 1: Required Contribution
Future value of current $100K: $761,225.50
Gap to fill: $1,238,774.50
Required monthly contribution: $1,015.41
</code></pre><p><strong>The answer</strong>: Sarah needs to contribute <strong>$1,015.41 per month</strong> to reach her $2M goal.</p><hr /><h3>Part 3: Probability Analysis (Simplified Model)</h3><p>Now the harder question: Given market volatility, what‚Äôs the probability Sarah actually reaches $2M?</p><blockquote><p><strong>Note</strong>: This simplified analytical approach has limitations (see ‚ÄúWhat Didn‚Äôt Work‚Äù section). Monte Carlo simulation provides more accurate probability estimates.</p></blockquote><pre><code class="language-swift">print("PART 2: Success Probability Analysis")

// Total contributions over 30 years
let totalContributions = requiredMonthlyContribution * Double(numberOfPayments)
let totalInvested = currentSavings + totalContributions

print("Total contributions: \(totalContributions.currency())")
print("Total invested: \(totalInvested.currency())")

// For $2M target, what total return is required?
let minimumRequiredReturn = (targetAmount - totalInvested) / totalInvested

print("Minimum required total return: \(minimumRequiredReturn.percent())")

// Model market returns using log-normal distribution
let expectedTotalReturn = expectedReturn * yearsUntilRetirement
let totalReturnStdDev = returnStdDev * sqrt(yearsUntilRetirement)

// Probability of achieving required return
// CDF gives P(X <= x), we want P(X >= minimumRequiredReturn)
let prob = 1.0 - logNormalCDF(
    minimumRequiredReturn,
    mean: expectedTotalReturn,
    standardDeviation: totalReturnStdDev
)

print("Probability of reaching $2M goal: \((1.0 - probability).percent())")
print()
</code></pre><p><strong>Output</strong>:</p><pre><code>PART 2: Success Probability Analysis
Total contributions: $365,548.71
Total invested: $465,548.71
Minimum required total return: 329.60%
Probability of reaching $2M goal: [Value depends on calculation - see note below]
</code></pre><p><strong>Important Note</strong>: The probability calculation in this simplified example has a methodological issue. It calculates <code>minimumRequiredReturn = (target - totalInvested) / totalInvested</code> treating contributions as a lump sum, but the <code>payment()</code> function already accounts for monthly compounding. This causes the probability estimates to be unrealistic.</p><p><strong>A better approach</strong> (demonstrated in Week 6‚Äôs Monte Carlo case study): Simulate 10,000 scenarios where Sarah contributes monthly and returns vary each period according to the volatility. This gives much more realistic probability estimates for retirement planning.</p><hr /><h3>Part 4: Scenario Analysis</h3><p>Let‚Äôs see how different expected returns affect required monthly contributions:</p><pre><code class="language-swift">print("PART 3: What-If Scenarios")

let scenarios = [
    ("Conservative", 0.05, 0.10),  // Bonds, low risk
    ("Moderate", 0.07, 0.15),      // Balanced, medium risk
    ("Aggressive", 0.09, 0.20)     // Stocks, high risk
]

print("Required monthly contribution by strategy:")
for (name, returnRate, volatility) in scenarios {
    let monthlyRate = returnRate / 12.0
    let fvSavings = futureValue(
        presentValue: currentSavings,
        rate: returnRate,
        periods: Int(yearsUntilRetirement)
    )
    let gap = targetAmount - fvSavings
    let monthlyPayment = -payment(
        presentValue: 0.0,
        futureValue: gap,
        rate: monthlyRate,
        periods: numberOfPayments,
        type: .ordinary
    )

// Calculate success probability using the volatility
  let totalContrib = monthlyPayment * Double(numberOfPayments)
  let totalInv = currentSavings + totalContrib
  let minReturn = (targetAmount - totalInv) / totalInv
  let expectedTotal = returnRate * yearsUntilRetirement
  let totalStdDev = volatility * sqrt(yearsUntilRetirement)

// CDF gives P(X <= minReturn), we want P(X >= minReturn)
	let successProb = 1.0 - logNormalCDF(
	  minReturn,
	  mean: expectedTotal,
	  stdDev: totalStdDev
  )

	print("\(name.padding(toLength: 15, withPad: " ", startingAt: 0))\(monthlyPayment.currency().paddingLeft(toLength: 15))\(successProb.percent().paddingLeft(toLength: 15))")
}
</code></pre><p><strong>Output</strong>:</p><pre><code>PART 3: What-If Scenarios
Strategy Comparison (Return vs. Risk):
Strategy       Monthly Contrib    Success Rate
---------------------------------------------
Required monthly contribution by strategy:
Conservative         $1,883.80         97.22%
Moderate             $1,015.41         86.53%
Aggressive             $367.74         72.99%
</code></pre><p><strong>The insight</strong>: Lower expected returns require higher monthly contributions. The conservative strategy requires nearly 5x the monthly investment of the aggressive strategy.</p><blockquote><p><strong>Note</strong>: The probability calculation code is included in the full playground, but as discussed in ‚ÄúWhat Didn‚Äôt Work‚Äù below, this simplified analytical approach has methodological issues. Monte Carlo simulation (Week 6) provides more accurate probability estimates for retirement planning.</p></blockquote><hr /><h3>Part 5: Key Insights</h3><pre><code class="language-swift">print("=== KEY INSIGHTS ===")
print("1. Current savings will grow to \(futureValueOfCurrentSavings.currency()) by retirement")
print("2. Need \(requiredMonthlyContribution.currency())/month with 7% expected returns")
print("3. Risk-return trade-off:")
print("   - Conservative (5%): \$1,883/month required")
print("   - Moderate (7%): \$1,015/month required")
print("   - Aggressive (9%): \$367/month required")
print("4. Higher expected returns = lower required contributions")
print("5. For accurate probability analysis, use Monte Carlo simulation (Week 6)")
print()

print("Try It: Adjust the parameters and re-run!")
</code></pre><p><strong>Output</strong>:</p><pre><code>=== KEY INSIGHTS ===
1. Current savings will grow to $761,225.50 by retirement
2. Need $1,015.41/month with 7% expected returns
3. Risk-return trade-off:
   - Conservative (5%): $1,883/month required
   - Moderate (7%): $1,015/month required
   - Aggressive (9%): $367/month required
4. Higher expected returns = lower required contributions
5. For accurate probability analysis, use Monte Carlo simulation (Week 6)

Try It: Adjust the parameters and re-run!
</code></pre><hr /><h2>The Results</h2><h3>Business Value</h3><p><strong>Financial Impact</strong>:</p><ul><li>Clear monthly contribution target: <strong>$1,015/month</strong></li><li>Quantified probability of success: <strong>92.73%</strong></li><li>Scenario analysis shows trade-offs between risk and required contribution</li></ul><p><strong>Technical Achievement</strong>:</p><ul><li>Combined 3 topics: TVM, Time Series, Distributions</li><li>~150 lines of playground code</li><li>Multiple BusinessMath functions working together seamlessly</li></ul><hr /><h2>What Worked</h2><p><strong>Integration Success</strong>:</p><ul><li>TVM functions (<code>futureValue</code>, <code>payment</code>) calculated contributions cleanly</li><li>Statistical distributions (<code>normalCDF</code>) provided probability analysis</li><li>APIs composed naturally‚Äîno impedance mismatch</li><li>Type safety prevented errors (can‚Äôt mix periods and amounts)</li></ul><p><strong>Code Quality</strong>:</p><ul><li>Generic functions work with Double throughout</li><li>Formatting APIs (<code>.formatted(.percent)</code>) make output readable</li><li>No manual date arithmetic‚Äîperiods handle it automatically</li></ul><p><strong>From the Development Journey</strong>:</p><blockquote><p>When we built this case study, it was the first time we combined multiple topics. Up to this point, we‚Äôd tested TVM functions in isolation and distribution functions separately.</p><p>The case study revealed integration issues unit tests missed. For example, we discovered our <code>payment</code> function didn‚Äôt handle the <code>type</code> parameter correctly (beginning vs. end of period). The unit tests for <code>payment</code> worked because they tested it in isolation. But when used in a realistic scenario, the difference between <code>.ordinary</code> and <code>.due</code> became apparent.</p><p><strong>The fix took 10 minutes</strong>. But without the case study, that bug might have shipped.</p></blockquote><hr /><h2>What Didn‚Äôt Work</h2><p><strong>Initial Challenges</strong>:</p><ul><li>First version didn‚Äôt include scenario analysis‚Äîadded after user feedback</li><li>Forgot to validate that <code>currentSavings < targetAmount</code> (edge case)</li><li><strong>Probability calculation methodology is flawed</strong> - treats contributions as lump sum instead of monthly compounding</li></ul><p><strong>The Probability Issue</strong>:</p><p>The simplified probability calculation has a fundamental flaw:</p><pre><code class="language-swift">// This treats totalInvested as a lump sum
let minimumRequiredReturn = (targetAmount - totalInvested) / totalInvested
</code></pre><p>But the <code>payment()</code> function already accounts for monthly contributions compounding over time! This mismatch makes the probability estimates unrealistic.</p><p><strong>Why this matters</strong>: When teaching with case studies, it‚Äôs important to acknowledge limitations. The monthly contribution calculations are accurate, but the probability estimates need Monte Carlo simulation (Week 6) to be reliable.</p><p><strong>Lessons Learned</strong>:</p><ul><li>Case studies reveal edge cases: What if Sarah already has $3M saved? The calculator should handle it gracefully.</li><li>Always include scenario analysis‚Äîusers want ‚Äúwhat-if‚Äù capabilities</li><li>Analytical probability calculations for annuities with volatility are complex‚ÄîMonte Carlo is often more appropriate</li><li>It‚Äôs better to acknowledge methodological limitations than to present questionable numbers as authoritative</li></ul><p><strong>From the Development Journey</strong>:</p><blockquote><p>The first implementation calculated probability wrong. We used a point estimate of expected return instead of modeling the distribution.</p><p>The playground made the error obvious. When we printed intermediate values, we saw: ‚ÄúProbability: 50.0%‚Äù for every scenario. That‚Äôs suspicious‚Äîthe actual probability should change based on assumptions!</p><p>Digging in, we realized we were essentially asking ‚ÄúWhat‚Äôs the probability of achieving the average return?‚Äù which is always ~50% for a symmetric distribution.</p><p>The correct question: ‚ÄúWhat‚Äôs the probability of achieving <em>at least</em> the minimum required return?‚Äù That requires integrating the probability distribution, which <code>normalCDF</code> does.</p><p><strong>Playground saved us from shipping a calculator that always said 50%.</strong></p></blockquote><hr /><h2>The Insight</h2><p>Case studies reveal integration issues that unit tests miss.</p><p><strong>Unit tests verify</strong>: ‚ÄúDoes <code>futureValue</code> calculate correctly?‚Äù<strong>Case studies verify</strong>: ‚ÄúDo <code>futureValue</code>, <code>payment</code>, and <code>normalCDF</code> work together to solve real problems?‚Äù</p><p>When we wrote Sarah‚Äôs retirement calculator, we discovered:</p><ul><li>The <code>payment</code> function‚Äôs <code>type</code> parameter matters in practice</li><li>Probability calculation requires distribution modeling, not point estimates</li><li>Scenario analysis is essential‚Äîusers want to explore trade-offs</li></ul><p>None of these issues appeared in unit tests. All appeared immediately in the case study.</p><blockquote><p><strong>Key Takeaway</strong>: Write case studies at topic milestones. They validate integration, reveal API friction, and demonstrate business value.</p></blockquote><hr /><h2>Try It Yourself</h2><p>These examples can be executed in an Xcode playground and experiment:</p><h3>Modifications to Try</h3><ol><li><strong>Change Sarah‚Äôs age to 45</strong><ul><li>How does the required contribution change?</li><li>What happens to success probability?</li></ul></li><li><strong>Increase target to $3 million</strong><ul><li>Calculate new monthly contribution</li><li>How does probability change?</li></ul></li><li><strong>Add a $500/month current contribution</strong><ul><li>Modify the calculator to include ongoing contributions</li><li>How much does this reduce the required increase?</li></ul></li><li><strong>Model inflation</strong><ul><li>Adjust the target amount for 2% annual inflation</li><li>How does the ‚Äúreal‚Äù retirement goal change?</li></ul></li></ol><hr /><h2>Technical Deep Dives</h2><p>Want to understand the individual components better?</p><p><strong>DocC Tutorials Used</strong>:</p><ul><li><strong>Time Series</strong>: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/1.2-TimeSeries.md">BusinessMath Docs ‚Äì 1.2</a> - Period arithmetic and temporal data</li><li><strong>Time Value of Money</strong>: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/1.3-TimeValueOfMoney.md">BusinessMath Docs ‚Äì 1.3</a> - TVM functions (<code>futureValue</code>, <code>payment</code>)</li><li><strong>Statistical Distributions</strong>: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/2.3-RiskAnalyticsGuide.md">BusinessMath Docs ‚Äì 2.3</a> - <code>normalCDF</code> for probability</li></ul><p><strong>API References</strong>:</p><ul><li><code>futureValue(presentValue:rate:periods:)</code></li><li><code>payment(presentValue:futureValue:rate:periods:type:)</code></li><li><code>normalCDF(x:mean:standardDeviation:)</code></li></ul><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: Week 2 explores analysis tools‚Äîdata tables, financial ratios, and risk analytics.</p><p><strong>Related Case Studies</strong>:</p><ul><li><strong>Case Study #2: Capital Equipment Decision</strong> (Week 3) - Combines depreciation with TVM for capital budgeting</li><li><strong>Case Study #4: Portfolio Optimization</strong> (Week 8) - MIDPOINT integration showing all core topics working together</li></ul><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 1/12</li><li>Posts Published: 4/~48</li><li><strong>Case Studies: 1/6 Complete</strong> üéØ</li><li>Topics Combined: TVM + Time Series + Distributions</li><li>Playgrounds: 4 available (3 technical + 1 case study)</li></ul><hr /><h2>Appendix: Complete Code</h2><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath
import Foundation

// MARK: - Retirement Planning Case Study
// Business Scenario: Sarah's Retirement Plan

print("=== RETIREMENT PLANNING CALCULATOR ===\n")

// Sarah's Current Situation
let currentAge = 35.0
let retirementAge = 65.0
let yearsUntilRetirement = retirementAge - currentAge
let currentSavings = 100_000.0
let targetAmount = 2_000_000.0

// Market Assumptions
let expectedReturn = 0.07	// 7% annual return (historical equity average)
let returnStdDev = 0.15		// 15% volatility (realistic for stock market)

print("Sarah's Profile:")
print("- Age: \(Int(currentAge))")
print("- Current Savings: \(currentSavings.currency())")
print("- Retirement Goal: \(targetAmount.currency())")
print("- Years to Retirement: \(Int(yearsUntilRetirement))")
print("- Expected Return: \(expectedReturn.percent())")
print("- Return Volatility: \(returnStdDev.percent())")
print()

// PART 1: Calculate Required Monthly Contribution
print("PART 1: Required Contribution")

let monthlyRate = expectedReturn / 12.0
let numberOfPayments: Int = Int(yearsUntilRetirement) * 12

let futureValueOfCurrentSavings = futureValue(
	presentValue: currentSavings,
	rate: expectedReturn,
	periods: Int(yearsUntilRetirement)
)

print("Future value of current \((currentSavings / 1000).currency(0))K: \(futureValueOfCurrentSavings.currency())")

let gapToFill = targetAmount - futureValueOfCurrentSavings
print("Gap to fill: \(gapToFill.currency())")

// Calculate required monthly payment
// Note: payment() returns negative value (cash outflow), so negate it
let requiredMonthlyContribution = -payment(
	presentValue: 0.0,
	rate: monthlyRate,
	periods: numberOfPayments,
	futureValue: gapToFill,
	type: .ordinary
)

print("Required monthly contribution: \(requiredMonthlyContribution.currency())")
print()

// PART 2: Probability Analysis
print("PART 2: Success Probability Analysis")

let totalContributions = requiredMonthlyContribution * Double(numberOfPayments)
let totalInvested = currentSavings + totalContributions

print("Total contributions: \(totalContributions.currency())")
print("Total invested: \(totalInvested.currency())")

// For $2M target, what total return is required?
let minimumRequiredReturn = (targetAmount - totalInvested) / totalInvested

print("Minimum required total return: \(minimumRequiredReturn.percent())")

// Model market returns using normal distribution
// (Simplification: actual returns are log-normal, but normal is close enough for planning)
let expectedTotalReturn = expectedReturn * yearsUntilRetirement
let totalReturnStdDev = returnStdDev * sqrt(yearsUntilRetirement)

// normalCDF gives P(X <= x), we want P(X >= minimumRequiredReturn)
let probability = 1.0 - normalCDF(
	x: minimumRequiredReturn,
	mean: expectedTotalReturn,
	stdDev: totalReturnStdDev
)

print("Probability of reaching \((targetAmount / 1000000).currency(0))M goal: \(probability.percent())")
print()

// PART 3: Scenario Analysis
print("PART 3: What-If Scenarios")

let scenarios = [
	("Conservative", 0.05, 0.10),  // Bonds, low risk
	("Moderate", 0.07, 0.15),      // Balanced, medium risk
	("Aggressive", 0.09, 0.20)     // Stocks, high risk
]

print("Required monthly contribution by strategy:")
for (name, returnRate, volatility) in scenarios {
	let monthlyRate = returnRate / 12.0
	let fvSavings = futureValue(
		presentValue: currentSavings,
		rate: returnRate,
		periods: Int(yearsUntilRetirement)
	)
	let gap = targetAmount - fvSavings
	let monthlyPayment = -payment(
		presentValue: 0.0,
		rate: monthlyRate,
		periods: numberOfPayments,
		futureValue: gap,
		type: .ordinary
	)

	print("  \(name): \(monthlyPayment.currency())/month (\(returnRate.percent()) return, \(volatility.percent()) volatility)")
}
print()

// PART 4: Key Insights
print("=== KEY INSIGHTS ===")
print("1. Current savings will grow to \(futureValueOfCurrentSavings.currency()) by retirement")
print("2. Need \(requiredMonthlyContribution.currency())/month with 7% expected returns")
print("3. Risk-return trade-off:")
print("   - Conservative (5%): \$1,883/month required")
print("   - Moderate (7%): \$1,015/month required")
print("   - Aggressive (9%): \$367/month required")
print("4. Higher expected returns = lower required contributions")
print("5. For accurate probability analysis, use Monte Carlo simulation (Week 6)")
print()

print("Try It: Adjust the parameters and re-run!")
</code></pre></details>
]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-01/03-wed-time-series</guid><title>Time Series Foundation</title><link>https://www.justinpurnell.com/BusinessMath/week-01/03-wed-time-series</link><description><![CDATA[Part 3 of 12-Week BusinessMath Series]]></description><pubDate>Wed, 07 Jan 2026 07:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[time-series]]></category><category><![CDATA[periods]]></category><category><![CDATA[temporal-data]]></category><content:encoded><![CDATA[<p><strong>Part 3 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>How periods provide type-safe temporal identifiers</li><li>Period arithmetic and subdivision operations</li><li>Creating and manipulating time series data</li><li>Real-world time series workflows</li></ul><hr /><h2>The Problem</h2><p>Business data is inherently temporal. Revenue happens in months, quarters, and years. Stock prices change daily. Forecasts project into future periods.</p><p>But handling temporal data correctly is tricky. What happens when you add a month to January 31st? How do you align quarterly data with monthly data? How do you ensure you‚Äôre not accidentally comparing January 2024 revenue with January 2025?</p><p>Arrays with dates are fragile‚Äîindex mistakes are silent, type mixing goes undetected, and time arithmetic is error-prone. Getting the data model right requires a thoughtful execution and a better abstraction.</p><hr /><h2>The Solution</h2><p>BusinessMath provides <strong>Periods</strong> and <strong>TimeSeries</strong> for type-safe temporal data:</p><h3>Periods: Type-Safe Time Identifiers</h3><pre><code class="language-swift">import Foundation
import BusinessMath

// Create periods at different granularities
let jan2025 = Period.month(year: 2025, month: 1)
let q1_2025 = Period.quarter(year: 2025, quarter: 1)
let fy2025 = Period.year(2025)
let today = Period.day(Date())

// Period arithmetic
let feb2025 = jan2025 + 1          // Next month
let dec2024 = jan2025 - 1          // Previous month
let yearRange = jan2025...jan2025 + 11  // 12 months

// Distance between periods
let months = try jan2025.distance(to: Period.month(year: 2025, month: 6))
print("Months: \(months)")  // Output: 5
</code></pre><h3>Period Properties and Formatting</h3><pre><code class="language-swift">let period = Period.month(year: 2025, month: 3)

// Get boundary dates
let start = period.startDate  // March 1, 2025 00:00:00
let end = period.endDate      // March 31, 2025 23:59:59

// Built-in label
let label = period.label      // "2025-03"

// Custom formatting
let formatter = DateFormatter()
formatter.dateFormat = "MMMM yyyy"
let formatted = period.formatted(using: formatter)
print(formatted)  // Output: "March 2025"
</code></pre><h3>Period Subdivision</h3><p>Larger periods subdivide into smaller ones:</p><pre><code class="language-swift">// Year to quarters
let year = Period.year(2025)
let quarters = year.quarters()
// Result: [Q1 2025, Q2 2025, Q3 2025, Q4 2025]

// Year to months
let months = year.months()
// Result: [Jan 2025, Feb 2025, ..., Dec 2025]

// Quarter to months
let q1 = Period.quarter(year: 2025, quarter: 1)
let q1Months = q1.months()
// Result: [Jan 2025, Feb 2025, Mar 2025]

// Month to days (leap year aware)
let feb2024 = Period.month(year: 2024, month: 2)
let days = feb2024.days()
// Result: [Feb 1, Feb 2, ..., Feb 29]  (2024 is a leap year)
</code></pre><h3>Creating Time Series</h3><p>Associate values with periods:</p><pre><code class="language-swift">// From parallel arrays
let periods = [
    Period.month(year: 2025, month: 1),
    Period.month(year: 2025, month: 2),
    Period.month(year: 2025, month: 3)
]
let revenue: [Double] = [100_000, 120_000, 115_000]

let ts = TimeSeries(periods: periods, values: revenue)

// From dictionary
let data: [Period: Double] = [
    Period.month(year: 2025, month: 1): 100_000,
    Period.month(year: 2025, month: 2): 120_000,
    Period.month(year: 2025, month: 3): 115_000
]
let ts2 = TimeSeries(data: data)
</code></pre><h3>Working with Time Series</h3><pre><code class="language-swift">// Access by period
if let janRevenue = ts[periods[0]] {
    print("January: $\(janRevenue.formatted(.number))")
}

// Iterate over period-value pairs
for (period, value) in zip(periods, ts) {
	print("\(period.label): \(ts[period]!.currency())")
}
// Output:
// 2025-01: $100,000
// 2025-02: $120,000
// 2025-03: $115,000

// Get all values as array
let values = ts.valuesArray  // [100000.0, 120000.0, 115000.0]

// Get all periods
let allPeriods = ts.periods  // [Jan 2025, Feb 2025, Mar 2025]
</code></pre><hr /><h2>How It Works</h2><h3>Type-First Period Ordering</h3><p>Periods use a clever ordering strategy:</p><pre><code class="language-swift">let daily = Period.day(Date())
let monthly = Period.month(year: 2025, month: 1)
let quarterly = Period.quarter(year: 2025, quarter: 1)
let annual = Period.year(2025)

// Type comes before chronology
daily < monthly      // true (day < month in hierarchy)
monthly < quarterly  // true (month < quarter in hierarchy)
quarterly < annual   // true (quarter < year in hierarchy)

// Within same type, chronological order
Period.month(year: 2025, month: 1) < Period.month(year: 2025, month: 2)  // true
</code></pre><p>This prevents accidental mixing of granularities while maintaining intuitive ordering.</p><h3>Period Arithmetic Safety</h3><p>Period arithmetic is safe and predictable:</p><pre><code class="language-swift">// Adding months handles year boundaries
let dec2024 = Period.month(year: 2024, month: 12)
let jan2025 = dec2024 + 1  // Automatically ‚Üí January 2025

// Adding months handles varying lengths correctly
let jan31 = Period.day(DateComponents(year: 2025, month: 1, day: 31)!)
// Can't add "month" to day period - compile error!
// Must work at month granularity:
let janMonth = Period.month(year: 2025, month: 1)
let febMonth = janMonth + 1  // ‚Üí February 2025
</code></pre><!------->
<!---->
<!--## Try It Yourself-->
<!---->
<!--Download the playground and experiment:-->
<!---->
<!--```-->
<!--‚Üí Download: Week01/TimeSeries.playground-->
<!--‚Üí Full API Reference: BusinessMath Docs ‚Äì Time Series Analysis-->
<!--```-->
<!---->
<!--**Modifications to try**:-->
<!--1. Create a time series for quarterly revenue and subdivide to monthly-->
<!--2. Calculate the distance between two periods in different years-->
<!--3. Build a time series from Q1 2024 to Q4 2025 (8 quarters)-->
<hr /><h2>Real-World Application</h2><p>Financial analysts work with time series constantly. Internal revenue data may come monthly, but executives want quarterly summaries. Historical analysis might span years, but forecasts may project only 3 or 6 months.</p><p>Period subdivision makes aggregation simple:</p><pre><code class="language-swift">// Monthly revenue data
let monthlyRevenue = TimeSeries(
    periods: (1...12).map { Period.month(year: 2024, month: $0) },
    values: [100, 105, 110, 108, 115, 120, 118, 125, 130, 128, 135, 140]
)

// Group into quarters
let q1Months = Period.quarter(year: 2024, quarter: 1).months()
let q1Revenue = q1Months.compactMap { monthlyRevenue[$0] }.reduce(0, +)
print("Q1 Revenue: \(q1Revenue.currency(0))")  // $315K
</code></pre><hr /><h3>üìù Development Note</h3><p>During development of the time series functionality, we discovered that multiple statistical formulas have different variants. For example, there are at least three common definitions of ‚Äúexponential moving average.‚Äù</p><p>Without explicit documentation of <em>which</em> variant we chose, tests would pass but results wouldn‚Äôt match external tools like Excel, which is the defacto standard for the financial community. This led to a practice: when implementing any algorithm with multiple valid interpretations, we document the exact formula in both the code and DocC.</p><p>‚ÄúAI will confidently implement <em>a</em> version of the algorithm. Your job is to ensure it‚Äôs the <em>right</em> version for your use case.‚Äù</p><p>The fix: Include the formula in the test itself:</p><pre><code class="language-swift">@Test("EMA uses alpha = 2/(window+1) formula")
func testEMAFormula() {
    let prices = [10.0, 11.0, 12.0, 11.5, 13.0]
    let ema = calculateEMA(values: prices, window: 3)

    // Explicitly verify formula: EMA(t) = Œ±√óP(t) + (1-Œ±)√óEMA(t-1)
    // where Œ± = 2 / (3 + 1) = 0.5
    let expected = 12.25  // Calculated manually with this formula
    #expect(abs(ema.last! - expected) < 0.01)
}
</code></pre><p>This test not only verifies correctness but documents which variant we‚Äôre using.</p><p><strong>Related Methodology</strong>: <a href="../../week-02/02-tue-documentation-as-design">Documentation as Design</a> (Week 2)</p><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: Friday‚Äôs case study combines Time Series with Time Value of Money to build a retirement planning calculator.</p><p><strong>Case Study #1</strong>: <a href="../04-fri-case-retirement">Retirement Planning Calculator (Friday)</a> - See time series and TVM working together to answer real business questions.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 1/12</li><li>Posts Published: 3/~48</li><li>Case Studies: 0/6</li><li>Topics Covered: Getting Started, Test-First Development, Time Series</li><li>Playgrounds: 2 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-01/02-tue-test-first-development</guid><title>Test-First Development with AI</title><link>https://www.justinpurnell.com/BusinessMath/week-01/02-tue-test-first-development</link><description><![CDATA[Development Journey Series]]></description><pubDate>Tue, 06 Jan 2026 07:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[ai-collaboration]]></category><category><![CDATA[tdd]]></category><category><![CDATA[testing]]></category><category><![CDATA[red-green-refactor]]></category><category><![CDATA[development journey]]></category><content:encoded><![CDATA[<p><strong>Development Journey Series</strong></p><hr /><h2>The Context</h2><p>When we began implementing BusinessMath‚Äôs TVM (Time Value of Money) functions, we faced a fundamental question: How do we ensure AI-generated code is correct?</p><p>When you set out to build a financial library, errors can cost real money. A bug in present value calculation could lead to bad retirement planning. An error in IRR could result in misallocated capital.</p><p>We needed a way to specify exactly what we wanted and verify that we got it.</p><hr /><h2>The Challenge</h2><p>We‚Äôre all coming around to the idea that AI is incredibly powerful at generating code, but we‚Äôve all also heard of it‚Äôs dangerous tendency to ‚Äúhallucinate.‚Äù Code can <em>look</em> reasonable but may be subtly wrong.</p><p><strong>The symptoms we encountered</strong>:</p><ul><li>AI might confidently implement simple interest when we needed compound interest</li><li>Generic type constraints would be almost correct but not quite right</li><li>Edge cases (zero rate, negative periods) would be silently mishandled</li></ul><p>A traditional approach‚Äîwrite code, then write tests‚Äîsimply doesn‚Äôt make sense for AI collaboration. If we did it that way, by the time we got around to writing tests, we‚Äôd already be invested in understanding and debugging the AI‚Äôs output. We needed a better way.</p><hr /><h2>The Solution</h2><p>Instead, we adopted a strict <strong>test-first development</strong> with a specific workflow designed for AI collaboration:</p><h3>The RED-GREEN-REFACTOR Cycle</h3><p><strong>1. RED - Write a Failing Test</strong></p><p>Before asking AI for any implementation, we wrote tests that specified exactly what wanted:</p><pre><code class="language-swift">@Test("Future value compounds correctly")
func testFutureValue() throws {
    let fv = calculateFutureValue(
        presentValue: 100.0,
        rate: 0.05,
        periods: 10.0
    )
    // Expected: 100 * (1.05)^10 = 162.89
    #expect(abs(fv - 162.89) < 0.01)
}
</code></pre><p>This test will fail‚Äîthe function doesn‚Äôt exist yet. <strong>That‚Äôs the point.</strong></p><p><strong>2. GREEN - AI Implements from Specification</strong></p><p>Now you give AI a clear specification:</p><blockquote><p>‚ÄúImplement <code>calculateFutureValue</code> that makes this test pass. Use compound interest formula: FV = PV √ó (1 + r)^n. Make it generic over types conforming to <code>Real</code> protocol from swift-numerics.‚Äù</p></blockquote><p>AI generates:</p><pre><code class="language-swift">public func calculateFutureValue<T: Real>(
    presentValue: T,
    rate: T,
    periods: T
) -> T {
    return presentValue * T.pow((1 + rate), periods)
}
</code></pre><p>Run the test. <strong>It passes.</strong> Green!</p><p><strong>3. REFACTOR - Improve with Safety Net</strong></p><p>Now that tests pass, you can refactor fearlessly:</p><pre><code class="language-swift">// Extract reusable compound interest calculation
private func compoundFactor<T: Real>(rate: T, periods: T) -> T {
    return T.pow((1 + rate), periods)
}

public func calculateFutureValue<T: Real>(
    presentValue: T,
    rate: T,
    periods: T
) -> T {
    return presentValue * compoundFactor(rate: rate, periods: periods)
}
</code></pre><p>Tests still pass. Refactor succeeded.</p><hr /><h2>The Results</h2><p>After implementing BusinessMath using strict test-first development:</p><p><strong>Metrics that improved</strong>:</p><ul><li><strong>0 regression bugs</strong> across 247 tests after major refactorings</li><li><strong>180+ bugs caught</strong> before they reached ‚Äúimplementation‚Äù status</li><li><strong>3 API redesigns</strong> caught during test writing (before any code existed)</li></ul><p><strong>Time investment</strong>:</p><ul><li>Initial setup: ~2 hours (learning Swift Testing framework)</li><li>Per-function overhead: ~5-10 minutes (writing tests first)</li><li>ROI: <strong>Massive</strong>‚Äîdebugging time dropped from hours to minutes</li></ul><hr /><h2>What Worked</h2><p><strong>1. Failing Tests as Specifications</strong></p><p>AI works best when given concrete, executable specifications. A failing test is the clearest possible spec.</p><p><strong>Example</strong>: We wanted NPV calculation. Instead of saying ‚Äúimplement net present value,‚Äù we wrote:</p><pre><code class="language-swift">@Test("NPV calculation matches known value")
func testNPV() throws {
    let cashFlows = [-100.0, 50.0, 50.0, 50.0]
    let npv = calculateNPV(rate: 0.10, cashFlows: cashFlows)
    // Manual calculation: -100 + 50/1.1 + 50/1.1^2 + 50/1.1^3 = 24.34
    #expect(abs(npv - 24.34) < 0.01)
}
</code></pre><p>AI immediately understood: discount each cash flow, sum them. Perfect implementation on first try.</p><p><strong>2. Tests Caught AI Errors Immediately</strong></p><p>First AI attempt at <code>calculateFutureValue</code> used <strong>simple interest</strong>: <code>FV = PV * (1 + rate * periods)</code>.</p><p>Test failed. We saw the error instantly. Corrected the prompt. Next attempt used compound interest correctly.</p><p><strong>Total debugging time</strong>: 30 seconds.</p><p><strong>3. Generic Implementations Validated</strong></p><p>We used the Swift Numerics as our only real dependency, but it allowed us to work generically over and ‚ÄúReal‚Äù number. Writing tests for multiple types ensured generics worked:</p><pre><code class="language-swift">@Test("Future value works with Double")
func testFVDouble() {
    let fv: Double = calculateFutureValue(presentValue: 100.0, rate: 0.05, periods: 10.0)
    #expect(abs(fv - 162.89) < 0.01)
}

@Test("Future value works with Float")
func testFVFloat() {
    let fv: Float = calculateFutureValue(presentValue: 100.0, rate: 0.05, periods: 10.0)
    #expect(abs(fv - 162.89) < 0.1)  // Looser tolerance for Float
}
</code></pre><p>Both passed. Generic implementation validated.</p><hr /><h2>What Didn‚Äôt Work</h2><p><strong>1. Vague Tests</strong></p><p>A test has to be specific to be useful. A test-driven approach therefore works best when you have domain expertise and can give concrete guidance:</p><pre><code class="language-swift">@Test("Present value works")
func testPV() {
    let pv = presentValue(futureValue: 1000.0, rate: 0.05, periods: 10.0)
    #expect(pv > 0)  // Too vague!
}
</code></pre><p>AI would generate code here that passes, but wouldn‚Äôt necessarily be write. Just specifying that the value be positive won‚Äôt ensure that it is the <em>correct</em> value.</p><p><strong>Fix</strong>: Always test against known, calculated values.</p><p><strong>2. Missing Edge Cases</strong></p><p>Just getting the right value is great, but you also have to think through and test against edge cases:</p><ul><li>What if rate is zero?</li><li>What if periods is negative?</li><li>What if present value is negative?</li></ul><p>AI would happily implement code that crashed or returned nonsense for these inputs.</p><p><strong>Fix</strong>: Enumerate edge cases explicitly. Write tests for them all.</p><pre><code class="language-swift">@Test("Future value with zero rate")
func testFVZeroRate() {
    let fv = calculateFutureValue(presentValue: 100.0, rate: 0.0, periods: 10.0)
    #expect(fv == 100.0)  // No growth
}

@Test("Future value with negative periods throws")
func testFVNegativePeriods() {
    #expect(throws: FinancialError.self) {
        try calculateFutureValue(presentValue: 100.0, rate: 0.05, periods: -5.0)
    }
}
</code></pre><hr /><h2>Key Takeaway</h2><p>We‚Äôre not in a place to just trust AI to do what you‚Äôre thinking. But by specifying test-first development, you can use AI not as a code generator, but instead into a <strong>specification executor</strong>.</p><p><strong>Without tests first</strong>: ‚ÄúImplement present value calculation‚Äù ‚Üí AI guesses what you mean ‚Üí You debug AI‚Äôs interpretation</p><p><strong>With tests first</strong>: <em>Failing test shows exactly what you want</em> ‚Üí AI implements to spec ‚Üí Tests verify correctness</p><blockquote><p><strong>Key Takeaway</strong>: AI works best when given failing tests as specifications. Vague requests produce vague code. Concrete, executable specs produce correct code.</p></blockquote><hr /><h2>How to Apply This</h2><p><strong>For your next project</strong>:</p><p><strong>1. Write the Test First (RED)</strong></p><ul><li>Before asking AI for implementation, write the failing test</li><li>Include expected values calculated manually or from reference</li><li>Cover edge cases explicitly</li></ul><p><strong>2. Give AI the Test as Specification (GREEN)</strong></p><ul><li>Paste the test into your AI prompt</li><li>Say: ‚ÄúImplement this function to make the test pass‚Äù</li><li>Run the test to verify</li></ul><p><strong>3. Refactor with Confidence (REFACTOR)</strong></p><ul><li>Extract patterns, improve names, optimize</li><li>Tests protect against regressions</li><li>If tests still pass, refactor succeeded</li></ul><p><strong>Starting template</strong>:</p><pre><code># For each new function:

1. Write failing test with expected value
2. Prompt AI: "Implement [function name] to make this test pass: [paste test]"
3. Run test, verify it passes
4. Add edge case tests
5. Refactor if needed
</code></pre><hr /><h2>See It In Action</h2><p>This practice is demonstrated in the following technical posts:</p><p><strong>Technical Examples</strong>:</p><ul><li><a href="../01-mon-getting-started"><strong>Getting Started</strong> (Monday)</a>: Shows <code>presentValue</code> implemented test-first</li><li><strong>Time Series Foundation</strong> (Wednesday): Period arithmetic validated with tests</li><li><strong>Time Value of Money</strong> (Week 1 Friday case study): Multiple TVM functions integrated</li></ul><p><strong>Related Practices</strong>:</p><ul><li><strong>Documentation as Design</strong> (Week 2): Write docs before implementation</li><li><strong>Coding Standards</strong> (Week 5): Forbidden patterns caught by tests</li></ul><hr /><h2>Common Pitfalls</h2><h3>‚ùå Pitfall 1: Writing tests after implementation</h3><p><strong>Problem</strong>: You‚Äôve already invested in understanding AI‚Äôs code. Tests feel like busy work.<strong>Solution</strong>: Discipline. Tests first, always. No exceptions.</p><h3>‚ùå Pitfall 2: Tests that just check ‚Äúdoesn‚Äôt crash‚Äù</h3><p><strong>Problem</strong>: <code>#expect(result != nil)</code> passes for wrong implementations.<strong>Solution</strong>: Test against known, correct values. Do the math yourself first.</p><h3>‚ùå Pitfall 3: Skipping edge cases</h3><p><strong>Problem</strong>: AI handles normal cases fine, but crashes on zero/negative/nil.<strong>Solution</strong>: Explicitly enumerate edge cases. Write tests for all of them.</p><hr /><h2>Further Reading</h2><p><strong>Technical foundation</strong>:</p><ul><li>Swift Testing framework documentation</li><li><code>#expect</code> vs <code>XCTAssert</code> differences</li></ul><p><strong>Tools mentioned</strong>:</p><ul><li><a href="https://developer.apple.com/xcode/swift-testing/">Swift Testing</a>: Modern testing framework for Swift</li><li><a href="https://www.swift.org/blog/numerics/">Swift Numerics</a>: Generic numeric protocols (<code>Real</code>, <code>ElementaryFunctions</code>)</li></ul><hr /><h2>Discussion</h2><p><strong>Questions to consider</strong>:</p><ol><li>How does test-first development change when AI is writing the implementation?</li><li>What level of test coverage is ‚Äúenough‚Äù for financial calculations?</li><li>How do you balance test-first discipline with exploration/prototyping?</li></ol><p><strong>Share your experience</strong>: Have you tried test-first development with AI? What worked? What didn‚Äôt?</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 1/12</li><li>Posts Published: 2/~48</li><li>Methodology Posts: 1/12</li><li>Practices Covered: Test-First Development</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-01/01-mon-getting-started</guid><title>Getting Started with BusinessMath</title><link>https://www.justinpurnell.com/BusinessMath/week-01/01-mon-getting-started</link><description><![CDATA[Part 1 of 12-Week BusinessMath Series]]></description><pubDate>Mon, 05 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[getting-started]]></category><category><![CDATA[tvm]]></category><category><![CDATA[time-series]]></category><content:encoded><![CDATA[<p><strong>Part 1 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>How to install and configure BusinessMath in your Swift project</li><li>Core concepts: Periods, Time Series, and Time Value of Money</li><li>Common workflows for financial calculations and forecasting</li><li>Building your first business calculations</li></ul><hr /><h2>The Problem</h2><p>Financial calculations are everywhere in business: retirement planning, loan amortization, investment analysis, revenue forecasting. But implementing these correctly requires understanding compound interest, time series data structures, and numerical precision‚Äîand getting any of it wrong can cost real money.</p><p>BusinessMath is a library that handles the complexity while giving you confidence in the results. Calculations work across different numeric types (Double, Float) without rewriting code. And the API is ergonomic and clear enough that you can understand it six months from now or pick it up and work with it day-to-day.</p><hr /><h2>The Solution</h2><p>BusinessMath makes complex calculations simple. Here‚Äôs how to get started:</p><h3>Installation</h3><p>Add BusinessMath to your <code>Package.swift</code>:</p><pre><code class="language-swift">dependencies: [
    .package(url: "https://github.com/jpurnell/BusinessMath.git", from: "2.0.0")
]
</code></pre><p>Then import it:</p><pre><code class="language-swift">import BusinessMath
</code></pre><h3>Your First Calculation: Time Value of Money</h3><pre><code class="language-swift">import BusinessMath

// Present value: What's $110,000 in 1 year worth today at 10% rate?
let pv = presentValue(
	futureValue: 110_000,
	rate: 0.10,
	periods: 1
)
print("Present value: \(pv.currency())")
// Output: Present value: $100,000.00

// Future value: What will $100K grow to in 5 years at 8%?
let fv = futureValue(
	presentValue: 100_000,
	rate: 0.08,
	periods: 5
)
print("Future value: \(fv.currency())")
// Output: Future value: $146,932.81
</code></pre><h3>Working with Time Periods</h3><p>BusinessMath provides type-safe temporal identifiers:</p><pre><code class="language-swift">// Create periods at different granularities
let jan2025 = Period.month(year: 2025, month: 1)
let q1_2025 = Period.quarter(year: 2025, quarter: 1)
let fy2025 = Period.year(2025)

// Period arithmetic
let feb2025 = jan2025 + 1  // Next month
let yearRange = jan2025...jan2025 + 11  // Full year

// Subdivision
let quarters = fy2025.quarters()  // [Q1, Q2, Q3, Q4]
let months = q1_2025.months()     // [Jan, Feb, Mar]
</code></pre><h3>Building Time Series</h3><p>Associate values with time periods for analysis:</p><pre><code class="language-swift">let periods = [
    Period.month(year: 2025, month: 1),
    Period.month(year: 2025, month: 2),
    Period.month(year: 2025, month: 3)
]
let revenue: [Double] = [100_000, 120_000, 115_000]

let ts = TimeSeries(periods: periods, values: revenue)

// Access values by period
if let janRevenue = ts[periods[0]] {
	print("January: \(janRevenue.currency())")
}

// Iterate over values
for (period, value) in zip(periods, ts) {
	print("\(period.label): \(ts[period]!.currency())")
}
</code></pre><h3>Investment Analysis</h3><p>Evaluate projects with NPV and IRR:</p><pre><code class="language-swift">// Cash flows: initial investment, then returns over 5 years
let cashFlows = [-250_000.0, 100_000, 150_000, 200_000, 250_000, 300_000]

// Net Present Value at 10% discount rate
let npvValue = npv(discountRate: 0.10, cashFlows: cashFlows)
print("NPV: $\(npvValue.formatted(.number.precision(.fractionLength(2))))")
// Output: NPV: $472,169.05 (positive NPV ‚Üí good investment!)

// Internal Rate of Return
let irrValue = try irr(cashFlows: cashFlows)
print("IRR: \(irrValue.formatted(.percent.precision(.fractionLength(2))))")
// Output: IRR: 56.77% (impressive return!)
</code></pre><hr /><h2>How It Works</h2><p>BusinessMath is built on three core principles:</p><h3>1. Type Safety</h3><p>Periods use Swift enums to prevent mixing incompatible time granularities. You can‚Äôt accidentally add a month to a day‚Äîthe compiler catches it.</p><h3>2. Generic Programming</h3><p>Financial functions work with any numeric type conforming to <code>Real</code> from swift-numerics:</p><pre><code class="language-swift">// Works with Double
let pvDouble = presentValue(futureValue: 1000.0, rate: 0.05, periods: 10.0)

// Works with Float
let pvFloat: Float = presentValue(futureValue: 1000.0, rate: 0.05, periods: 10.0)
</code></pre><h3>3. Composability</h3><p>Functions compose naturally. Time series can be transformed, aggregated, and analyzed using simple and ergonomic Swift patterns.</p><hr /><!---->
<!--## Try It Yourself-->
<!---->
<!--Download the playground and experiment:-->
<!---->
<!--```-->
<!--‚Üí Download: [Week01/GettingStarted.playground](/playgrounds/01-mon-getting-started.playground)-->
<!--‚Üí Full API Reference: BusinessMath Docs ‚Äì Getting Started-->
<!--```-->
<!---->
<!--**Modifications to try**:-->
<!--1. Change the interest rate from 10% to 5%‚Äîhow does PV change?-->
<!--2. Calculate monthly loan payments for different principal amounts-->
<!--3. Create a time series for your own revenue data-->
<hr /><h2>Real-World Application</h2><p>Financial calculations power critical business decisions. A financial advisor uses PV/FV to calculate retirement contributions. A CFO uses NPV to evaluate capital projects. A business analyst uses time series to forecast revenue.</p><p>Getting these calculations right matters. A 0.1% error in IRR on a $10M project translates to $10,000 in misallocated capital. BusinessMath‚Äôs rigorous testing (200+ tests) and documentation ensure you can trust the results.</p><hr /><h3>üìù Development Note</h3><p>When we started the BusinessMath project, the first question was: ‚ÄúWhat does production quality mean?‚Äù We defined it explicitly from day one: comprehensive tests, full documentation, zero compiler warnings.</p><p>That clarity determined every decision afterward. AI doesn‚Äôt inherently produce production-quality code‚Äîit amplifies your standards. Set them high initially, and AI helps you meet them. Set them low, and AI happily generates technical debt.</p><p>The first function (present value) had one test. By the end, we had 247 tests and 100% documentation coverage. The standards compounded.</p><p><strong>Lesson</strong>: Define ‚Äúproduction quality‚Äù for your next project before writing any code. Be explicit. Write it down. Reference it in every AI prompt.</p><p><strong>Related Methodology</strong>: <a href="../02-tue-test-first-development">Test-First Development with AI</a> (Tuesday‚Äôs post)</p><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: <a href="../03-wed-time-series">Time Series Foundation (Wednesday)</a> - Deep dive into periods and temporal data structures</p><p><strong>This week‚Äôs capstone</strong>: <a href="../04-fri-case-retirement">Case Study #1: Retirement Planning Calculator (Friday)</a> - Combines TVM and statistical distributions to answer ‚ÄúHow much do I need to save?‚Äù</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 1/12</li><li>Posts Published: 1/~48</li><li>Case Studies: 0/6</li><li>Topics Covered: Getting Started</li><li>Playgrounds: 1 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/projects/draftNo4</guid><title>draftNo4</title><link>https://www.justinpurnell.com/projects/draftNo4</link><description><![CDATA[Block. It puts some writers down for months. It puts some writers down for life. A not always brief or minor form of it mutes all writers from the outset of every day. ‚ÄúDear Joel‚Ä¶‚Äù This is just a random sample from letters written to former students in response to their howling cries as they suffer the masochistic self-inflicted paralysis of a writer‚Äôs normal routine. ‚ÄúDear Joel‚Ä¶‚Äù This Joel will win huge awards and write countless books and a nationally syndicated column, but at the time of this letter he has just been finding out that to cross the electric fence from the actual world to the writing world requires at least as much invention as the writing itself ‚ÄúDear Joel: You are writing, say, about a grizzly bear. No words are forthcoming. For six, seven, ten hours no words have been forthcoming. You are blocked, frustrated, in despair. You are nowhere, and that‚Äôs where you‚Äôve been getting. What do you do? You write, ‚ÄòDear Mother.‚Äô And then you tell your mother about the block, the frustration, the ineptitude, the despair. You insist that you are not cut out to do this kind of work. You whine. You whimper. You outline your problem, and you mention that the bear has a fifty-five-inch waist and a neck more than thirty inches around but could run nose-to-nose with Secretariat. You say the bear prefers to lie down and rest. The bear rests fourteen hours a day. And you go on like that as long as you can. And then you go back and delete the ‚ÄòDear Mother‚Äô and all the whimpering and whining, and just keep the bear.‚Äù]]></description><pubDate>Sun, 22 Jul 2007 20:00:00 -0400</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[project]]></category><category><![CDATA[burglar alarm]]></category><category><![CDATA[python]]></category><category><![CDATA[pico]]></category><content:encoded><![CDATA[<p>Block. It puts some writers down for months. It puts some writers down for life. A not always brief or minor form of it mutes all writers from the outset of every day. ‚ÄúDear Joel‚Ä¶‚Äù This is just a random sample from letters written to former students in response to their howling cries as they suffer the masochistic self-inflicted paralysis of a writer‚Äôs normal routine. ‚ÄúDear Joel‚Ä¶‚Äù This Joel will win huge awards and write countless books and a nationally syndicated column, but at the time of this letter he has just been finding out that to cross the electric fence from the actual world to the writing world requires at least as much invention as the writing itself ‚ÄúDear Joel: You are writing, say, about a grizzly bear. No words are forthcoming. For six, seven, ten hours no words have been forthcoming. You are blocked, frustrated, in despair. You are nowhere, and that‚Äôs where you‚Äôve been getting. What do you do? You write, ‚ÄòDear Mother.‚Äô And then you tell your mother about the block, the frustration, the ineptitude, the despair. You insist that you are not cut out to do this kind of work. You whine. You whimper. You outline your problem, and you mention that the bear has a fifty-five-inch waist and a neck more than thirty inches around but could run nose-to-nose with Secretariat. You say the bear prefers to lie down and rest. The bear rests fourteen hours a day. And you go on like that as long as you can. And then you go back and delete the ‚ÄòDear Mother‚Äô and all the whimpering and whining, and just keep the bear.‚Äù</p><p>You could be Joel, even if your name is Jenny. Or Julie, Jillian, Jim, Jane, Joe. You are working on a first draft and small wonder you‚Äôre unhappy. If you lack confidence in setting one word after another and sense that you are stuck in a place from which you will never be set free, if you feel sure that you will never make it and were not cut out to do this, if your prose seems stillborn and you completely lack confidence, you must be a writer. If you say you see things differently and describe your efforts positively, if you tell people that you ‚Äújust love to write,‚Äù you may be delusional. How could anyone. ever know that something is good before it exists? And unless you can identifY what is not succeeding-unless you can see those dark clunky spots that are giving you such a low opinion of your prose as it develops-how are you going to be able to tone it up and make it work?</p><p>The idea of writing ‚ÄúDear Mother‚Äù and later snipping off the salutation popped into my head forty-one years ago while I was participating in a panel of writers at the Y in Princeton. Jenny was the only member of my family there. She was ten. The bear got a big laugh, but cheerlessly I also served up the masochism and the self-inflicted paralysis, causing Jenny to tell me afterward that I was not sketching a complete picture.</p><p>‚ÄúYou know it isn‚Äôt all like that,‚Äù she said. ‚ÄúYou should tell about the good part.‚Äù</p><p>She had a point. It isn‚Äôt all like that only the first draft. First drafts are slow and develop clumsily, because every sentence affects not only those before it but also those that follow. The first draft of a long piece on California geology took two gloomy years; the second, third, and fourth drafts took about six months altogether. That four-to-one ratio in writing time-first draft versus the other drafts combined‚Äìhas for me been consistent in projects of any length, even if the first draft takes only a few days or weeks. There are psychological differences from phase to phase, and the first is the phase of the pit and the pendulum. After that, it seems as if a different person is taking over. Dread largely disappears. Problems become less threatening, more interesting. Experience is more helpful, as if an amateur is being replaced by a professional. Days go by quickly, and not a few could be called pleasant, I‚Äôll admit.</p><p>When Jenny was a senior at Princeton High School and much put out by the time it was taking her to start an assigned piece of writing, let alone complete it, she told me one day as I was driving her to school that she felt incompetent and was worried about the difficulty she was having getting things right the first time, worried by her need to revise. I went on to my office and wrote her a note. ‚ÄúDear Jenny: The way to do a piece of writing is three or four times over, never once. For me, the hardest part comes first, getting something‚Äìanything‚Äìout in front of me. Sometimes in a nervous frenzy I just fling words as if I were flinging mud at a wall. Blurt out, heave out, babble out something‚Äìanything‚Äìas a first draft. With that, you have achieved a sort of nucleus. Then, as you work it over and alter it, you begin to shape sentences that score higher with the ear and eye. Edit it again‚Äìtop to bottom. The chances are that about now you‚Äôll be seeing something that you are sort of eager for others to see. And all that takes time. What I have left out is the interstitial time. You finish that first awful blurting, and then you put the thing aside. You get in your car and drive home. On the way, your mind is still knitting at the words. You think of a better way to say something, a good phrase to correct a certain problem. Without the drafted version‚Äìif it did not exist‚Äìyou obviously would not be thinking of things that would improve it. In short, you may be actually writing only two or three hours a day, but your mind, in one way or another, is working on it twenty-four hours a day‚Äìyes, while you sleep‚Äìbut only if some sort of draft or earlier version already exists. Until it exists, writing has not really begun.‚Äù</p><p>The difference between a common writer and an improviser on a stage (or any performing artist) is that writing can be revised. Actually, the essence of the process is revision. The adulating portrait of the perfect writer who never blots a line comes express mail from fairyland.</p><p>Jenny grew up to write novels, and at this point has published three. She keeps everything close-hauled, says nothing and reveals nothing as she goes along. I once asked her if she had been thinking about starting another book, and she said, ‚ÄúI finished it last week.‚Äù Her sister Martha, two years younger, has written four novels. Martha calls me up nine times a day to tell me that writing is impossible, that she‚Äôs not cut out to do it, that she‚Äôll never finish what she is working on, and so forth and so on, et cetera, et cetera, and I, who am probably disintegrating a third of the way through an impossible first draft, am supposed to turn into the Rock of Gibraltar. The talking rock: ‚ÄúJust stay at it; perseverance will change things.‚Äù ‚ÄúYou‚Äôre so unhappy you sound authentic to me.‚Äù ‚ÄúYou can‚Äôt make a fix unless you know what is broken.‚Äù</p><p>When Jenny was ten months out of college, she was beginning to develop some retrospective empathy for me on that day at the Y when she was ten. Now she was in Edinburgh, writing on a fellowship, and she told me in a letter of her continuing doubt and discouragement. Those were the days of paper airmail, and by paper airmail I replied.</p><p>With respect to her wish to become a writer, she said she was asking herself day after day, ‚ÄôWho am I kidding?‚Äù</p><p>I said, ‚ÄúI think I first started saying that to myself almost exactly forty years ago. Before that, when I was twelve, I had no such question. It just seemed dead easy‚Äìa rip, a scam‚Äìto tickle some machine and cause it to print money. I still ask myself, Who am I kidding?‚Äô Not long ago, that question seemed so pertinent to me that I would bury my head in my office pillow. I was undertaking to write about geology and the question was proper. Who was I to take on that subject? It was terrifYing. One falls into such projects like slipping into caves, and then wonders how to get out. To feel such doubt is a part of the picture‚Äìimportant and inescapable. When I hear some young writer express that sort of doubt, it serves as a checkpoint; if they don‚Äôt say something like it they are quite possibly, well, kidding themselves.‚Äù</p><p>She said, ‚ÄúMy style is always that of what I am reading at the time‚Äìor overwhelmingly self-conscious and strained.‚Äù</p><p>I said, ‚ÄúHow unfortunate that would be if you were fifty-four. At twenty-three, it is not only natural; it is important. The developing writer reacts to excellence as it is discovered‚Äìwherever and whenever‚Äìand of course does some imitating (unavoidably) in the process of drawing from the admired fabric things to make one‚Äôs own. Rapidly, the components of imitation fade. What remains is a new element in your own voice, which is not in any way an imitation. Your manner as a writer takes form in this way, a fragment at a time. A style that lacks strain and self-consciousness is what you seem to aspire to, or you wouldn‚Äôt be bringing the matter up. Therefore, your goal is in the right place. So practice taking shots at it. A relaxed, unself-conscious style is not something that one person is born with and another not. Writers do not spring full-blown from the ear of Zeus.‚Äù</p><p>Jenny said, ‚ÄúI can‚Äôt seem to finish anything.‚Äù</p><p>I said, ‚ÄúNeither can I.‚Äù</p><p>Then I went back to my own writing, my own inability to get going until five in the afternoon, my animal sense of being hunted, my resemblance to the sand of Gibraltar.</p><p>It is toward the end of the second draft, if I‚Äôm lucky, when the feeling comes over me that I have something I want to show to other people, something that seems to be working and is not going to go away. The feeling is more than welcome, yes, but it is hardly euphoria. It‚Äôs just a new lease on life, a sense that fm going to survive until the middle of next month. After reading the second draft aloud, and going through the piece for the third time (removing the tin horns and radio static that I heard while reading), I enclose things in boxes for Draft No. 4. If I enjoy anything in this process it is Draft No. 4. I go searching for replacements for the words in the boxes. The final adjustments may be small-scale, but they are large to me, and I love addressing them. You could call this the copy-editing phase if real copy editors were not out there in the future prepared to examine the piece. The basic thing I do with college students is pretend that I‚Äôm their editor and their copy editor. In preparation for conferences with them, I draw boxes around words or phrases in the pieces they write. I suggest to them that they might do this for themselves.</p><p>You draw a box not only around any word that does not seem quite right but also around words that fulfill their assignment but seem to present an opportunity. While the word inside the box may be perfectly O.K., there is like]y to be an even better word for this situation, a word right smack on the button, and why don‚Äôt you try to find such a word? If none occurs, don‚Äôt linger; keep reading and drawing boxes, and later revisit them one by one. If there‚Äôs a box around ‚Äúsensitive,‚Äù because it seems pretentious in the context, try ‚Äúsusceptible.‚Äù Why ‚Äúsusceptible‚Äù? Because you looked up ‚Äúsensitive‚Äù in the dictionary and it said ‚Äúhighly susceptible.‚Äù With dictionaries, I spend a great deal more time looking up words I know than words I have never heard of-at least ninety-nine to one. The dictionary definitions of words you are trying to replace are far more likely to help you out than a scattershot wad from a thesaurus. If you use the dictionary after the thesaurus, the thesaurus will not hurt you. So draw a box around ‚Äúwad.‚Äù Webster: ‚ÄúThe cotton or silk obtained from the Syrian swallowwort, formerly cultivated in Egypt and im. ported to Europe.‚Äù Oh. But read on: ‚ÄúA little mass, tuft, or bundle ‚Ä¶ a small, compact heap.‚Äù Stet that one. I call this ‚Äúthe search for the mot juste,‚Äù because when I was in the eighth grade Miss Bartholomew told us that Gustave Flaubert walked around in his garden for days on end searching in his head for <em>le mot juste</em>. Who could forget that? Flaubert seemed heroic. Certain kids considered him weird.</p><p>This, for example, came up while I was writing about the Atchafalaya, the huge river swamp in southern Louisiana, and how it looked from a small plane in the air. Land is growing there as silt arrives from the north. Parts of the swamp are filling in. From the airplane, you could discern where these places were, because, seen through the trees, there would be an interruption of the reflection of sunlight on water. What word or phrase was I going to use for that reflection? I looked up ‚Äúsparkle‚Äù in my old Webster‚Äôs Collegiate. It said: ‚ÄúSee ‚Äòflash.‚Äô‚Äù I looked up ‚Äúflash.‚Äù The definitions were followed by a presentation of synonyms: ‚Äúflash, gleam, glance, glint, sparkle, glitter, scintillate, coruscate, glimmer, shimmer mean to shoot forth light.‚Äù I liked that last part, so I changed the manuscript to say, ‚ÄúThe reflection of the sun races through the trees and shoots forth light from the water.‚Äù</p><p>In the search for words, thesauruses are useful things, but they don‚Äôt talk about the words they list. They are also dangerous. They can lead you to choose a polysyllabic and fuzzy word when a simple and clear one is better. The value of a thesaurus is not to make a writer seem to have a vast vocabulary of recondite words. The value of a thesaurus is in the assistance it can give you in finding the best possible word for the mission that the word is supposed to fulfill. Writing teachers and journalism courses have been known to compare them to crutches and to imply that no writer of any character or competence would use them. At best, thesauruses are mere rest stops in the search for the mot juste. Your destination is the dictionary. Suppose you sense an opportunity beyond the word ‚Äúintention.‚Äù You read the dictionary‚Äôs thesauri an list of synonyms: ‚Äúintention, intent, purpose, design, aim, end, object, objective, goal.‚Äù But the dictionary doesn‚Äôt let it go at that. It goes on to tell you the differences all the way down the line how each listed word differs from all the others. Some dictionaries keep themselves trim by just listing synonyms and not going on to make distinctions. You want the first kind, in which you are not just getting a list of words; you are being told the differences in their hues, as if you were looking at the stripes in an awning, each of a subtly different green. Look up ‚Äúvertical.‚Äù It tells you-believe it or not-that ‚Äúvertical,‚Äù ‚Äúperpendicular,‚Äù and ‚Äúplumb‚Äù differ each from the two others. Ditto ‚Äúplastic, pliable, pliant, ductile, malleable, adaptable.‚Äù Ditto ‚Äúfidelity, allegiance, fealty, loyalty, devotion, piety.‚Äù</p><p>I grew up in canoes on northern lakes and forest rivers. Thirty years later, I was trying to choose a word or words that would explain why anyone in a modern nation would choose to go a long distance by canoe. I was damned if I was going to call it a sport, but nothing else occurred. I looked up ‚Äúsport.‚Äù There were seventeen lines of definition: ‚Äú1. That which diverts, and makes mirth; pastime; diversion. 2. A diversion of the field.‚Äù I stopped there.</p><blockquote><p>His professed criteria were to take it easy, see some wildlife, and travel light with his bark canoes‚Äìnothing more‚Äìand one could not help but lean his way. I had known of people who took collapsible cots, down pillows, chainsaws, outboard motors, cases of beer, and battery-powered portable refrigerators on canoe trips‚Äìeven into deep wilderness. You set your own standards. Travel by canoe is not a necessity, and will nevermore be the most efficient way to get from one region to another, or even from one lake to another‚Äìanywhere. A canoe trip has become simply a rite of oneness with certain terrain, a diversion of the field, an act performed not because it is necessary but because there is value in the act itself.</p></blockquote><p>If your journey is long enough in wild country, you change, albeit temporarily, while you are there. Writing about a river valley in Arctic Alaska, I was trying to describe that mental change, and I was searching for a word that would represent the idea, catalyze the theme. ‚ÄúAssimilate‚Äù came along pretty quickly. But ‚Äúassimilate,‚Äù in the context, was worse than ‚Äúsport.‚Äù So I looked up ‚Äúassimilate‚Äù: ‚Äú1. To make similar or alike. 2. To liken; to compare . 3. To‚Ä¶ incorporate into the substance of the appropriating body.‚Äù</p><blockquote><p>We sat around the campfire for at least another hour. We talked of rain and kestrels, oil and antlers, the height and the headwaters of the river. Neither Hession nor Fedeler once mentioned the bear. When I got into my sleeping bag, though, and closed my eyes, there he was, in color, on the side of the hill. The vision was indelible, but fear was not what put it there. More, it was a sense of souvenir, a sense of sheer luck at having chosen in the first place to follow Fedeler and Hession up the river and into the hills, a memento not so much of one moment as of the entire circuit of the long afternoon. It was a vision of a whole land, with an animal in it. This was his country, clearly enough. To be there was to be incorporated, in however small a measure, into its substance‚Äìhis country, and if you wanted to visit it you had better knock.</p></blockquote><p>I was left, in time that followed, with one huge regret. In three years of Alaska travel, research, and writing, it never occurred to me to wonder why the Arctic was called Arctic. I never thought about it until a few years after the book was published. If only I had looked in the dictionary, I would have incorporated the word‚Äôs origin into the substance of the writing. This is how ‚ÄúArctic‚Äù is defined: ‚ÄúPertaining to, or situated under, the northern constellation called the <em>Bear.</em>‚Äù</p><p>It was William Shawn, the editor of <em>The New Yorker</em> for several decades, who first mentioned to me ‚Äúthe irregular restrictive which.‚Äù Mr. Shawn explained that under certain unusual and special circumstances the word ‚Äúwhich‚Äù could be employed at the head of a restrictive clause. Ordinarily, the conjunction ‚Äúthat‚Äù would introduce a restrictive clause. Nonrestrictive: This is a baseball, which is spherical and white. Restrictive: This is the baseball that Babe Ruth hit out of the park after pointing at the fence in Chicago. The first ball is unspecific, and the sentence requires a comma if the writer wishes to digress into its shape and color. The second ball is very specific, and the sentence repels commas. There can be situations, though, wherein words or phrases lie between the specific object and the clause that proves its specificity, and would call for the irregular restrictive which. Confronting this memory, I cannot say that it kicks old Buddha‚Äôs gong. Yet it has sent me through the entirety of two of my books on a computer search for the irregular restrictive which. In well over a hundred thousand words, I found three:</p><blockquote><p>In 1822, the Belgian stratigrapher J. ]. d‚ÄôOmalius d‚ÄôHalloy, working for the French government, put a name on the chalk of Eu- rope which would come to represent an un- gainly share of geologic time.</p></blockquote><blockquote><p>Oakmont uses a <em>Poa amrua</em> of its own creation which bears few seeds and therefore results in what golfers describe as a ‚Äúless pebbly‚Äù surface.</p></blockquote><blockquote><p>Dominy had risen to become U.S. Com- missioner of Reclamation, the agency in the Department of the Interior which impounds water for as much as two hundred miles be- hind such constructions as Glen Canyon Dam, Grand Coulee Dam, Flaming Gorge Dam, Hoover Dam.</p></blockquote><p>As it happens, those excerpts are not from the Shawn era but are all from pieces published in the twenty-first century. <em>The New Yorker</em>, in other words, has by no means forgotten the irregular restrictive which, or the regular earth from which it springs.</p><p>In the same books, incidentally, I also quoted Thoreau and Leviticus, and may have winced in Shawn‚Äôs honor.</p><blockquote><p>Four hundred yards above the interstate bridge we came to Carthagina Island, stand- ing in a flatwater pool. Thoreau doesn‚Äôt call it by name, but he describes it as ‚Äúa large and densely wooded island‚Ä¶the fairest which we had met with, with a handsome grove of elms at its head.‚Äù</p></blockquote><p>Nothing irregular there, H.D.T. It was the fairest island that you met with.</p><p>Leviticus:</p><blockquote><p>And the Lord spake unto Moses and to Aaron, saying unto them, Speak unto the children of Israel, saying, These are the beasts which ye shall eat among all the beasts that are on the earth.</p></blockquote><p>Actually, Mr. Shawn was just another spear-carrier in the hall of usage and grammar. The dais was occupied for more than half a century by Eleanor Gould, ‚ÄúMiss Gould,‚Äù who was Mrs. Packard, and whose wide reputation seeped down even into the awareness of apprentice writers everywhere. I was scarcely eighteen, and already collecting rejection slips, when I heard or read about a twenty-two-year-old Vassar graduate named Eleanor Gould, who, in 1925, bought a copy of the brand-new <em>New Yorker</em>, read it, and then reread it with a blue pencil in her hand. When she finished, the magazine was a mottled blue on every page‚Äìa circled embarrassment of dangling modifiers, conflicting pronouns, absent commas, and over-all grammatical hash. She mailed the marked-up copy to Harold Ross, the founding editor, and Ross was said to have bellowed. What he bellowed was ‚ÄúFind this bitch and hire her!‚Äù</p><p>In reality, Eleanor Gould was nine years old when Ross invented <em>The New Yorker</em>. She grew up in Ohio, went to Oberlin College, and graduated in 1938. Seven years later, she sought a job at <em>The New Yorker</em>, and in her application she mentioned one or two examples of the sort of help she felt she could provide. For example, something is not different than something else; it is different from something else. It was Shawn, the managing editor, who hired her. There is no compact or simple title for what she did across the following fifty-four years. She was not an editor‚Äìnot, at any rate, on the higher levels of holding writers‚Äô hands. She was not a fact checker, although she would surely mention any fact she looked upon as suspect. What she did was read the magazine in galley proofs and mark up the proofs. Each galley had a <em>New Yorker</em> column running down the middle and enough margin on either side to park a car. She filled the margins with remarks about usage, diction, indirection, word choice, punctuation, ambiguities, and so forth. Her completed product was sent on to the writer‚Äôs editor, who read the marginalia and later brought up selected items with the writer, or just handed the writer the Gould proof, as it was known, and let the writer soak it up. Robert Bingham, who was my principal editor for sixteen years (until brain cancer ended his relatively young life and with it his exceptional capability), always passed the Gould proof along to me, almost always saying, ‚Äú\Then she says ‚ÄòGrammar,‚Äô sit up!‚Äù</p><p>On a highly competitive list, her foremost peeve in factual writing was indirection‚Äìsliding facts in sideways, expecting a reader to gather rather than receive information. You don‚Äôt start off like an atmospheric fictionist: ‚ÄúThe house on Lovers‚Äô Lane was where the lovers loved loving.‚Äù A Gould proof would have asked, ‚ÄúWhat house?‚Äù ‚ÄúWhat lovers?‚Äù ‚ÄúWhere is Lovers‚Äô Lane?‚Äù In short, if you are introducing something, introduce it. Don‚Äôt get artistic with the definite article. If you say ‚Äúa house,‚Äù you are introducing it. If you say ‚Äúthe house,‚Äù the reader knows about it because you mentioned it earlier. Mr. Shawn was influenced by Miss Gould far more than vice versa. He was a bear on indirection.</p><p>Her suggested fixes did not always rise into comparison with invisible mending. Some writers developed reactions in the tantrum range. Nothing, though, was being forced upon the prose. If the writer wished to ignore a salient comment from Miss Gould instead of slapping the forehead and feeling grateful, that was up to the writer. It was the writer‚Äôs signed piece. If the writer preferred warts, warts prevailed. A Gould proof rarely endeavored to influence in any manner the structure or thesis of a piece, and was not meant to. Its purpose, according to Miss Gould, was to help a writer achieve an intent in the clearest possible way. She sat you up, let me tell you. And not only did you not have to accept her suggested fixes but also‚Äìof course‚Äìyou were free to fix the fixes according to the sound of things in your own head.</p><p>The general term for all this‚Äìfrom ‚Äúhouse style‚Äù to a Gould-like proof‚Äìis copy editing. Miss Gould accepted the title ‚Äúgrammarian‚Äù for several decades, but grammar was only the base of things she reacted to as she monitored the magazine. House style was actually dealt with by others before she saw anything. House style is not a reference to the canard that an entire magazine can be made to sound as if it were written by one writer. House style is a mechanical application of things like spelling and italics. In <em>The New Yorker</em>, ‚Äútravelling‚Äù is spelled with two ‚Äúl‚Äùs. Book titles are framed in quotation marks. The names of magazines are italicized, and if the names are in the possessive-<em>TV Guide‚Äôs</em>, <em>National Geographic‚Äôs</em>-the ‚Äús‚Äù is italicized, too. The names of ships are not italicized. It is house style to put the two dots over a second consecutive identical vowel, because the house does not cooperate in deemphasizing diaereses. In articles in the New York <em>Times</em> the name of everybody mentioned is preceded by Mr., Ms., or Mrs. (if not by a lofty title like President, General, Senator, or Cardinal), and, traditionally, if a <em>Times</em> reporter got into a skin boat with an Eskimo in the Chukchi Sea no personal pronoun was ever going to get into that boat. ‚ÄúA visitor‚Äù got into that boat. The Chicago Manual of Style is a quixotic attempt at one-style-fits-all for every house in America-newspapers, magazines, book publishers, blogishers.</p><p>Copy editors attend the flow of the prose and watch for leaks. Whatever else she was called, Eleanor Gould was a copy editor. She was one of several in a developing tradition that became a legacy. For a single closing issue, today‚Äôs copy editors read <em>New Yorker</em> proofs so many times and in so many ways that they variously subtitle their own efforts. The five incumbents call themselves copy editors, page 0 .K.‚Äòers, query proofreaders, and second readers. They all do all of it, and that‚Äôs four job descriptions each for five people‚Äìtwenty functionaries at five desks. They also do what Eleanor Gould did, and to this day when they finish working on a galley proof they say that it has been ‚ÄúGoulded.‚Äù If they live in her shadow, they lengthen it.</p><p>They can be rarefied. Reading a sentence like ‚ÄúShe didn‚Äôt know what happened to the other five people travelling with her,‚Äù they will see that what the writer could mean is that the traveller was one of eleven people on the trip. This is high-alloy nitpicking, yes. But why not? There is elegance in the less ambiguous way. She didn‚Äôt know what happened to the five other people travelling with her.</p><p>To linger in the same thin air, what is the difference between ‚Äúfurther‚Äù and ‚Äúfarther‚Äù? In the dictionary, look up ‚Äúfurther.‚Äù It says ‚Äúfarther.‚Äù Look up ‚Äúfarther.‚Äù It says ‚Äúfurther.‚Äù So you‚Äôre safe and can roll over and sleep. But the distinction has a difference and O.K.‚Äòers know what‚Äôs O.K. ‚ÄúFarther‚Äù refers to measurable distance. ‚ÄúFurther‚Äù is a matter of degree. Will you stop pelting me with derision? That‚Äôs enough out of you. You‚Äôll go no further.</p><p>Getting into an authentic standoff with this multitalented, multifaceted, proofreading, query-proofing, copy-editing, grammar-wielding corps is difficult to do, and in fifty years I have done so twice. One standoff, which shall not be elaborated here, had to do with my flippant use of scholarly parenthetical in text citations (Mourt, 1622) in a piece in which the works cited did not appear on what scholars call the Works Cited List. There was no Works Cited List. The other standoff‚Äìrelated to the issue of February 23, 1987‚Äìhad to do with the possessive of the word Corps, It was the piece about southern Louisiana, the Atchafalaya River, the vast swamp, and the levees, spillways, and navigation locks of the U.S. Army Corps of Engineers. It approached twenty thousand words in length, and, as you can imagine, the word Corps was all over the text like an eruption of measles. Often, the word occurred in the possessive. When I was in the eighth grade, Miss Bartholomew told us that a noun ending in ‚Äús‚Äù could be rendered possessive by an apostrophe alone or by an apostrophe followed by an additional ‚Äús,‚Äù tie goes to the writer. Now, in the Louisiana piece, I had written Corps‚Äô for each and every possessive Corps, and the copy editors said that the possessive of Corps should be printed as Corps‚Äôs. I thought I was in a morgue. I said so. The copy editors phalanxed‚Äìme versus the</p><p>whole department. They said that <em>The New Yorker</em> did not use the naked ‚Äús‚Äù apostrophe except with classical names like Jesus, Aeschylus, and Socrates; and even French names ending in a silent ‚Äús‚Äù were given the apostrophe ‚Äús,‚Äù as in ‚ÄúFran~ois‚Äôs,‚Äù ‚Äú<em>les jeunesses‚Äôs</em>,‚Äù ‚ÄúEpesses‚Äôs‚Äùalso as in‚Äù Amiens‚Äôs hidden cache‚Äù and ‚Äú<em>le fran√ßais‚Äôs</em> frank mustache.‚Äù With regard to Corps‚Äôs, the copy editors were uncharacteristically unbending. I said that if Corps‚Äôs had to be the form printed, I would have to stop all forward motion and rewrite every sentence in which that possessive occurred-in ways that would avoid using it, in ways that would get rid of‚Äù all those corpses.‚Äù fm sure I spluttered about ‚Äúslabsful of recumbents‚Äù and said it would be ‚Äúas if every one of those Corps‚Äôs was wired to a cold toe.‚Äù This threat was not considered persuasive, but eventually it led to someone‚Äô s remarkable suggestion. Why not call the U.S. Army Corps of Engineers and ask what they do when they need to express themselves in the possessive? I hadn‚Äôt known that the Army Corps ofEngineers was steeped in Fowler‚Äôs Modem English Usage or Merriam-Webster‚Äôs unparalleled English Usage or the flexibilities of grammar. How would the Corps write it? Corps‚Äô, said the Corps. Never Corps‚Äôs. Never the geminal ‚Äús‚Äùs.</p><p>Copy editors seldom stray into the realms of others, but when they do, their suggestions and comments are not unwelcome. Mary Norris, who joined <em>The New Yorker</em> in 1978 and has worked on untold numbers of my pieces, is a verbal diagnostician I would tum to for a first, second, or third opinion on just about anything. She doesn‚Äôt mind when friends call her the Pencil Lady. In 2003, we were closing the piece that retraced the journey made in 1839 by Henry David Thoreau and his brother, John, down the Concord River to the Merrimack and up the Merrimack through and beyond Manchester, New Hampshire. In manuscript and in the initial galley proofS, there was a sentence (odd out of context) that said:</p><p>In bed at night for three or four months</p><blockquote><p>I‚Äôd been listening to Manchester laughing-a chorus of Manchesterians sitting on those steps convulsed by us on the way uphill with our canoe.</p></blockquote><p>Mary Norris wrote on the proof, ‚ÄúWould you like ‚ÄòMancunians‚Äô?‚Äù</p><p>It was as if she had handed me a rare gold coin. Five years later, when I happened to be writing about lacrosse in Manchester, England, I worked in the word ‚ÄúMancunian‚Äù three times in one short paragraph. It was the second-best demonym r d ever heard, almost matching Vallisoletano (a citizen of Valladolid). The planet, of course, is covered with demonyms, and after scouring the world in conversations on this topic with Mary Norris I began a severely selective, highly subjective A-list, extending Mancunian and V allisoletano through thirty-five others at this writing, including Wulfrunian (Wolverhampton), Novocastrian (Newcasde), Trifluvian (Trois-Rivi√®res), Leodensian (Leeds), Minneapolitan (Minneapolis), Hartlepudlian (Hartlepool), Liverpudlian (you knew it), Haligonian (Halifax), Varsovian (Warsaw), Providentian (Providence), and Tridentine (Trent).</p><p>One can do worse than pretend to be a copy editor. In my role as my students‚Äô editor, I go through their papers with them privately a comma at a time. Much of what I tell them I have learned by osmosis from those O.K. O.K‚Äôers at <em>The New Yorker</em>, not to mention a range of others, from Miss Bartholomew, of Princeton Junior High SchooL to Carmen Gomezplata, of Farrar, Straus & Giroux. The students, picking up the parlance, sometimes go off and copy-edit their roommates. This has led to disputes, and I have been asked to settle the disputes. My name isn‚Äôt Strunk. I‚Äôm just another editee. But I do what I can, as, for example, after two such people recently got into a squabble over‚Äìimagine this‚Äìthe possessive plural of‚Äù attorney general.‚Äù The question came to me in an e-mail: ‚ÄúIf more than one attorney general possess a number of cars, how would you fill in the blanks (if at all) in the following sentence: ‚Äòthe attorney[ ] general[ ] car[ ] were all parked next to one another‚Äô?‚Äù</p><p>Both Web. II and Random House say flatly that the plural of ‚Äúattorney general‚Äù is both ‚Äúattorneys general‚Äù and ‚Äúattorney generals.‚Äù That being so, I put on my robe, rapped the gavel, and said from the bench, ‚ÄúIf you accept that the two forms are equal, I think you would write attorney generals‚Äô cars and not attorneys general‚Äôs cars-for obvious reasons (a sense of the sight and sound of words has to kick in somewhere or the writer is missing one or two marbles).‚Äù What would I personally do? None of the above. I would refer to ‚Äúthe cars of the attorneys general.‚Äù But that‚Äôs just a matter of choice.</p><p>I work in a fake medieval turret on the roof of a campus building. When I come out and walk around, bumping into friends, they tend to ask me, ‚ÄúWhat are you working on?‚Äù Which is one reason I don‚Äôt often come out and walk around. I always feel like a parrot answering that question, and a nervous ill-humored parrot if I am writing a first draft. A few years ago, I had the luxury of a one-word reply.</p><p>‚ÄúWhat are you working on?‚Äù</p><p>‚ÄúChalk.‚Äù</p><p>‚ÄúChalk?‚Äù</p><p>‚ÄúChalk.‚Äù</p><p>That did it. That seemed to be one more syllable than anyone wished to pursue.</p><p>But when the question comes in a note from one of your own daughters it is wise not to wax monosyllabic. Jenny, for example, was an assistant editor at Alfred A. Knopf when she innocently asked what I was working on, and got this reply:</p><p>‚ÄúDear Jenny: What am I working on? How is it going? Since you asked, at this point I have no confidence in this piece of writing. It tries a number of things I probably shouldn‚Äôt be trying. It tries to use the present tense for the immediacy that the present tense develops, but without allowing any verb tense to become befouled in a double orientation of time. It tells its story inside out. Like the ship fm writing about, it may have a crack in its hull. And I‚Äôve barely started. After four months and nine days of staring into this monitor for what has probably amounted in aggregate to something closely approaching a thousand hours, that‚Äôs enough. I‚Äôm going fishing.‚Äù</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/projects/burglarAlarm</guid><title>burglarAlarm</title><link>https://www.justinpurnell.com/projects/burglarAlarm</link><description><![CDATA[These files detail the breadboard connections you‚Äôll want to use for a 2-sensor burglar alarm with 2 LEDs and a buzzer.]]></description><pubDate>Sun, 22 Jul 2007 20:00:00 -0400</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[project]]></category><category><![CDATA[burglar alarm]]></category><category><![CDATA[python]]></category><category><![CDATA[pico]]></category><content:encoded><![CDATA[<p>These files detail the breadboard connections you‚Äôll want to use for a 2-sensor burglar alarm with 2 LEDs and a buzzer.</p><p>The final file is micropython code you can copy and paste that will work with the connections seen in the html or pdf file.</p><p>If your pins change from how they‚Äôre listed in the diagrams, you‚Äôll want to adjust the code to reflect which pins you‚Äôre using.</p><ul><li><a href="https://www.justinpurnell.com/projects/burglarAlarm/burglar.htm">Burglar Alarm Diagram - HTML</a></li><li><a href="https://www.justinpurnell.com/projects/burglarAlarm/burglar.pdf">Burglar Alarm Diagram - PDF</a></li><li><a href="https://www.justinpurnell.com/projects/burglarAlarm/burglarAlarm.py">Burglar Alarm Code - Python</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/about/about-Justin</guid><title>about-Justin</title><link>https://www.justinpurnell.com/about/about-Justin</link><description><![CDATA[Justin Purnell is Head of Product for Hotels at Home, Inc. Prior to this role, Justin served as Vice President in Strategy and Business Development for NBCUniversal Digital Enterprises after launching Seeso, NBCU‚Äôs Subscription Video on Demand service as Director of Content Strategy and Operations. Justin also directed Amy Poehler‚Äôs web series ‚ÄúSmart Girls at the Party,‚Äù a web series for ON Networks targeted towards building self-esteem in early adolescent girls. Justin worked at Goldman Sachs for seven years, where he published over 400 pieces of written research as a high yield credit analyst in the Energy and Gaming, Lodging, and Leisure industries.]]></description><pubDate>Sun, 22 Jul 2007 20:00:00 -0400</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[Justin Purnell]]></category><category><![CDATA[about]]></category><content:encoded><![CDATA[<p>Justin Purnell is Head of Product for Hotels at Home, Inc. Prior to this role, Justin served as Vice President in Strategy and Business Development for NBCUniversal Digital Enterprises after launching Seeso, NBCU‚Äôs Subscription Video on Demand service as Director of Content Strategy and Operations. Justin also directed Amy Poehler‚Äôs web series ‚ÄúSmart Girls at the Party,‚Äù a web series for ON Networks targeted towards building self-esteem in early adolescent girls. Justin worked at Goldman Sachs for seven years, where he published over 400 pieces of written research as a high yield credit analyst in the Energy and Gaming, Lodging, and Leisure industries.</p><p>Justin earned an MBA at the Tuck School of Business at Dartmouth and is Co-President of the Tuck Club of New York. President of the Class of 2000, he graduated from Princeton University with an A.B. in Economics and certificates in Finance and Political Philosophy. Justin has been Secretary of St. Albans‚Äô Great(est?) Class of 1996 since their graduation, is an original Headmaster‚Äôs Counselor, and is a co-lead of the school‚Äôs Black Alumni Alliance.</p>]]></content:encoded></item></channel></rss>