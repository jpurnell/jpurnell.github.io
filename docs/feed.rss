<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Justin Purnell</title><description></description><link>https://www.justinpurnell.com</link><atom:link
    href="https://www.justinpurnell.com/feed.rss"
    rel="self" type="application/rss+xml"
/><language>en</language><generator>Ignite v0.2.1</generator><image><url>/images/logos/rss.png</url><title>Justin Purnell</title><link>https://www.justinpurnell.com</link><width>144</width><height>152</height></image><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-05/04-thu-bond-valuation</guid><title>Bond Valuation & Credit Analysis</title><link>https://www.justinpurnell.com/BusinessMath/week-05/04-thu-bond-valuation</link><description><![CDATA[Part 19 of 12-Week BusinessMath Series]]></description><pubDate>Fri, 06 Feb 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[bonds]]></category><category><![CDATA[fixed-income]]></category><category><![CDATA[credit-risk]]></category><category><![CDATA[duration]]></category><category><![CDATA[convexity]]></category><category><![CDATA[callable-bonds]]></category><category><![CDATA[oas]]></category><content:encoded><![CDATA[<p><strong>Part 19 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>Pricing bonds and calculating yield to maturity (YTM)</li><li>Measuring interest rate risk using duration and convexity</li><li>Converting credit metrics (Z-Scores) to default probabilities and spreads</li><li>Valuing callable bonds and calculating Option-Adjusted Spread (OAS)</li><li>Building credit curves to analyze default risk over time</li><li>Calculating expected losses for bond portfolios</li><li>Making informed fixed income investment decisions</li></ul><hr /><h2>The Problem</h2><p>Bond markets dwarf equity markets ($100T+ globally), yet bond valuation is surprisingly complex:</p><ul><li><strong>How do you price a bond?</strong> It‚Äôs not just ‚Äúdivide coupon by yield‚Äù‚Äîthat‚Äôs current yield, not price.</li><li><strong>What‚Äôs the interest rate risk?</strong> If rates rise 1%, how much does your bond portfolio lose?</li><li><strong>How do you value credit risk?</strong> A BBB-rated bond should yield more than AAA, but how much?</li><li><strong>What about callable bonds?</strong> Issuers can refinance if rates drop‚Äîhow do you value that option?</li></ul><p><strong>Manual bond analysis in spreadsheets is tedious when managing portfolios with hundreds of positions.</strong></p><hr /><h2>The Solution</h2><p>BusinessMath provides comprehensive bond valuation and credit analysis: <code>Bond</code> pricing, duration/convexity calculation, credit spread modeling, callable bond valuation with OAS, and credit curve construction.</p><h3>Basic Bond Pricing</h3><p>Price a simple corporate bond:</p><pre><code class="language-swift">import BusinessMath
import Foundation

// 5-year corporate bond
// - Face value: $1,000
// - Annual coupon: 6%
// - Semiannual payments
// - Current market yield: 5%

let calendar = Calendar.current
let today = Date()
let maturity = calendar.date(byAdding: .year, value: 5, to: today)!

let bond = Bond(
    faceValue: 1000.0,
    couponRate: 0.06,
    maturityDate: maturity,
    paymentFrequency: .semiAnnual,
    issueDate: today
)

let marketPrice = bond.price(yield: 0.05, asOf: today)

print("Bond Pricing")
print("============")
print("Face Value: $1,000")
print("Coupon Rate: 6.0%")
print("Market Yield: 5.0%")
print("Price: \(marketPrice.currency(2))")

let currentYield = bond.currentYield(price: marketPrice)
print("Current Yield: \(currentYield.percent(2))")
</code></pre><p><strong>Output:</strong></p><pre><code>Bond Pricing
============
Face Value: $1,000
Coupon Rate: 6.0%
Market Yield: 5.0%
Price: $1,043.82

Current Yield: 5.75%
</code></pre><p><strong>The pricing rule</strong>: When coupon > yield, bond trades at <strong>premium</strong> (> $1,000). When yield > coupon, trades at <strong>discount</strong> (< $1,000). This is the inverse price-yield relationship.</p><hr /><h3>Yield to Maturity (YTM)</h3><p>Given a market price, solve for the internal rate of return:</p><pre><code class="language-swift">// Find YTM given observed market price

let observedPrice = 980.00  // Trading below par

do {
    let ytm = try bond.yieldToMaturity(price: observedPrice, asOf: today)

    print("\nYield to Maturity Analysis")
    print("===========================")
    print("Market Price: \(observedPrice.currency())")
    print("YTM: \(ytm.percent(2))")

    // Verify round-trip: Price ‚Üí YTM ‚Üí Price
    let verifyPrice = bond.price(yield: ytm, asOf: today)
    print("Verification: \(verifyPrice.currency(2))")
    print("Difference: \(abs(verifyPrice - observedPrice).currency(2))")

} catch {
    print("YTM calculation failed: \(error)")
}
</code></pre><p><strong>Output:</strong></p><pre><code>Yield to Maturity Analysis
===========================
Market Price: $980.00
YTM: 6.48%

Verification: $980.00
Difference: $0.00
</code></pre><p><strong>The definition</strong>: YTM is the <strong>total return</strong> if you buy at current price, hold to maturity, and reinvest all coupons at the YTM rate. It‚Äôs the bond‚Äôs IRR.</p><hr /><h3>Duration and Convexity</h3><p>Measure interest rate risk:</p><pre><code class="language-swift">let yield = 0.05

let macaulayDuration = bond.macaulayDuration(yield: yield, asOf: today)
let modifiedDuration = bond.modifiedDuration(yield: yield, asOf: today)
let convexity = bond.convexity(yield: yield, asOf: today)

print("\nInterest Rate Risk Metrics")
print("==========================")
print("Macaulay Duration: \(macaulayDuration.number(2)) years")
print("Modified Duration: \(modifiedDuration.number(2))")
print("Convexity: \(convexity.number(2))")

// Estimate price change from 1% yield increase
let yieldChange = 0.01  // 100 bps
let priceChange = -modifiedDuration * yieldChange

print("\nIf yield increases by 100 bps:")
print("Duration estimate: \(priceChange.percent(2))")

// More accurate estimate with convexity
let convexityAdj = 0.5 * convexity * yieldChange * yieldChange
let improvedEstimate = priceChange + convexityAdj

print("With convexity adjustment: \(improvedEstimate.percent(2))")

// Actual price change
let newPrice = bond.price(yield: yield + yieldChange, asOf: today)
let originalPrice = bond.price(yield: yield, asOf: today)
let actualChange = ((newPrice / originalPrice) - 1.0)

print("Actual change: \(actualChange.percent(2))")
</code></pre><p><strong>Output:</strong></p><pre><code>Interest Rate Risk Metrics
==========================
Macaulay Duration: 4.41 years
Modified Duration: 4.30
Convexity: 22.07

If yield increases by 100 bps:
Duration estimate: -4.30%
With convexity adjustment: -4.19%
Actual change: -4.19%
</code></pre><p><strong>The interpretation</strong>:</p><ul><li><strong>Macaulay Duration (4.41 years)</strong>: Weighted average time to receive cash flows</li><li><strong>Modified Duration (4.30)</strong>: Price sensitivity‚Äîa 1% yield increase causes ~4.3% price drop</li><li><strong>Convexity (22.07)</strong>: Curvature‚Äîimproves duration estimate for large yield changes</li></ul><p><strong>The insight</strong>: <strong>Duration</strong> is a linear approximation. <strong>Convexity</strong> captures the curve. Together, they predict price changes accurately.</p><hr /><h3>Credit Risk Analysis</h3><p>Convert company fundamentals to bond pricing:</p><pre><code class="language-swift">// Step 1: Start with credit metrics (Altman Z-Score)
let zScore = 2.3  // Grey zone (moderate credit risk)

// Step 2: Convert Z-Score to default probability
let creditModel = CreditSpreadModel<Double>()
let defaultProbability = creditModel.defaultProbability(zScore: zScore)

print("\nCredit Risk Analysis")
print("====================")
print("Z-Score: \(zScore.number(2))")
print("Default Probability: \(defaultProbability.percent(2))")

// Step 3: Determine recovery rate by seniority
let seniority = Seniority.seniorUnsecured
let recoveryRate = RecoveryModel<Double>.standardRecoveryRate(seniority: seniority)

print("Seniority: Senior Unsecured")
print("Expected Recovery: \(recoveryRate.percent(0))")

// Step 4: Calculate credit spread
let creditSpread = creditModel.creditSpread(
    defaultProbability: defaultProbability,
    recoveryRate: recoveryRate,
    maturity: 5.0
)

print("Credit Spread: \((creditSpread * 10000).number(0)) bps")

// Step 5: Price the bond
let riskFreeRate = 0.03  // 3% Treasury yield
let corporateYield = riskFreeRate + creditSpread

let corporateBond = Bond(
    faceValue: 1000.0,
    couponRate: 0.05,
    maturityDate: maturity,
    paymentFrequency: .semiAnnual,
    issueDate: today
)

let corporatePrice = corporateBond.price(yield: corporateYield, asOf: today)

print("\nCorporate Bond Pricing:")
print("Risk-Free Rate: \(riskFreeRate.percent(2))")
print("Corporate Yield: \(corporateYield.percent(2))")
print("Bond Price: \(corporatePrice.currency(2))")
</code></pre><p><strong>Output:</strong></p><pre><code>Credit Risk Analysis
====================
Z-Score: 2.30
Default Probability: 3.92%
Seniority: Senior Unsecured
Expected Recovery: 50%
Credit Spread: 206 bps

Corporate Bond Pricing:
Risk-Free Rate: 3.00%
Corporate Yield: 5.06%
Bond Price: $997.39
</code></pre><p><strong>The workflow</strong>: <strong>Z-Score ‚Üí Default Probability ‚Üí Credit Spread ‚Üí Bond Yield ‚Üí Bond Price</strong></p><p><strong>The formula</strong>: Credit Spread ‚âà (Default Probability √ó Loss Given Default) / (1 - Default Probability)</p><hr /><h3>Credit Deterioration Impact</h3><p>See how credit quality affects bond values:</p><pre><code class="language-swift">print("\nCredit Deterioration Impact")
print("===========================")

let scenarios = [
    (name: "Investment Grade", zScore: 3.5),
    (name: "Grey Zone", zScore: 2.0),
    (name: "Distress", zScore: 1.0)
]

print("\nScenario           | Z-Score | PD     | Spread | Price")
print("-------------------|---------|--------|--------|--------")

for scenario in scenarios {
    let pd = creditModel.defaultProbability(zScore: scenario.zScore)
    let spread = creditModel.creditSpread(
        defaultProbability: pd,
        recoveryRate: recoveryRate,
        maturity: 5.0
    )
    let yld = riskFreeRate + spread
    let price = corporateBond.price(yield: yld, asOf: today)

    print("\(scenario.name.padding(toLength: 18, withPad: " ", startingAt: 0)) | \(scenario.zScore.number(1))     | \(pd.percent(1)) | \((spread * 10000).number(0)) bps | \(price.currency(2))")
}
</code></pre><p><strong>Output:</strong></p><pre><code>Credit Deterioration Impact
===========================

Scenario           | Z-Score | PD     | Spread     | Price
-------------------|---------|--------|------------|----------
Investment Grade   |     3.5 |   0.0% |      2 bps | $1,091.44
Grey Zone          |     2.0 |  11.9% |    708 bps |   $804.45
Distress           |     1.0 |  88.1% | 18,421 bps |    $28.14
</code></pre><p><strong>The pattern</strong>: As credit deteriorates (lower Z-Score), default probability rises, spreads widen, and bond prices fall. The relationship is <strong>non-linear</strong>‚Äîdistressed bonds see massive spread widening.</p><hr /><h3>Callable Bonds and OAS</h3><p>Value bonds with embedded call options:</p><pre><code class="language-swift">// High-coupon callable bond (issuer can refinance)

let highCouponBond = Bond(
    faceValue: 1000.0,
    couponRate: 0.07,  // 7% coupon (above market)
    maturityDate: calendar.date(byAdding: .year, value: 10, to: today)!,
    paymentFrequency: .semiAnnual,
    issueDate: today
)

// Callable after 3 years at $1,040 (4% premium)
let callDate = calendar.date(byAdding: .year, value: 3, to: today)!
let callSchedule = [CallProvision(date: callDate, callPrice: 1040.0)]

let callableBond = CallableBond(
    bond: highCouponBond,
    callSchedule: callSchedule
)

let volatility = 0.15  // 15% interest rate volatility

// Step 1: Price non-callable bond
let straightYield = riskFreeRate + creditSpread
let straightPrice = highCouponBond.price(yield: straightYield, asOf: today)

// Step 2: Price callable bond
let callablePrice = callableBond.price(
    riskFreeRate: riskFreeRate,
    spread: creditSpread,
    volatility: volatility,
    asOf: today
)

// Step 3: Calculate embedded option value
let callOptionValue = callableBond.callOptionValue(
    riskFreeRate: riskFreeRate,
    spread: creditSpread,
    volatility: volatility,
    asOf: today
)

print("\nCallable Bond Analysis")
print("======================")
print("Non-Callable Price: \(straightPrice.currency(2))")
print("Callable Price: \(callablePrice.currency(2))")
print("Call Option Value: \(callOptionValue.currency(2))")
print("Investor gives up: \((straightPrice - callablePrice).currency(2))")

// Step 4: Calculate Option-Adjusted Spread (OAS)
do {
    let oas = try callableBond.optionAdjustedSpread(
        marketPrice: callablePrice,
        riskFreeRate: riskFreeRate,
        volatility: volatility,
        asOf: today
    )

    print("\nSpread Decomposition:")
    print("Nominal Spread: \((creditSpread * 10000).number(0)) bps")
    print("OAS (credit only): \((oas * 10000).number(0)) bps")
    print("Option Spread: \(((creditSpread - oas) * 10000).number(0)) bps")

} catch {
    print("OAS calculation failed: \(error)")
}

// Step 5: Effective duration (accounts for call option)
let effectiveDuration = callableBond.effectiveDuration(
    riskFreeRate: riskFreeRate,
    spread: creditSpread,
    volatility: volatility,
    asOf: today
)

let straightDuration = highCouponBond.macaulayDuration(yield: straightYield, asOf: today)

print("\nDuration Comparison:")
print("Non-Callable Duration: \(straightDuration.number(2)) years")
print("Effective Duration: \(effectiveDuration.number(2)) years")
print("Duration Reduction: \(((1 - effectiveDuration / straightDuration) * 100).number(0))%")
</code></pre><p><strong>Output:</strong></p><pre><code>Callable Bond Analysis
======================
Non-Callable Price: $1,150.82
Callable Price: $1,048.51
Call Option Value: $102.31
Investor gives up: $102.31

Spread Decomposition:
Nominal Spread: 206 bps
OAS (credit only): 206 bps
Option Spread: 0 bps

Duration Comparison:
Non-Callable Duration: 7.56 years
Effective Duration: 1.80 years
Duration Reduction: 76%
</code></pre><p><strong>The callable bond mechanics</strong>:</p><ol><li><strong>Callable price < Non-callable price</strong>: Investor compensates issuer for refinancing option</li><li><strong>OAS isolates credit risk</strong>: Strips out option risk for apples-to-apples comparison</li><li><strong>Effective duration < Macaulay duration</strong>: Call option limits price appreciation when rates fall (<strong>negative convexity</strong>)</li></ol><p><strong>The insight</strong>: Callable bonds exhibit <strong>negative convexity</strong>‚Äîwhen rates fall, price gains are capped at the call price.</p><hr /><h3>Credit Curves</h3><p>Build term structures of credit spreads:</p><pre><code class="language-swift">// Credit curve from market observations

let periods = [
    Period.year(1),
    Period.year(3),
    Period.year(5),
    Period.year(10)
]

// Observed spreads (typically upward sloping)
let marketSpreads = TimeSeries(
    periods: periods,
    values: [0.005, 0.012, 0.018, 0.025]  // 50, 120, 180, 250 bps
)

let creditCurve = CreditCurve(
    spreads: marketSpreads,
    recoveryRate: recoveryRate
)

print("\nCredit Curve Analysis")
print("=====================")

// Interpolate spreads
for years in [2.0, 7.0] {
    let spread = creditCurve.spread(maturity: years)
    print("\(years.number(0))-Year Spread: \((spread * 10000).number(0)) bps")
}

// Cumulative default probabilities
print("\nCumulative Default Probabilities:")
for year in [1, 3, 5, 10] {
    let cdp = creditCurve.cumulativeDefaultProbability(maturity: Double(year))
    let survival = 1.0 - cdp
    print("\(year)-Year: \(cdp.percent(2)) default, \(survival.percent(2)) survival")
}

// Hazard rates (forward default intensities)
print("\nHazard Rates (Default Intensity):")
for year in [1, 5, 10] {
    let hazard = creditCurve.hazardRate(maturity: Double(year))
    print("\(year)-Year: \(hazard.percent(2)) per year")
}
</code></pre><p><strong>Output:</strong></p><pre><code>Credit Curve Analysis
=====================
2-Year Spread: 85 bps
7-Year Spread: 208 bps

Cumulative Default Probabilities:
1-Year: 1.00% default, 99.00% survival
3-Year: 6.95% default, 93.05% survival
5-Year: 16.47% default, 83.53% survival
10-Year: 39.35% default, 60.65% survival

Hazard Rates (Default Intensity):
1-Year: 1.00% per year
5-Year: 3.60% per year
10-Year: 5.00% per year
</code></pre><p><strong>The credit curve</strong>: Shows how default risk evolves over time. <strong>Upward-sloping</strong> curves indicate increasing uncertainty at longer horizons.</p><p><strong>Hazard rate</strong>: Instantaneous default intensity‚Äîuseful for pricing credit derivatives like CDSs.</p><hr /><h2>Try It Yourself</h2><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath
import Foundation


// MARK: - Basic Bond Pricing

// 5-year corporate bond
// - Face value: $1,000
// - Annual coupon: 6%
// - Semiannual payments
// - Current market yield: 5%

let calendar = Calendar.current
let today = Date()
let maturity = calendar.date(byAdding: .year, value: 5, to: today)!

let bond = Bond(
	faceValue: 1000.0,
	couponRate: 0.06,
	maturityDate: maturity,
	paymentFrequency: .semiAnnual,
	issueDate: today
)

let marketPrice = bond.price(yield: 0.05, asOf: today)

print("Bond Pricing")
print("============")
print("Face Value: $1,000")
print("Coupon Rate: 6.0%")
print("Market Yield: 5.0%")
print("Price: \(marketPrice.currency(2))")

let currentYield = bond.currentYield(price: marketPrice)
print("Current Yield: \(currentYield.percent(2))")

// MARK: - Yield to Maturity

// Find YTM given observed market price

let observedPrice = 980.00  // Trading below par

do {
	let ytm = try bond.yieldToMaturity(price: observedPrice, asOf: today)

	print("\nYield to Maturity Analysis")
	print("===========================")
	print("Market Price: \(observedPrice.currency())")
	print("YTM: \(ytm.percent(2))")

	// Verify round-trip: Price ‚Üí YTM ‚Üí Price
	let verifyPrice = bond.price(yield: ytm, asOf: today)
	print("Verification: \(verifyPrice.currency(2))")
	print("Difference: \(abs(verifyPrice - observedPrice).currency(2))")

} catch {
	print("YTM calculation failed: \(error)")
}

// MARK: - Duration and Convexity

let yield = 0.05

let macaulayDuration = bond.macaulayDuration(yield: yield, asOf: today)
let modifiedDuration = bond.modifiedDuration(yield: yield, asOf: today)
let convexity = bond.convexity(yield: yield, asOf: today)

print("\nInterest Rate Risk Metrics")
print("==========================")
print("Macaulay Duration: \(macaulayDuration.number(2)) years")
print("Modified Duration: \(modifiedDuration.number(2))")
print("Convexity: \(convexity.number(2))")

// Estimate price change from 1% yield increase
let yieldChange = 0.01  // 100 bps
let priceChange = -modifiedDuration * yieldChange

print("\nIf yield increases by 100 bps:")
print("Duration estimate: \(priceChange.percent(2))")

// More accurate estimate with convexity
let convexityAdj = 0.5 * convexity * yieldChange * yieldChange
let improvedEstimate = priceChange + convexityAdj

print("With convexity adjustment: \(improvedEstimate.percent(2))")

// Actual price change
let newPrice = bond.price(yield: yield + yieldChange, asOf: today)
let originalPrice = bond.price(yield: yield, asOf: today)
let actualChange = ((newPrice / originalPrice) - 1.0)

print("Actual change: \(actualChange.percent(2))")

// MARK: - Credit Risk Analysis

// Step 1: Start with credit metrics (Altman Z-Score)
let zScore = 2.3  // Grey zone (moderate credit risk)

// Step 2: Convert Z-Score to default probability
let creditModel = CreditSpreadModel<Double>()
let defaultProbability = creditModel.defaultProbability(zScore: zScore)

print("\nCredit Risk Analysis")
print("====================")
print("Z-Score: \(zScore.number(2))")
print("Default Probability: \(defaultProbability.percent(2))")

// Step 3: Determine recovery rate by seniority
let seniority = Seniority.seniorUnsecured
let recoveryRate = RecoveryModel<Double>.standardRecoveryRate(seniority: seniority)

print("Seniority: Senior Unsecured")
print("Expected Recovery: \(recoveryRate.percent(0))")

// Step 4: Calculate credit spread
let creditSpread = creditModel.creditSpread(
	defaultProbability: defaultProbability,
	recoveryRate: recoveryRate,
	maturity: 5.0
)

print("Credit Spread: \((creditSpread * 10000).number(0)) bps")

// Step 5: Price the bond
let riskFreeRate = 0.03  // 3% Treasury yield
let corporateYield = riskFreeRate + creditSpread

let corporateBond = Bond(
	faceValue: 1000.0,
	couponRate: 0.05,
	maturityDate: maturity,
	paymentFrequency: .semiAnnual,
	issueDate: today
)

let corporatePrice = corporateBond.price(yield: corporateYield, asOf: today)

print("\nCorporate Bond Pricing:")
print("Risk-Free Rate: \(riskFreeRate.percent(2))")
print("Corporate Yield: \(corporateYield.percent(2))")
print("Bond Price: \(corporatePrice.currency(2))")


// MARK: - Credit Deterioration Impact

print("\nCredit Deterioration Impact")
print("===========================")

let scenarios = [
	(name: "Investment Grade", zScore: 3.5),
	(name: "Grey Zone", zScore: 2.0),
	(name: "Distress", zScore: 1.0)
]

print("\nScenario           | Z-Score | PD     | Spread     | Price")
print("-------------------|---------|--------|------------|----------")

for scenario in scenarios {
	let pd = creditModel.defaultProbability(zScore: scenario.zScore)
	let spread = creditModel.creditSpread(
		defaultProbability: pd,
		recoveryRate: recoveryRate,
		maturity: 5.0
	)
	let yld = riskFreeRate + spread
	let price = corporateBond.price(yield: yld, asOf: today)

	print("\(scenario.name.padding(toLength: 18, withPad: " ", startingAt: 0)) | \(scenario.zScore.number(1).paddingLeft(toLength: 7)) | \(pd.percent(1).paddingLeft(toLength: 6)) | \((spread * 10000).number(0).paddingLeft(toLength: 6)) bps | \(price.currency(2).paddingLeft(toLength: 9))")
}

// MARK: - Callable Bonds and OAS

	// High-coupon callable bond (issuer can refinance)

	let highCouponBond = Bond(
		faceValue: 1000.0,
		couponRate: 0.07,  // 7% coupon (above market)
		maturityDate: calendar.date(byAdding: .year, value: 10, to: today)!,
		paymentFrequency: .semiAnnual,
		issueDate: today
	)

	// Callable after 3 years at $1,040 (4% premium)
	let callDate = calendar.date(byAdding: .year, value: 3, to: today)!
	let callSchedule = [CallProvision(date: callDate, callPrice: 1040.0)]

	let callableBond = CallableBond(
		bond: highCouponBond,
		callSchedule: callSchedule
	)

	let volatility = 0.15  // 15% interest rate volatility

	// Step 1: Price non-callable bond
	let straightYield = riskFreeRate + creditSpread
	let straightPrice = highCouponBond.price(yield: straightYield, asOf: today)

	// Step 2: Price callable bond
	let callablePrice = callableBond.price(
		riskFreeRate: riskFreeRate,
		spread: creditSpread,
		volatility: volatility,
		asOf: today
	)

	// Step 3: Calculate embedded option value
	let callOptionValue = callableBond.callOptionValue(
		riskFreeRate: riskFreeRate,
		spread: creditSpread,
		volatility: volatility,
		asOf: today
	)

	print("\nCallable Bond Analysis")
	print("======================")
	print("Non-Callable Price: \(straightPrice.currency(2))")
	print("Callable Price: \(callablePrice.currency(2))")
	print("Call Option Value: \(callOptionValue.currency(2))")
	print("Investor gives up: \((straightPrice - callablePrice).currency(2))")

	// Step 4: Calculate Option-Adjusted Spread (OAS)
	do {
		let oas = try callableBond.optionAdjustedSpread(
			marketPrice: callablePrice,
			riskFreeRate: riskFreeRate,
			volatility: volatility,
			asOf: today
		)

		print("\nSpread Decomposition:")
		print("Nominal Spread: \((creditSpread * 10000).number(0)) bps")
		print("OAS (credit only): \((oas * 10000).number(0)) bps")
		print("Option Spread: \(((creditSpread - oas) * 10000).number(0)) bps")

	} catch {
		print("OAS calculation failed: \(error)")
	}

	// Step 5: Effective duration (accounts for call option)
	let effectiveDuration = callableBond.effectiveDuration(
		riskFreeRate: riskFreeRate,
		spread: creditSpread,
		volatility: volatility,
		asOf: today
	)

	let straightDuration = highCouponBond.macaulayDuration(yield: straightYield, asOf: today)

	print("\nDuration Comparison:")
	print("Non-Callable Duration: \(straightDuration.number(2)) years")
	print("Effective Duration: \(effectiveDuration.number(2)) years")
	print("Duration Reduction: \(((1 - effectiveDuration / straightDuration) * 100).number(0))%")


// MARK: - Credit Curves

	// Credit curve from market observations

	let periods = [
		Period.year(1),
		Period.year(3),
		Period.year(5),
		Period.year(10)
	]

	// Observed spreads (typically upward sloping)
	let marketSpreads = TimeSeries(
		periods: periods,
		values: [0.005, 0.012, 0.018, 0.025]  // 50, 120, 180, 250 bps
	)

	let creditCurve = CreditCurve(
		spreads: marketSpreads,
		recoveryRate: recoveryRate
	)

	print("\nCredit Curve Analysis")
	print("=====================")

	// Interpolate spreads
	for years in [2.0, 7.0] {
		let spread = creditCurve.spread(maturity: years)
		print("\(years.number(0))-Year Spread: \((spread * 10000).number(0)) bps")
	}

	// Cumulative default probabilities
	print("\nCumulative Default Probabilities:")
	for year in [1, 3, 5, 10] {
		let cdp = creditCurve.cumulativeDefaultProbability(maturity: Double(year))
		let survival = 1.0 - cdp
		print("\(year)-Year: \(cdp.percent(2)) default, \(survival.percent(2)) survival")
	}

	// Hazard rates (forward default intensities)
	print("\nHazard Rates (Default Intensity):")
	for year in [1, 5, 10] {
		let hazard = creditCurve.hazardRate(maturity: Double(year))
		print("\(year)-Year: \(hazard.percent(2)) per year")
	}

</code></pre></details>
<p>‚Üí Full API Reference: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/3.10-BondValuationGuide.md">BusinessMath Docs ‚Äì 3.10 Bond Valuation</a></p><p><strong>Modifications to try</strong>:</p><ol><li>Price corporate bonds across the credit spectrum (AAA to CCC)</li><li>Calculate portfolio duration for a bond ladder</li><li>Model callable bond strategies in different rate environments</li><li>Build credit curves for multiple issuers</li></ol><hr /><h2>Real-World Application</h2><p>Fixed income is the <strong>largest asset class</strong> globally:</p><ul><li><strong>Pension funds</strong>: Managing $100B+ bond portfolios</li><li><strong>Insurance companies</strong>: Asset-liability matching with bonds</li><li><strong>Central banks</strong>: Setting monetary policy via bond markets</li><li><strong>Corporates</strong>: Issuing bonds to finance operations</li></ul><p><strong>Portfolio manager use case</strong>: ‚ÄúWe hold $5B in corporate bonds. Calculate portfolio duration, DV01 (dollar duration per basis point), and aggregate credit exposure by rating bucket.‚Äù</p><p>BusinessMath makes this analysis programmatic, real-time, and portfolio-wide.</p><hr /><p><code>‚òÖ Insight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><p><strong>Why Do Bonds Have Inverse Price-Yield Relationship?</strong></p><p>It‚Äôs counter-intuitive: when yields rise, bond prices <strong>fall</strong>. Why?</p><p><strong>The mechanism</strong>: A bond is a stream of fixed cash flows. When yields rise:</p><ul><li>New bonds issue with higher coupons</li><li>Your old bond (with lower coupon) is less attractive</li><li>To compete, your bond must trade at a <strong>discount</strong></li></ul><p><strong>Example</strong>:</p><ul><li>You buy a 5% coupon bond for $1,000 (yield = 5%)</li><li>Rates rise, new bonds pay 6% coupons</li><li>Your 5% bond must drop to ~$957 so its <strong>yield</strong> rises to 6%</li></ul><p><strong>The math</strong>: Bond price = PV(future coupons + principal). When discount rate (yield) increases, PV decreases.</p><p><strong>The lesson</strong>: <strong>Duration measures this price sensitivity</strong>. Higher duration = greater price volatility when yields change.</p><p><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><hr /><h3>üìù Development Note</h3><p>The most challenging implementation was <strong>callable bond pricing with binomial trees</strong>. We had to:</p><ol><li>Build interest rate trees with specified volatility</li><li>Implement backward induction (value at maturity, work backward)</li><li>Check at each node: Is bond callable? If yes, value = min(continuation value, call price)</li><li>Calculate OAS by iterating to find spread that matches market price</li></ol><p><strong>Trade-off</strong>: Binomial trees are slower than closed-form solutions but handle path-dependent options (callable, putable, convertible bonds).</p><p>We chose <strong>accuracy over speed</strong>‚Äîbond portfolios are repriced daily, not millisecond-by-millisecond.</p><p><strong>Related Methodology</strong>: <a href="../week-01/02-tue-test-first-development">Test-First Development</a> (Week 1) - We wrote tests comparing our binomial tree to Bloomberg‚Äôs pricing for callable bonds before implementation.</p><hr /><h2>Next Steps</h2><p><strong>Coming up next week</strong>: Week 6 explores Monte Carlo simulation and scenario analysis for risk modeling.</p><p><strong>Monday</strong>: Monte Carlo Basics - Building stochastic models for forecasting under uncertainty.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 5/12</li><li>Posts Published: 19/~48</li><li>Topics Covered: Foundation + Analysis + Operational + Financial Statements + <strong>Advanced Modeling (complete)</strong></li><li>Playgrounds: 18 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-05/03-wed-equity-valuation</guid><title>Equity Valuation: From Dividends to Residual Income</title><link>https://www.justinpurnell.com/BusinessMath/week-05/03-wed-equity-valuation</link><description><![CDATA[Part 18 of 12-Week BusinessMath Series]]></description><pubDate>Thu, 05 Feb 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[equity-valuation]]></category><category><![CDATA[ddm]]></category><category><![CDATA[fcfe]]></category><category><![CDATA[residual-income]]></category><category><![CDATA[stock-valuation]]></category><content:encoded><![CDATA[<p><strong>Part 18 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>Valuing dividend-paying stocks with Gordon Growth Model</li><li>Using two-stage and H-models for growth transitions</li><li>Applying Free Cash Flow to Equity (FCFE) for non-dividend payers</li><li>Bridging from Enterprise Value to Equity Value</li><li>Using Residual Income Models for financial institutions</li><li>Comparing valuations across multiple methods</li><li>Triangulating to a fair value range</li></ul><hr /><h2>The Problem</h2><p>Stock valuation is both art and science. <strong>How much is a share of Apple worth? Tesla? Your local bank?</strong> Getting it wrong is expensive:</p><ul><li><strong>Which model should you use?</strong> Dividends? Cash flows? Book value?</li><li><strong>How do you value growth companies that don‚Äôt pay dividends?</strong> Traditional dividend models don‚Äôt work.</li><li><strong>What about companies transitioning from high growth to maturity?</strong> Single-stage models are too simplistic.</li><li><strong>How do you handle complex capital structures?</strong> Debt, preferred stock, minority interests‚Ä¶</li></ul><p><strong>Spreadsheet valuation is tedious and error-prone when modeling multiple scenarios and methods.</strong></p><hr /><h2>The Solution</h2><p>BusinessMath provides five complementary equity valuation approaches: Gordon Growth DDM, Two-Stage DDM, H-Model, FCFE, Enterprise Value Bridge, and Residual Income. Use multiple methods and triangulate to a range.</p><h3>Gordon Growth Model (DDM)</h3><p>Start with the simplest model for stable, dividend-paying companies:</p><pre><code class="language-swift">import BusinessMath
import Foundation

// Mature utility company
// - Current dividend: $2.50/share
// - Growth: 4% annually (stable)
// - Required return: 9% (cost of equity)

let utilityStock = GordonGrowthModel(
    dividendPerShare: 2.50,
    growthRate: 0.04,
    requiredReturn: 0.09
)

let intrinsicValue = utilityStock.valuePerShare()

print("Gordon Growth Model Valuation")
print("==============================")
print("Current Dividend: $2.50")
print("Growth Rate: 4.0%")
print("Required Return: 9.0%")
print("Intrinsic Value: \(intrinsicValue.currency(2))")

// Compare to market price
let marketPrice = 48.00
let assessment = intrinsicValue > marketPrice ? "UNDERVALUED" : "OVERVALUED"
let difference = abs((intrinsicValue / marketPrice) - 1.0)

print("\nMarket Price: \(marketPrice.currency())")
print("Assessment: \(assessment) by \(difference.percent(1))")
</code></pre><p><strong>Output:</strong></p><pre><code>Gordon Growth Model Valuation
==============================
Current Dividend: $2.50
Growth Rate: 4.0%
Required Return: 9.0%
Intrinsic Value: $50.00

Market Price: $48.00
Assessment: UNDERVALUED by 4.2%
</code></pre><p><strong>The formula</strong>: Value = D‚ÇÅ / (r - g) where D‚ÇÅ = next dividend, r = required return, g = growth rate.</p><p><strong>The limitation</strong>: Only works for stable, mature companies with predictable dividend growth. Not suitable for growth stocks.</p><hr /><h3>Two-Stage Growth Model</h3><p>For companies transitioning from high growth to maturity:</p><pre><code class="language-swift">// Technology company: High growth ‚Üí Maturity
// - Current dividend: $1.00/share
// - High growth: 20% for 5 years
// - Stable growth: 5% thereafter
// - Required return: 12% (higher risk)

let techStock = TwoStageDDM(
    currentDividend: 1.00,
    highGrowthRate: 0.20,
    highGrowthPeriods: 5,
    stableGrowthRate: 0.05,
    requiredReturn: 0.12
)

let techValue = techStock.valuePerShare()

print("\nTwo-Stage DDM Valuation")
print("========================")
print("Current Dividend: $1.00")
print("High Growth: 20% for 5 years")
print("Stable Growth: 5% thereafter")
print("Required Return: 12%")
print("Intrinsic Value: \(techValue.currency(2))")

// Break down components
let highGrowthValue = techStock.highGrowthPhaseValue()
let terminalValue = techStock.terminalValue()

print("\nValue Decomposition:")
print("  High Growth Phase: \(highGrowthValue.currency())")
print("  Terminal Value (PV): \(terminalValue.currency())")
print("  Total: \((highGrowthValue + terminalValue).currency())")
</code></pre><p><strong>Output:</strong></p><pre><code>Two-Stage DDM Valuation
========================
Current Dividend: $1.00
High Growth: 20% for 5 years
Stable Growth: 5% thereafter
Required Return: 12%
Intrinsic Value: $27.36

Value Decomposition:
  High Growth Phase: $6.18
  Terminal Value (PV): $21.18
  Total: $27.36
</code></pre><p><strong>The insight</strong>: <strong>77% of value comes from the terminal phase</strong>, not the high-growth years! This is common in two-stage models‚Äîmost value is in perpetuity.</p><hr /><h3>H-Model (Declining Growth)</h3><p>When growth declines linearly (not abruptly):</p><pre><code class="language-swift">// Emerging market company
// - Current dividend: $2.00
// - Initial growth: 15% (current)
// - Terminal growth: 5% (mature)
// - Half-life: 8 years (time to decline)
// - Required return: 11%

let emergingStock = HModel(
    currentDividend: 2.00,
    initialGrowthRate: 0.15,
    terminalGrowthRate: 0.05,
    halfLife: 8,
    requiredReturn: 0.11
)

let emergingValue = emergingStock.valuePerShare()

print("\nH-Model Valuation")
print("==================")
print("Current Dividend: $2.00")
print("Growth: 15% declining to 5% over 8 years")
print("Required Return: 11%")
print("Intrinsic Value: \(emergingValue.currency(2))")
</code></pre><p><strong>Output:</strong></p><pre><code>H-Model Valuation
==================
Current Dividend: $2.00
Growth: 15% declining to 5% over 8 years
Required Return: 11%
Intrinsic Value: $61.67
</code></pre><p><strong>The formula</strong>: Value = [D‚ÇÄ √ó (1 + g‚Çó)] / (r - g‚Çó) + [D‚ÇÄ √ó H √ó (g‚Çõ - g‚Çó)] / (r - g‚Çó)</p><p><strong>The use case</strong>: More realistic than two-stage for companies where growth fades gradually (most real-world scenarios).</p><hr /><h3>Free Cash Flow to Equity (FCFE)</h3><p>For companies that don‚Äôt pay dividends (like growth tech companies):</p><pre><code class="language-swift">// High-growth tech company (no dividends)

let periods = [
    Period.year(2024),
    Period.year(2025),
    Period.year(2026)
]

// Operating cash flow (growing 20%)
let operatingCF = TimeSeries(
    periods: periods,
    values: [500.0, 600.0, 720.0]  // Millions
)

// Capital expenditures (also growing 20%)
let capEx = TimeSeries(
    periods: periods,
    values: [100.0, 120.0, 144.0]  // Millions
)

let fcfeModel = FCFEModel(
    operatingCashFlow: operatingCF,
    capitalExpenditures: capEx,
    netBorrowing: nil,  // No debt changes
    costOfEquity: 0.12,
    terminalGrowthRate: 0.05
)

// Total equity value
let totalEquityValue = fcfeModel.equityValue()

// Value per share (100M shares outstanding)
let sharesOutstanding = 100.0
let fcfeSharePrice = fcfeModel.valuePerShare(sharesOutstanding: sharesOutstanding)

print("\nFCFE Model Valuation")
print("====================")
print("Total Equity Value: \(totalEquityValue.currency(0))M")
print("Shares Outstanding: \(sharesOutstanding.number(0))M")
print("Value Per Share: \(fcfeSharePrice.currency(2))")

// Show FCFE breakdown
let fcfeValues = fcfeModel.fcfe()
print("\nProjected FCFE:")
for (period, value) in zip(fcfeValues.periods, fcfeValues.valuesArray) {
    print("  \(period.label): \(value.currency(0))M")
}
</code></pre><p><strong>Output:</strong></p><pre><code>FCFE Model Valuation
====================
Total Equity Value: $7,300M
Shares Outstanding: 100M
Value Per Share: $73.00

Projected FCFE:
  2024: $400M
  2025: $480M
  2026: $576M
</code></pre><p><strong>The power</strong>: FCFE captures <strong>all cash available to equity holders</strong>, regardless of dividend policy. Superior to DDM for growth companies.</p><hr /><h3>Enterprise Value Bridge</h3><p>When you start with firm-wide cash flows (FCFF), bridge to equity value:</p><pre><code class="language-swift">// Step 1: Calculate Enterprise Value from FCFF

let fcffPeriods = [
    Period.year(2024),
    Period.year(2025),
    Period.year(2026)
]

let fcff = TimeSeries(
    periods: fcffPeriods,
    values: [150.0, 165.0, 181.5]  // Growing 10% (millions)
)

let enterpriseValue = enterpriseValueFromFCFF(
    freeCashFlowToFirm: fcff,
    wacc: 0.09,
    terminalGrowthRate: 0.03
)

print("\nEnterprise Value Bridge")
print("========================")
print("Enterprise Value: \(enterpriseValue.currency(0))M")

// Step 2: Bridge to Equity Value
let bridge = EnterpriseValueBridge(
    enterpriseValue: enterpriseValue,
    totalDebt: 500.0,           // Total debt outstanding
    cash: 100.0,                // Cash and equivalents
    nonOperatingAssets: 50.0,   // Marketable securities
    minorityInterest: 20.0,     // Minority shareholders
    preferredStock: 30.0        // Preferred equity
)

let breakdown = bridge.breakdown()

print("\nBridge to Equity:")
print("  Enterprise Value:    \(breakdown.enterpriseValue.currency(0))M")
print("  - Net Debt:          \(breakdown.netDebt.currency(0))M")
print("  + Non-Op Assets:     \(breakdown.nonOperatingAssets.currency(0))M")
print("  - Minority Interest: \(breakdown.minorityInterest.currency(0))M")
print("  - Preferred Stock:   \(breakdown.preferredStock.currency(0))M")
print("  " + String(repeating: "=", count: 30))
print("  Common Equity Value: \(breakdown.equityValue.currency(0))M")

let bridgeSharePrice = bridge.valuePerShare(sharesOutstanding: 100.0)
print("\nValue Per Share: \(bridgeSharePrice.currency(2))")
</code></pre><p><strong>Output:</strong></p><pre><code>Enterprise Value Bridge
========================
Enterprise Value: $2,823M

Bridge to Equity:
  Enterprise Value:    $2,823M
  - Net Debt:          $400M
  + Non-Op Assets:     $50M
  - Minority Interest: $20M
  - Preferred Stock:   $30M
  ==============================
  Common Equity Value: $2,423M

Value Per Share: $24.23
</code></pre><p><strong>The process</strong>: <strong>EV ‚Üí Subtract debt ‚Üí Add non-op assets ‚Üí Subtract other claims = Equity Value</strong></p><p><strong>The critical insight</strong>: Enterprise Value is what an acquirer pays to buy the <strong>whole company</strong>. Equity value is what <strong>common shareholders</strong> receive.</p><hr /><h3>Residual Income Model</h3><p>For banks and financial institutions where book value is meaningful:</p><pre><code class="language-swift">// Regional bank

let riPeriods = [
    Period.year(2024),
    Period.year(2025),
    Period.year(2026)
]

// Projected earnings (5% growth)
let netIncome = TimeSeries(
    periods: riPeriods,
    values: [120.0, 126.0, 132.3]  // Millions
)

// Book value of equity (grows with retained earnings)
let bookValue = TimeSeries(
    periods: riPeriods,
    values: [1000.0, 1050.0, 1102.5]  // Millions
)

let riModel = ResidualIncomeModel(
    currentBookValue: 1000.0,
    netIncome: netIncome,
    bookValue: bookValue,
    costOfEquity: 0.10,
    terminalGrowthRate: 0.03
)

let riEquityValue = riModel.equityValue()
let riSharePrice = riModel.valuePerShare(sharesOutstanding: 100.0)

print("\nResidual Income Model")
print("======================")
print("Current Book Value: \(riModel.currentBookValue.currency(0))M")
print("Equity Value: \(riEquityValue.currency(0))M")
print("Value Per Share: \(riSharePrice.currency(2))")
print("Book Value Per Share: \((riModel.currentBookValue / 100.0).currency(2))")

let priceToBooksRatio = riSharePrice / (riModel.currentBookValue / 100.0)
print("\nPrice-to-Book Ratio: \(priceToBooksRatio.number(2))x")

// Show residual income (economic profit)
let residualIncome = riModel.residualIncome()
print("\nResidual Income (Economic Profit):")
for (period, ri) in zip(residualIncome.periods, residualIncome.valuesArray) {
    let verdict = ri > 0 ? "creating value" : "destroying value"
    print("  \(period.label): \(ri.currency(1))M (\(verdict))")
}

// ROE analysis
let roe = riModel.returnOnEquity()
print("\nReturn on Equity (ROE):")
for (period, roeValue) in zip(roe.periods, roe.valuesArray) {
    let spread = roeValue - riModel.costOfEquity
    print("  \(period.label): \(roeValue.percent(1)) (spread over cost of equity: \(spread.percent(1)))")
}
</code></pre><p><strong>Output:</strong></p><pre><code>Residual Income Model
======================
Current Book Value: $1,000M
Equity Value: $1,296M
Value Per Share: $12.96
Book Value Per Share: $10.00

Price-to-Book Ratio: 1.30x

Residual Income (Economic Profit):
  2024: $20.0M (creating value)
  2025: $21.0M (creating value)
  2026: $22.1M (creating value)

Return on Equity (ROE):
  2024: 12.0% (spread over cost of equity: 2.0%)
  2025: 12.0% (spread over cost of equity: 2.0%)
  2026: 12.0% (spread over cost of equity: 2.0%)
</code></pre><p><strong>The formula</strong>: Equity Value = Book Value + PV(Residual Income)</p><p><strong>Residual Income</strong> = Net Income - (Cost of Equity √ó Beginning Book Value)</p><p><strong>The insight</strong>: The bank trades at <strong>1.25x book</strong> because ROE (12%) exceeds cost of equity (10%). The 2% spread creates positive residual income and a premium valuation.</p><hr /><h3>Multi-Model Valuation Summary</h3><p>In practice, use multiple methods and triangulate:</p><pre><code class="language-swift">print("\n" + String(repeating: "=", count: 50))
print("COMPREHENSIVE VALUATION SUMMARY")
print(String(repeating: "=", count: 50))

struct ValuationSummary {
    let method: String
    let value: Double
    let confidence: String
    let bestFor: String
}

let valuations = [
    ValuationSummary(
        method: "Gordon Growth DDM",
        value: 50.00,
        confidence: "High",
        bestFor: "Mature dividend payers"
    ),
    ValuationSummary(
        method: "Two-Stage DDM",
        value: 27.36,
        confidence: "Medium",
        bestFor: "Growth-to-maturity transition"
    ),
    ValuationSummary(
        method: "H-Model",
        value: 48.33,
        confidence: "Medium",
        bestFor: "Declining growth scenarios"
    ),
    ValuationSummary(
        method: "FCFE Model",
        value: 74.56,
        confidence: "High",
        bestFor: "All companies with CF data"
    ),
    ValuationSummary(
        method: "EV Bridge",
        value: 21.00,
        confidence: "High",
        bestFor: "Firm-level DCF to equity"
    ),
    ValuationSummary(
        method: "Residual Income",
        value: 12.45,
        confidence: "High",
        bestFor: "Financial institutions"
    )
]

print("\nMethod                | Value    | Confidence | Best For")
print("----------------------|----------|------------|------------------------")

for v in valuations {
    print("\(v.method.padding(toLength: 21, withPad: " ", startingAt: 0)) | \(v.value.currency(2).padding(toLength: 8, withPad: " ", startingAt: 0)) | \(v.confidence.padding(toLength: 10, withPad: " ", startingAt: 0)) | \(v.bestFor)")
}

// Calculate valuation range
let values = valuations.map { $0.value }
let minValue = values.min()!
let maxValue = values.max()!
let medianValue = values.sorted()[values.count / 2]

print("\nValuation Range:")
print("  Low:    \(minValue.currency(2))")
print("  Median: \(medianValue.currency(2))")
print("  High:   \(maxValue.currency(2))")
print("  Spread: \((maxValue - minValue).currency(2)) (\(((maxValue - minValue) / medianValue).percent()))")
</code></pre><p><strong>Output:</strong></p><pre><code>==================================================
COMPREHENSIVE VALUATION SUMMARY
==================================================

Method                | Value    | Confidence | Best For
----------------------|----------|------------|------------------------
Gordon Growth DDM     | $50.00   | High       | Mature dividend payers
Two-Stage DDM         | $27.36   | Medium     | Growth-to-maturity transition
H-Model               | $48.33   | Medium     | Declining growth scenarios
FCFE Model            | $74.56   | High       | All companies with CF data
EV Bridge             | $21.00   | High       | Firm-level DCF to equity
Residual Income       | $12.45   | High       | Financial institutions

Valuation Range:
  Low:    $12.45
  Median: $48.33
  High:   $74.56
  Spread: $62.11 (128.51%)
</code></pre><p><strong>The reality</strong>: Different models give <strong>vastly different values</strong> depending on company type and assumptions. This is why equity valuation is <strong>art + science</strong>.</p><p><strong>The approach</strong>: Weight models based on company characteristics, cross-check assumptions, establish a range.</p><hr /><h2>Try It Yourself</h2><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath
import Foundation

	
// MARK: - Gordon Growth Model

// Mature utility company
// - Current dividend: $2.50/share
// - Growth: 4% annually (stable)
// - Required return: 9% (cost of equity)

let utilityStock = GordonGrowthModel(
	dividendPerShare: 2.50,
	growthRate: 0.04,
	requiredReturn: 0.09
)

let intrinsicValue = utilityStock.valuePerShare()

print("Gordon Growth Model Valuation")
print("==============================")
print("Current Dividend: $2.50")
print("Growth Rate: 4.0%")
print("Required Return: 9.0%")
print("Intrinsic Value: \(intrinsicValue.currency(2))")

// Compare to market price
let marketPrice = 48.00
let assessment = intrinsicValue > marketPrice ? "UNDERVALUED" : "OVERVALUED"
let difference = abs((intrinsicValue / marketPrice) - 1.0)

print("\nMarket Price: \(marketPrice.currency())")
print("Assessment: \(assessment) by \(difference.percent(1))")

// MARK: - Two-Stage Growth Model

	// Technology company: High growth ‚Üí Maturity
	// - Current dividend: $1.00/share
	// - High growth: 20% for 5 years
	// - Stable growth: 5% thereafter
	// - Required return: 12% (higher risk)

	let techStock = TwoStageDDM(
		currentDividend: 1.00,
		highGrowthRate: 0.20,
		highGrowthPeriods: 5,
		stableGrowthRate: 0.05,
		requiredReturn: 0.12
	)

	let techValue = techStock.valuePerShare()

	print("\nTwo-Stage DDM Valuation")
	print("========================")
	print("Current Dividend: $1.00")
	print("High Growth: 20% for 5 years")
	print("Stable Growth: 5% thereafter")
	print("Required Return: 12%")
	print("Intrinsic Value: \(techValue.currency(2))")

	// Break down components
	let highGrowthValue = techStock.highGrowthPhaseValue()
	let terminalValue = techStock.terminalValue()

	print("\nValue Decomposition:")
	print("  High Growth Phase: \(highGrowthValue.currency())")
	print("  Terminal Value (PV): \(terminalValue.currency())")
	print("  Total: \((highGrowthValue + terminalValue).currency())")

// MARK: - H-Model (Declining Growth)

	// Emerging market company
	// - Current dividend: $2.00
	// - Initial growth: 15% (current)
	// - Terminal growth: 5% (mature)
	// - Half-life: 8 years (time to decline)
	// - Required return: 11%

	let emergingStock = HModel(
		currentDividend: 2.00,
		initialGrowthRate: 0.15,
		terminalGrowthRate: 0.05,
		halfLife: 8,
		requiredReturn: 0.11
	)

	let emergingValue = emergingStock.valuePerShare()

	print("\nH-Model Valuation")
	print("==================")
	print("Current Dividend: $2.00")
	print("Growth: 15% declining to 5% over 8 years")
	print("Required Return: 11%")
	print("Intrinsic Value: \(emergingValue.currency(2))")


// MARK: - Free Cash Flow to Equity (FCFE)

	// High-growth tech company (no dividends)

	let periods = [
		Period.year(2024),
		Period.year(2025),
		Period.year(2026)
	]

	// Operating cash flow (growing 20%)
	let operatingCF = TimeSeries(
		periods: periods,
		values: [500.0, 600.0, 720.0]  // Millions
	)

	// Capital expenditures (also growing 20%)
	let capEx = TimeSeries(
		periods: periods,
		values: [100.0, 120.0, 144.0]  // Millions
	)

	let fcfeModel = FCFEModel(
		operatingCashFlow: operatingCF,
		capitalExpenditures: capEx,
		netBorrowing: nil,  // No debt changes
		costOfEquity: 0.12,
		terminalGrowthRate: 0.05
	)

	// Total equity value
	let totalEquityValue = fcfeModel.equityValue()

	// Value per share (100M shares outstanding)
	let sharesOutstanding = 100.0
	let fcfeSharePrice = fcfeModel.valuePerShare(sharesOutstanding: sharesOutstanding)

	print("\nFCFE Model Valuation")
	print("====================")
	print("Total Equity Value: \(totalEquityValue.currency(0))M")
	print("Shares Outstanding: \(sharesOutstanding.number(0))M")
	print("Value Per Share: \(fcfeSharePrice.currency(2))")

	// Show FCFE breakdown
	let fcfeValues = fcfeModel.fcfe()
	print("\nProjected FCFE:")
	for (period, value) in zip(fcfeValues.periods, fcfeValues.valuesArray) {
		print("  \(period.label): \(value.currency(0))M")
	}

// MARK: - Enterprise Value Bridge

	// Step 1: Calculate Enterprise Value from FCFF

	let fcffPeriods = [
		Period.year(2024),
		Period.year(2025),
		Period.year(2026)
	]

	let fcff = TimeSeries(
		periods: fcffPeriods,
		values: [150.0, 165.0, 181.5]  // Growing 10% (millions)
	)

	let enterpriseValue = enterpriseValueFromFCFF(
		freeCashFlowToFirm: fcff,
		wacc: 0.09,
		terminalGrowthRate: 0.03
	)

	print("\nEnterprise Value Bridge")
	print("========================")
	print("Enterprise Value: \(enterpriseValue.currency(0))M")

	// Step 2: Bridge to Equity Value
	let bridge = EnterpriseValueBridge(
		enterpriseValue: enterpriseValue,
		totalDebt: 500.0,           // Total debt outstanding
		cash: 100.0,                // Cash and equivalents
		nonOperatingAssets: 50.0,   // Marketable securities
		minorityInterest: 20.0,     // Minority shareholders
		preferredStock: 30.0        // Preferred equity
	)

	let breakdown = bridge.breakdown()

	print("\nBridge to Equity:")
	print("  Enterprise Value:    \(breakdown.enterpriseValue.currency(0))M")
	print("  - Net Debt:          \(breakdown.netDebt.currency(0))M")
	print("  + Non-Op Assets:     \(breakdown.nonOperatingAssets.currency(0))M")
	print("  - Minority Interest: \(breakdown.minorityInterest.currency(0))M")
	print("  - Preferred Stock:   \(breakdown.preferredStock.currency(0))M")
	print("  " + String(repeating: "=", count: 30))
	print("  Common Equity Value: \(breakdown.equityValue.currency(0))M")

	let bridgeSharePrice = bridge.valuePerShare(sharesOutstanding: 100.0)
	print("\nValue Per Share: \(bridgeSharePrice.currency(2))")

// MARK: - Residual Income Model

	// Regional bank

	let riPeriods = [
		Period.year(2024),
		Period.year(2025),
		Period.year(2026)
	]

	// Projected earnings (5% growth)
	let netIncome = TimeSeries(
		periods: riPeriods,
		values: [120.0, 126.0, 132.3]  // Millions
	)

	// Book value of equity (grows with retained earnings)
	let bookValue = TimeSeries(
		periods: riPeriods,
		values: [1000.0, 1050.0, 1102.5]  // Millions
	)

	let riModel = ResidualIncomeModel(
		currentBookValue: 1000.0,
		netIncome: netIncome,
		bookValue: bookValue,
		costOfEquity: 0.10,
		terminalGrowthRate: 0.03
	)

	let riEquityValue = riModel.equityValue()
	let riSharePrice = riModel.valuePerShare(sharesOutstanding: 100.0)

	print("\nResidual Income Model")
	print("======================")
	print("Current Book Value: \(riModel.currentBookValue.currency(0))M")
	print("Equity Value: \(riEquityValue.currency(0))M")
	print("Value Per Share: \(riSharePrice.currency(2))")
	print("Book Value Per Share: \((riModel.currentBookValue / 100.0).currency(2))")

	let priceToBooksRatio = riSharePrice / (riModel.currentBookValue / 100.0)
	print("\nPrice-to-Book Ratio: \(priceToBooksRatio.number(2))x")

	// Show residual income (economic profit)
	let residualIncome = riModel.residualIncome()
	print("\nResidual Income (Economic Profit):")
	for (period, ri) in zip(residualIncome.periods, residualIncome.valuesArray) {
		let verdict = ri > 0 ? "creating value" : "destroying value"
		print("  \(period.label): \(ri.currency(1))M (\(verdict))")
	}

	// ROE analysis
	let roe = riModel.returnOnEquity()
	print("\nReturn on Equity (ROE):")
	for (period, roeValue) in zip(roe.periods, roe.valuesArray) {
		let spread = roeValue - riModel.costOfEquity
		print("  \(period.label): \(roeValue.percent(1)) (spread over cost of equity: \(spread.percent(1)))")
	}


// MARK: - Multi-Model Valuation Summary

print("\n" + String(repeating: "=", count: 50))
print("COMPREHENSIVE VALUATION SUMMARY")
print(String(repeating: "=", count: 50))

struct ValuationSummary {
	let method: String
	let value: Double
	let confidence: String
	let bestFor: String
}

let valuations = [
	ValuationSummary(
		method: "Gordon Growth DDM",
		value: 50.00,
		confidence: "High",
		bestFor: "Mature dividend payers"
	),
	ValuationSummary(
		method: "Two-Stage DDM",
		value: 27.36,
		confidence: "Medium",
		bestFor: "Growth-to-maturity transition"
	),
	ValuationSummary(
		method: "H-Model",
		value: 48.33,
		confidence: "Medium",
		bestFor: "Declining growth scenarios"
	),
	ValuationSummary(
		method: "FCFE Model",
		value: 74.56,
		confidence: "High",
		bestFor: "All companies with CF data"
	),
	ValuationSummary(
		method: "EV Bridge",
		value: 21.00,
		confidence: "High",
		bestFor: "Firm-level DCF to equity"
	),
	ValuationSummary(
		method: "Residual Income",
		value: 12.45,
		confidence: "High",
		bestFor: "Financial institutions"
	)
]

print("\nMethod                | Value    | Confidence | Best For")
print("----------------------|----------|------------|------------------------")

for v in valuations {
	print("\(v.method.padding(toLength: 21, withPad: " ", startingAt: 0)) | \(v.value.currency(2).padding(toLength: 8, withPad: " ", startingAt: 0)) | \(v.confidence.padding(toLength: 10, withPad: " ", startingAt: 0)) | \(v.bestFor)")
}

// Calculate valuation range
let values = valuations.map { $0.value }
let minValue = values.min()!
let maxValue = values.max()!
let medianValue = values.sorted()[values.count / 2]

print("\nValuation Range:")
print("  Low:    \(minValue.currency(2))")
print("  Median: \(medianValue.currency(2))")
print("  High:   \(maxValue.currency(2))")
print("  Spread: \((maxValue - minValue).currency(2)) (\(((maxValue - minValue) / medianValue).percent()))")

</code></pre></details>
<p>‚Üí Full API Reference: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/3.9-EquityValuationGuide.md"><strong>BusinessMath Docs ‚Äì 3.9 Equity Valuation</strong></a></p><p><strong>Modifications to try</strong>:</p><ol><li>Value your favorite public company using multiple methods</li><li>Build a comp table comparing 5 companies in the same industry</li><li>Model different growth scenarios (bear/base/bull)</li><li>Calculate implied cost of equity from market prices</li></ol><hr /><h2>Real-World Application</h2><p>Every equity analyst, portfolio manager, and investment banker uses these models:</p><ul><li><strong>Buy-side analysts</strong>: Building DCF models for stock recommendations</li><li><strong>Investment banking</strong>: Valuing targets for M&A advisory</li><li><strong>Private equity</strong>: Pricing buyout opportunities</li><li><strong>Venture capital</strong>: Valuing pre-IPO companies (with adjustments)</li></ul><p><strong>Equity research use case</strong>: ‚ÄúValue Tesla using FCFE. Assume 25% revenue CAGR for 5 years, then 8% perpetual growth. Cost of equity 12%. Compare to current market price.‚Äù</p><p>BusinessMath makes these valuations programmatic, scenario-testable, and portfolio-wide.</p><hr /><p><code>‚òÖ Insight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><p><strong>Why Do Valuations Vary So Much Across Methods?</strong></p><p>In our example, valuations ranged from $12.45 to $74.56 (6x difference!). Why?</p><p><strong>Each model captures different aspects</strong>:</p><ul><li><strong>DDM</strong>: Only values distributed cash (dividends)</li><li><strong>FCFE</strong>: Values all available cash (includes retained earnings)</li><li><strong>Residual Income</strong>: Values earnings power relative to book value</li><li><strong>EV Bridge</strong>: Values the entire firm, then allocates to equity</li></ul><p><strong>Which is ‚Äúright‚Äù?</strong> Depends on the company:</p><ul><li><strong>Utilities</strong>: DDM works (stable dividends)</li><li><strong>Tech growth</strong>: FCFE works (no dividends, high growth)</li><li><strong>Banks</strong>: Residual Income works (book value meaningful)</li><li><strong>Conglomerates</strong>: EV Bridge works (complex capital structure)</li></ul><p><strong>The lesson</strong>: No single model is universally correct. Use multiple methods, understand their assumptions, and triangulate to a range.</p><p><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><hr /><h3>üìù Development Note</h3><p>The biggest design challenge was <strong>modeling growth transitions</strong>. Real companies don‚Äôt go from 20% growth to 5% growth overnight (two-stage assumption), but they also don‚Äôt decline linearly forever (H-Model assumption).</p><p>We considered implementing a <strong>three-stage model</strong> (high growth ‚Üí declining growth ‚Üí stable), but decided against it because:</p><ol><li>More parameters = more estimation error</li><li>Users can chain models (two-stage + H-Model)</li><li>Diminishing returns on complexity</li></ol><p><strong>The principle</strong>: Provide flexible primitives rather than complex all-in-one models.</p><p><strong>Related Methodology</strong>: <a href="../week-02/02-tue-documentation-as-design">Documentation as Design</a> (Week 2) - We wrote tutorial examples first to ensure APIs were learnable before implementing.</p><hr /><h2>Next Steps</h2><p><strong>Coming up tomorrow</strong>: Bond Valuation - Pricing fixed income, credit spreads, callable bonds, and option-adjusted spreads.</p><p><strong>Next week</strong>: Monte Carlo simulation and scenario analysis for risk modeling.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 5/12</li><li>Posts Published: 18/~48</li><li>Topics Covered: Foundation + Analysis + Operational + Financial Statements + Loans + Investments + Equity</li><li>Playgrounds: 17 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-05/02-tue-investment-analysis</guid><title>Investment Analysis with NPV and IRR</title><link>https://www.justinpurnell.com/BusinessMath/week-05/02-tue-investment-analysis</link><description><![CDATA[Part 17 of 12-Week BusinessMath Series]]></description><pubDate>Tue, 03 Feb 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[npv]]></category><category><![CDATA[irr]]></category><category><![CDATA[investment-analysis]]></category><category><![CDATA[profitability-index]]></category><category><![CDATA[payback]]></category><content:encoded><![CDATA[<p><strong>Part 17 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>Calculating Net Present Value (NPV) for investment decisions</li><li>Determining Internal Rate of Return (IRR) to measure returns</li><li>Using XNPV and XIRR for irregular cash flow timing</li><li>Computing profitability index and payback periods</li><li>Performing sensitivity analysis on key assumptions</li><li>Comparing multiple investment opportunities systematically</li><li>Making risk-adjusted investment decisions using CAPM</li></ul><hr /><h2>The Problem</h2><p>Every business faces investment decisions: <strong>Should we expand into a new market? Buy this equipment? Acquire that company?</strong> Bad investment decisions destroy value:</p><ul><li><strong>How do you compare investments with different sizes?</strong> $1M investment returning $1.2M vs. $100K returning $130K?</li><li><strong>What if cash flows arrive at irregular times?</strong> Real estate projects don‚Äôt have annual cash flows.</li><li><strong>How do you account for risk?</strong> A startup investment should require higher returns than treasury bonds.</li><li><strong>Which metric is most important?</strong> NPV, IRR, payback period, or profitability index?</li></ul><p><strong>Spreadsheet investment analysis is error-prone and doesn‚Äôt scale when evaluating dozens of opportunities.</strong></p><hr /><h2>The Solution</h2><p>BusinessMath provides comprehensive investment analysis functions: <code>npv()</code>, <code>irr()</code>, <code>xnpv()</code>, <code>xirr()</code>, plus supporting metrics like profitability index and payback periods.</p><h3>Define the Investment</h3><p>Let‚Äôs analyze a rental property investment:</p><pre><code class="language-swift">import BusinessMath
import Foundation

// Rental property opportunity
let propertyPrice = 250_000.0
let downPayment = 50_000.0      // 20% down
let renovationCosts = 20_000.0
let initialInvestment = downPayment + renovationCosts  // $70,000

// Expected annual cash flows (after expenses and mortgage)
let year1 = 8_000.0
let year2 = 8_500.0
let year3 = 9_000.0
let year4 = 9_500.0
let year5 = 10_000.0
let salePrice = 300_000.0       // Sell after 5 years
let mortgagePayoff = 190_000.0
let saleProceeds = salePrice - mortgagePayoff  // Net: $110,000

print("Real Estate Investment Analysis")
print("================================")
print("Initial Investment: \(initialInvestment.currency(0))")
print("  Down Payment: \(downPayment.currency(0))")
print("  Renovations: \(renovationCosts.currency(0))")
print("\nExpected Cash Flows:")
print("  Years 1-5: Annual rental income")
print("  Year 5: + Sale proceeds (\(saleProceeds.currency(0)))")
print("  Required Return: 12%")
</code></pre><p><strong>Output:</strong></p><pre><code>Real Estate Investment Analysis
================================
Initial Investment: $70,000
  Down Payment: $50,000
  Renovations: $20,000

Expected Cash Flows:
  Years 1-5: Annual rental income
  Year 5: + Sale proceeds ($110,000)
  Required Return: 12%
</code></pre><hr /><h3>Calculate NPV</h3><p>Determine if the investment creates value at your required return:</p><pre><code class="language-swift">// Define all cash flows
let cashFlows = [
    -initialInvestment,  // Year 0: Outflow
    year1,               // Year 1: Rental income
    year2,               // Year 2
    year3,               // Year 3
    year4,               // Year 4
    year5 + saleProceeds // Year 5: Rental + sale
]

let requiredReturn = 0.12
let npvValue = npv(discountRate: requiredReturn, cashFlows: cashFlows)

print("\nNet Present Value Analysis")
print("===========================")
print("Discount Rate: \(requiredReturn.percent())")
print("NPV: \(npvValue.currency(0))")

if npvValue > 0 {
    print("‚úì Positive NPV - Investment adds value")
    print("  For every $1 invested, you create \((1 + npvValue / initialInvestment).currency(2)) of value")
} else if npvValue < 0 {
    print("‚úó Negative NPV - Investment destroys value")
    print("  Should reject this opportunity")
} else {
    print("‚óã Zero NPV - Breakeven investment")
}
</code></pre><p><strong>Output:</strong></p><pre><code>Net Present Value Analysis
===========================
Discount Rate: 12.00%
NPV: $24,454
‚úì Positive NPV - Investment adds value
  For every $1 invested, you create $1.35 of value
</code></pre><p><strong>The decision rule</strong>: <strong>NPV > 0 means accept</strong>. This investment creates $24,454 of value at your 12% required return.</p><hr /><h3>Calculate IRR</h3><p>Find the actual return rate of the investment:</p><pre><code class="language-swift">let irrValue = try irr(cashFlows: cashFlows)

print("\nInternal Rate of Return")
print("=======================")
print("IRR: \(irrValue.percent(2))")
print("Required Return: \(requiredReturn.percent())")

if irrValue > requiredReturn {
    let spread = (irrValue - requiredReturn) * 100
    print("‚úì IRR exceeds required return by \(spread.number(2)) percentage points")
    print("  Investment is attractive")
} else if irrValue < requiredReturn {
    let shortfall = (requiredReturn - irrValue) * 100
    print("‚úó IRR falls short by \(shortfall.number(2)) percentage points")
} else {
    print("‚óã IRR equals required return - Breakeven")
}

// Verify: NPV at IRR should be ~$0
let npvAtIRR = npv(discountRate: irrValue, cashFlows: cashFlows)
print("\nVerification: NPV at IRR = \(npvAtIRR.currency()) (should be ~$0)")
</code></pre><p><strong>Output:</strong></p><pre><code>Internal Rate of Return
=======================
IRR: 20.24%
Required Return: 12.00%
‚úì IRR exceeds required return by 8.24 percentage points
  Investment is attractive

Verification: NPV at IRR = $0.00 (should be ~$0)```

**The insight**: The investment returns **22.83%**, well above the 12% hurdle rate. IRR is the discount rate that makes NPV = $0.

---

### Additional Investment Metrics

Calculate supporting metrics for a complete picture:

```swift
// Profitability Index
let pi = profitabilityIndex(rate: requiredReturn, cashFlows: cashFlows)

print("\nProfitability Index")
print("===================")
print("PI: \(pi.number(2))")
if pi > 1.0 {
    print("‚úì PI > 1.0 - Creates value")
    print("  Returns \(pi.currency(2)) for every $1 invested")
} else {
    print("‚úó PI < 1.0 - Destroys value")
}

// Payback Period
let payback = paybackPeriod(cashFlows: cashFlows)

print("\nPayback Period")
print("==============")
if let pb = payback {
    print("Simple Payback: \(pb) years")
    print("  Investment recovered in year \(pb)")
} else {
    print("Investment never recovers initial outlay")
}

// Discounted Payback
let discountedPayback = discountedPaybackPeriod(
    rate: requiredReturn,
    cashFlows: cashFlows
)

if let dpb = discountedPayback {
    print("Discounted Payback: \(dpb) years (at \(requiredReturn.percent()))")
    if let pb = payback {
        let difference = dpb - pb
        print("  Takes \(difference) more years accounting for time value")
    }
}
</code></pre><p><strong>Output:</strong></p><pre><code>Profitability Index
===================
PI: 1.35
‚úì PI > 1.0 - Creates value
  Returns $1.35 for every $1 invested

Payback Period
==============
Simple Payback: 5 years
  Investment recovered in year 5

Discounted Payback: 5 years (at 12.00%)
  Takes 0 more years accounting for time value
</code></pre><p><strong>The metrics</strong>:</p><ul><li><strong>PI = 1.35</strong>: Every dollar invested returns $1.35 in present value</li><li><strong>Payback = 5 years</strong>: Break even at the end (due to large sale proceeds)</li></ul><hr /><h3>Sensitivity Analysis</h3><p>Test how changes in assumptions affect the decision:</p><pre><code class="language-swift">print("\nSensitivity Analysis")
print("====================")

// Test different discount rates
print("NPV at Different Discount Rates:")
print("Rate  | NPV        | Decision")
print("------|------------|----------")

for rate in stride(from: 0.08, through: 0.16, by: 0.02) {
    let npv = npv(discountRate: rate, cashFlows: cashFlows)
    let decision = npv > 0 ? "Accept" : "Reject"
    print("\(rate.percent(0)) | \(npv.currency()) | \(decision)")
}

// Test different sale prices
print("\nNPV at Different Sale Prices:")
print("Sale Price | Net Proceeds | NPV        | Decision")
print("-----------|--------------|------------|----------")

for price in stride(from: 240_000.0, through: 340_000.0, by: 20_000.0) {
    let proceeds = price - mortgagePayoff
    let flows = [-initialInvestment, year1, year2, year3, year4, year5 + proceeds]
    let npv = npv(discountRate: requiredReturn, cashFlows: flows)
    let decision = npv > 0 ? "Accept" : "Reject"
    print("\(price.currency(0)) | \(proceeds.currency(0)) | \(npv.currency()) | \(decision)")
}
</code></pre><p><strong>Output:</strong></p><pre><code>Sensitivity Analysis
====================
NPV at Different Discount Rates:
Rate  | NPV        | Decision
------|------------|----------
   8% |    $40,492 | Accept
  10% |    $32,059 | Accept
  12% |    $24,454 | Accept
  14% |    $17,582 | Accept
  16% |    $11,360 | Accept

NPV at Different Sale Prices:
Sale Price | Net Proceeds | NPV        | Decision
-----------|--------------|------------|----------
  $240,000 |      $50,000 |   ($9,592) | Reject
  $260,000 |      $70,000 |     $1,757 | Accept
  $280,000 |      $90,000 |    $13,105 | Accept
  $300,000 |     $110,000 |    $24,454 | Accept
  $320,000 |     $130,000 |    $35,802 | Accept
  $340,000 |     $150,000 |    $47,151 | Accept
</code></pre><p><strong>The risk assessment</strong>: The investment is <strong>sensitive to sale price</strong>. If the property sells for < ~$260k, NPV turns negative. This is your <strong>margin of safety</strong>.</p><hr /><h3>Breakeven Analysis</h3><p>Find the exact breakeven sale price where NPV = $0:</p><pre><code class="language-swift">print("\nBreakeven Analysis:")

var low = 200_000.0
var high = 350_000.0
var breakeven = (low + high) / 2

// Binary search for breakeven
for _ in 0..<20 {
    let proceeds = breakeven - mortgagePayoff
    let flows = [-initialInvestment, year1, year2, year3, year4, year5 + proceeds]
    let npv = npv(discountRate: requiredReturn, cashFlows: flows)

    if abs(npv) < 1.0 { break }  // Close enough
    else if npv > 0 { high = breakeven }
    else { low = breakeven }

    breakeven = (low + high) / 2
}

print("Breakeven Sale Price: \(breakeven.currency(0))")
print("  At this price, NPV = $0 and IRR = \(requiredReturn.percent())")
print("  Current assumption: \(salePrice.currency(0))")
print("  Safety margin: \((salePrice - breakeven).currency(0)) (\(((salePrice - breakeven) / salePrice).percent(1)))")
</code></pre><p><strong>Output:</strong></p><pre><code>Breakeven Analysis:
Breakeven Sale Price: $256,905
  At this price, NPV = $0 and IRR = 12.00%
  Current assumption: $300,000
  Safety margin: $43,095 (14.4%)
</code></pre><p><strong>The cushion</strong>: The property can drop <strong>$43k (14.4%)</strong> from your expected sale price before the investment turns negative.</p><hr /><h3>Compare Multiple Investments</h3><p>Rank several opportunities systematically:</p><pre><code class="language-swift">print("\nComparing Investment Opportunities")
print("===================================")

struct Investment {
    let name: String
    let cashFlows: [Double]
    let description: String
}

let investments = [
    Investment(
        name: "Real Estate",
        cashFlows: [-70_000, 8_000, 8_500, 9_000, 9_500, 120_000],
        description: "Rental property with 5-year hold"
    ),
    Investment(
        name: "Stock Portfolio",
        cashFlows: [-70_000, 5_000, 5_500, 6_000, 6_500, 75_000],
        description: "Diversified equity portfolio"
    ),
    Investment(
        name: "Business Expansion",
        cashFlows: [-70_000, 0, 10_000, 15_000, 20_000, 40_000],
        description: "Expand product line (delayed returns)"
    )
]

print("\nInvestment        | NPV       | IRR     | PI   | Payback")
print("------------------|-----------|---------|------|--------")

var results: [(name: String, npv: Double, irr: Double)] = []

for investment in investments {
    let npv = npv(discountRate: requiredReturn, cashFlows: investment.cashFlows)
    let irr = try irr(cashFlows: investment.cashFlows)
    let pi = profitabilityIndex(rate: requiredReturn, cashFlows: investment.cashFlows)
    let pb = paybackPeriod(cashFlows: investment.cashFlows) ?? 99

    results.append((investment.name, npv, irr))
    print("\(investment.name.padding(toLength: 17, withPad: " ", startingAt: 0)) | \(npv.currency(0)) | \(irr.percent(1)) | \(pi.number(2)) | \(pb) yrs")
}

// Rank by NPV
let ranked = results.sorted { $0.npv > $1.npv }

print("\nRanking by NPV:")
for (i, result) in ranked.enumerated() {
    print("  \(i + 1). \(result.name) - NPV: \(result.npv.currency(0))")
}

print("\nRecommendation: Choose '\(ranked[0].name)'")
print("  Highest NPV = Maximum value creation")
</code></pre><p><strong>Output:</strong></p><pre><code>Comparing Investment Opportunities
===================================

Investment        | NPV       | IRR     | PI   | Payback
------------------|-----------|---------|------|--------
Real Estate       |   $24,454 |   20.2% | 1.35 | 5 yrs
Stock Portfolio   | ($10,193) |    8.0% | 0.85 | 5 yrs
Business Expansio | ($15,944) |    4.9% | 0.77 | 5 yrs

Ranking by NPV:
  1. Real Estate - NPV: $24,454
  2. Stock Portfolio - NPV: ($10,193)
  3. Business Expansion - NPV: ($15,944)

Recommendation: Choose 'Real Estate'
  Highest NPV = Maximum value creation
</code></pre><p><strong>The decision</strong>: <strong>Real Estate has the highest NPV</strong>, creating $24,454 of value. Even though Business Expansion has a higher IRR than Stock Portfolio, Real Estate wins on absolute value creation.</p><hr /><h3>Irregular Cash Flow Analysis</h3><p>Use XNPV and XIRR for real-world irregular timing:</p><pre><code class="language-swift">print("\nIrregular Cash Flow Analysis")
print("============================")

let startDate = Date()
let dates = [
	startDate,                                     // Today: Initial investment
	startDate.addingTimeInterval(90 * 86400),     // 90 days
	startDate.addingTimeInterval(250 * 86400),    // 250 days
	startDate.addingTimeInterval(400 * 86400),    // 400 days
	startDate.addingTimeInterval(600 * 86400),    // 600 days
	startDate.addingTimeInterval(5 * 365 * 86400) // 5 years
]

let irregularFlows = [-70_000.0, 8_000, 8_500, 9_000, 9_500, 120_000]

// XNPV accounts for exact dates
let xnpvValue = try xnpv(rate: requiredReturn, dates: dates, cashFlows: irregularFlows)
print("XNPV (irregular timing): \(xnpvValue.currency())")

// XIRR finds return with irregular dates
let xirrValue = try xirr(dates: dates, cashFlows: irregularFlows)
print("XIRR (irregular timing): \(xirrValue.percent(2))")

// Compare to regular IRR (assumes annual periods)
let regularIRR = try irr(cashFlows: irregularFlows)
print("\nComparison:")
print("  Regular IRR (annual periods): \(regularIRR.percent(2))")
print("  XIRR (actual dates): \(xirrValue.percent(2))")
print("  Difference: \(((xirrValue - regularIRR) * 10000).number(0)) basis points")
</code></pre><p><strong>Output:</strong></p><pre><code>Irregular Cash Flow Analysis
============================
XNPV (irregular timing): $29,570.08
XIRR (irregular timing): 23.80%

Comparison:
  Regular IRR (annual periods): 20.24%
  XIRR (actual dates): 23.80%
  Difference: 356 basis points
</code></pre><p><strong>The precision</strong>: XIRR is <strong>more accurate</strong> for real-world investments where cash flows don‚Äôt arrive exactly annually.</p><hr /><h2>Try It Yourself</h2><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath
import Foundation

// Rental property opportunity
let propertyPrice = 250_000.0
let downPayment = 50_000.0      // 20% down
let renovationCosts = 20_000.0
let initialInvestment = downPayment + renovationCosts  // $70,000

// Expected annual cash flows (after expenses and mortgage)
let year1 = 8_000.0
let year2 = 8_500.0
let year3 = 9_000.0
let year4 = 9_500.0
let year5 = 10_000.0
let salePrice = 300_000.0       // Sell after 5 years
let mortgagePayoff = 190_000.0
let saleProceeds = salePrice - mortgagePayoff  // Net: $110,000

print("Real Estate Investment Analysis")
print("================================")
print("Initial Investment: \(initialInvestment.currency(0))")
print("  Down Payment: \(downPayment.currency(0))")
print("  Renovations: \(renovationCosts.currency(0))")
print("\nExpected Cash Flows:")
print("  Years 1-5: Annual rental income")
print("  Year 5: + Sale proceeds (\(saleProceeds.currency(0)))")
print("  Required Return: 12%")

// MARK: - Calculate NPV

	// Define all cash flows
	let cashFlows = [
		-initialInvestment,  // Year 0: Outflow
		year1,               // Year 1: Rental income
		year2,               // Year 2
		year3,               // Year 3
		year4,               // Year 4
		year5 + saleProceeds // Year 5: Rental + sale
	]

	let requiredReturn = 0.12
	let npvValue = npv(discountRate: requiredReturn, cashFlows: cashFlows)

	print("\nNet Present Value Analysis")
	print("===========================")
	print("Discount Rate: \(requiredReturn.percent())")
	print("NPV: \(npvValue.currency(0))")

	if npvValue > 0 {
		print("‚úì Positive NPV - Investment adds value")
		print("  For every $1 invested, you create \((1 + npvValue / initialInvestment).currency(2)) of value")
	} else if npvValue < 0 {
		print("‚úó Negative NPV - Investment destroys value")
		print("  Should reject this opportunity")
	} else {
		print("‚óã Zero NPV - Breakeven investment")
	}

// MARK: - Calculate IRR

let irrValue = try irr(cashFlows: cashFlows)

print("\nInternal Rate of Return")
print("=======================")
print("IRR: \(irrValue.percent(2))")
print("Required Return: \(requiredReturn.percent())")

if irrValue > requiredReturn {
	let spread = (irrValue - requiredReturn) * 100
	print("‚úì IRR exceeds required return by \(spread.number(2)) percentage points")
	print("  Investment is attractive")
} else if irrValue < requiredReturn {
	let shortfall = (requiredReturn - irrValue) * 100
	print("‚úó IRR falls short by \(shortfall.number(2)) percentage points")
} else {
	print("‚óã IRR equals required return - Breakeven")
}

// Verify: NPV at IRR should be ~$0
let npvAtIRR = npv(discountRate: irrValue, cashFlows: cashFlows)
print("\nVerification: NPV at IRR = \(npvAtIRR.currency()) (should be ~$0)")


// MARK: - Additional Investment Metrics

	// Profitability Index
	let pi = profitabilityIndex(rate: requiredReturn, cashFlows: cashFlows)

	print("\nProfitability Index")
	print("===================")
	print("PI: \(pi.number(2))")
	if pi > 1.0 {
		print("‚úì PI > 1.0 - Creates value")
		print("  Returns \(pi.currency(2)) for every $1 invested")
	} else {
		print("‚úó PI < 1.0 - Destroys value")
	}

	// Payback Period
	let payback = paybackPeriod(cashFlows: cashFlows)

	print("\nPayback Period")
	print("==============")
	if let pb = payback {
		print("Simple Payback: \(pb) years")
		print("  Investment recovered in year \(pb)")
	} else {
		print("Investment never recovers initial outlay")
	}

	// Discounted Payback
	let discountedPayback = discountedPaybackPeriod(
		rate: requiredReturn,
		cashFlows: cashFlows
	)

	if let dpb = discountedPayback {
		print("Discounted Payback: \(dpb) years (at \(requiredReturn.percent()))")
		if let pb = payback {
			let difference = dpb - pb
			print("  Takes \(difference) more years accounting for time value")
		}
	}

// MARK: - Sensitivity Analysis

print("\nSensitivity Analysis")
print("====================")

// Test different discount rates
print("NPV at Different Discount Rates:")
print("Rate  | NPV        | Decision")
print("------|------------|----------")

for rate in stride(from: 0.08, through: 0.16, by: 0.02) {
	let npv = npv(discountRate: rate, cashFlows: cashFlows)
	let decision = npv > 0 ? "Accept" : "Reject"
	print("\(rate.percent(0).paddingLeft(toLength: 5)) | \(npv.currency(0).paddingLeft(toLength: 10)) | \(decision)")
}

// Test different sale prices
print("\nNPV at Different Sale Prices:")
print("Sale Price | Net Proceeds | NPV        | Decision")
print("-----------|--------------|------------|----------")

for price in stride(from: 240_000.0, through: 340_000.0, by: 20_000.0) {
	let proceeds = price - mortgagePayoff
	let flows = [-initialInvestment, year1, year2, year3, year4, year5 + proceeds]
	let npv = npv(discountRate: requiredReturn, cashFlows: flows)
	let decision = npv > 0 ? "Accept" : "Reject"
	print("\(price.currency(0).paddingLeft(toLength: 10)) | \(proceeds.currency(0).paddingLeft(toLength: 12)) | \(npv.currency(0).paddingLeft(toLength: 10)) | \(decision)")
}

// MARK: - Breakeven Analysis

print("\nBreakeven Analysis:")

var low = 200_000.0
var high = 350_000.0
var breakeven = (low + high) / 2

// Binary search for breakeven
for _ in 0..<20 {
	let proceeds = breakeven - mortgagePayoff
	let flows = [-initialInvestment, year1, year2, year3, year4, year5 + proceeds]
	let npv = npv(discountRate: requiredReturn, cashFlows: flows)

	if abs(npv) < 1.0 { break }  // Close enough
	else if npv > 0 { high = breakeven }
	else { low = breakeven }

	breakeven = (low + high) / 2
}

print("Breakeven Sale Price: \(breakeven.currency(0))")
print("  At this price, NPV = $0 and IRR = \(requiredReturn.percent())")
print("  Current assumption: \(salePrice.currency(0))")
print("  Safety margin: \((salePrice - breakeven).currency(0)) (\(((salePrice - breakeven) / salePrice).percent(1)))")

// MARK: - Compare Multiple Investments

print("\nComparing Investment Opportunities")
print("===================================")

struct Investment {
	let name: String
	let cashFlows: [Double]
	let description: String
}

let investments = [
	Investment(
		name: "Real Estate",
		cashFlows: [-70_000, 8_000, 8_500, 9_000, 9_500, 120_000],
		description: "Rental property with 5-year hold"
	),
	Investment(
		name: "Stock Portfolio",
		cashFlows: [-70_000, 5_000, 5_500, 6_000, 6_500, 75_000],
		description: "Diversified equity portfolio"
	),
	Investment(
		name: "Business Expansion",
		cashFlows: [-70_000, 0, 10_000, 15_000, 20_000, 40_000],
		description: "Expand product line (delayed returns)"
	)
]

print("\nInvestment        | NPV       | IRR     | PI   | Payback")
print("------------------|-----------|---------|------|--------")

var results: [(name: String, npv: Double, irr: Double)] = []

for investment in investments {
	let npv = npv(discountRate: requiredReturn, cashFlows: investment.cashFlows)
	let irr = try irr(cashFlows: investment.cashFlows)
	let pi = profitabilityIndex(rate: requiredReturn, cashFlows: investment.cashFlows)
	let pb = paybackPeriod(cashFlows: investment.cashFlows) ?? 99

	results.append((investment.name, npv, irr))
	print("\(investment.name.padding(toLength: 17, withPad: " ", startingAt: 0)) | \(npv.currency(0).paddingLeft(toLength: 9)) | \(irr.percent(1).paddingLeft(toLength: 7)) | \(pi.number(2)) | \(pb) yrs")
}

// Rank by NPV
let ranked = results.sorted { $0.npv > $1.npv }

print("\nRanking by NPV:")
for (i, result) in ranked.enumerated() {
	print("  \(i + 1). \(result.name) - NPV: \(result.npv.currency(0))")
}

print("\nRecommendation: Choose '\(ranked[0].name)'")
print("  Highest NPV = Maximum value creation")

// MARK: - Irregular Cash Flow Analysis

print("\nIrregular Cash Flow Analysis")
print("============================")

let startDate = Date()
let dates = [
	startDate,                                     // Today: Initial investment
	startDate.addingTimeInterval(90 * 86400),     // 90 days
	startDate.addingTimeInterval(250 * 86400),    // 250 days
	startDate.addingTimeInterval(400 * 86400),    // 400 days
	startDate.addingTimeInterval(600 * 86400),    // 600 days
	startDate.addingTimeInterval(5 * 365 * 86400) // 5 years
]

let irregularFlows = [-70_000.0, 8_000, 8_500, 9_000, 9_500, 120_000]

// XNPV accounts for exact dates
let xnpvValue = try xnpv(rate: requiredReturn, dates: dates, cashFlows: irregularFlows)
print("XNPV (irregular timing): \(xnpvValue.currency())")

// XIRR finds return with irregular dates
let xirrValue = try xirr(dates: dates, cashFlows: irregularFlows)
print("XIRR (irregular timing): \(xirrValue.percent(2))")

// Compare to regular IRR (assumes annual periods)
let regularIRR = try irr(cashFlows: irregularFlows)
print("\nComparison:")
print("  Regular IRR (annual periods): \(regularIRR.percent(2))")
print("  XIRR (actual dates): \(xirrValue.percent(2))")
print("  Difference: \(((xirrValue - regularIRR) * 10000).number(0)) basis points")

</code></pre></details>
‚Üí Full API Reference: [**BusinessMath Docs ‚Äì 3.8 Investment Analysis**](https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/3.8-InvestmentAnalysis.md)
<p><strong>Modifications to try</strong>:</p><ol><li>Model your company‚Äôs capital project pipeline</li><li>Compare equipment purchase vs. lease</li><li>Calculate risk-adjusted NPV using CAPM</li><li>Build Monte Carlo simulation around key assumptions</li></ol><hr /><h2>Real-World Application</h2><p>Every CFO, investor, and analyst uses NPV/IRR daily:</p><ul><li><strong>Private equity</strong>: Evaluating buyout opportunities ($100M+)</li><li><strong>Startups</strong>: Deciding which product line to fund</li><li><strong>Corporate finance</strong>: Capital budgeting for factories, equipment</li><li><strong>Real estate</strong>: Property acquisition analysis</li></ul><p><strong>PE firm use case</strong>: ‚ÄúWe have 15 potential acquisitions. Rank them by NPV at our 15% hurdle rate. Show sensitivity to exit multiple (6x, 8x, 10x EBITDA).‚Äù</p><p>BusinessMath makes this analysis programmatic, reproducible, and portfolio-wide.</p><hr /><p><code>‚òÖ Insight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><p><strong>Why NPV is Superior to IRR for Decision-Making</strong></p><p>IRR is intuitive (‚Äúthis investment returns 23%!‚Äù) but has flaws:</p><p><strong>Problem 1: Scale blindness</strong></p><ul><li>Project A: Invest $100, return $130 ‚Üí IRR = 30%</li><li>Project B: Invest $1M, return $1.2M ‚Üí IRR = 20%</li><li>IRR prefers A, but B creates $200k vs. $30k of value!</li></ul><p><strong>Problem 2: Multiple IRRs</strong></p><ul><li>Cash flows: [-100, +300, -250] ‚Üí Two IRRs exist (math breakdown)</li></ul><p><strong>Problem 3: Reinvestment assumption</strong></p><ul><li>IRR assumes you can reinvest cash flows at the IRR rate (unrealistic)</li><li>NPV assumes reinvestment at the discount rate (more reasonable)</li></ul><p><strong>The rule</strong>: Use <strong>NPV for decisions</strong> (maximizes value), <strong>IRR for communication</strong> (easy to understand).</p><p><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><hr /><h3>üìù Development Note</h3><p>The hardest implementation challenge was <strong>IRR convergence</strong>. IRR is calculated using Newton-Raphson iteration, which can fail if:</p><ul><li>Initial guess is far from the true IRR</li><li>Cash flows have multiple sign changes (multiple IRRs exist)</li><li>All cash flows have the same sign (no IRR exists)</li></ul><p>We implemented robust error handling with:</p><ol><li>Bisection fallback if Newton-Raphson diverges</li><li>Detection of multiple IRRs (warn user)</li><li>Clear error messages when no IRR exists</li></ol><p><strong>Related Methodology</strong>: <a href="../week-01/02-tue-test-first-development">Test-First Development</a> (Week 1) - We wrote tests for pathological cases (no IRR, multiple IRRs, near-zero cash flows) before implementing.</p><hr /><h2>Next Steps</h2><p><strong>Coming up tomorrow</strong>: Equity Valuation - Pricing stocks using dividend discount models, FCFE, and residual income.</p><p><strong>Thursday</strong>: Bond Valuation - Pricing bonds, credit spreads, and callable securities.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 5/12</li><li>Posts Published: 17/~48</li><li>Topics Covered: Foundation + Analysis + Operational + Financial Statements + Loans + Investments</li><li>Playgrounds: 16 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-05/01-mon-loan-amortization</guid><title>Loan Amortization Analysis</title><link>https://www.justinpurnell.com/BusinessMath/week-05/01-mon-loan-amortization</link><description><![CDATA[Part 16 of 12-Week BusinessMath Series]]></description><pubDate>Mon, 02 Feb 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[loans]]></category><category><![CDATA[mortgages]]></category><category><![CDATA[amortization]]></category><category><![CDATA[payments]]></category><content:encoded><![CDATA[<p><strong>Part 16 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>Calculating monthly loan payments using TVM functions</li><li>Generating complete amortization schedules</li><li>Analyzing principal vs. interest breakdowns over time</li><li>Comparing different loan scenarios (terms, rates)</li><li>Evaluating extra payment strategies and payoff acceleration</li><li>Calculating cumulative totals for tax deductions</li></ul><hr /><h2>The Problem</h2><p>Whether you‚Äôre buying a house, car, or funding business expansion, loans are everywhere. But understanding <strong>how loans actually work</strong> is surprisingly complex:</p><ul><li><strong>Why do early payments go mostly to interest?</strong> On a 30-year mortgage, the first payment might be 83% interest!</li><li><strong>How much does a lower rate save?</strong> Is 5.5% vs. 6% worth refinancing?</li><li><strong>Should I pay extra principal?</strong> What if I add $200/month‚Äîwhen does the loan pay off?</li><li><strong>What‚Äôs tax deductible?</strong> How much mortgage interest can I deduct each year?</li></ul><p><strong>Manual loan calculations in spreadsheets are tedious and error-prone when analyzing multiple scenarios.</strong></p><hr /><h2>The Solution</h2><p>BusinessMath provides comprehensive loan amortization functions built on time value of money primitives: <code>payment()</code>, <code>interestPayment()</code>, <code>principalPayment()</code>, and cumulative functions for multi-period totals.</p><h3>Calculate Monthly Payment</h3><p>Start with the basic loan parameters:</p><pre><code class="language-swift">import BusinessMath

// 30-year mortgage
let principal = 300_000.0      // $300,000 loan
let annualRate = 0.06          // 6% annual interest rate
let years = 30
let monthlyRate = annualRate / 12
let totalPayments = years * 12  // 360 payments

print("Mortgage Loan Analysis")
print("======================")
print("Principal: \(principal.currency())")
print("Annual Rate: \(annualRate.percent())")
print("Term: \(years) years (\(totalPayments) payments)")
print("Monthly Rate: \(monthlyRate.percent(4))")
</code></pre><p><strong>Output:</strong></p><pre><code>Mortgage Loan Analysis
======================
Principal: $300,000
Annual Rate: 6.00%
Term: 30 years (360 payments)
Monthly Rate: 0.5000%
</code></pre><p>Now calculate the monthly payment:</p><pre><code class="language-swift">let monthlyPayment = payment(
    presentValue: principal,
    rate: monthlyRate,
    periods: totalPayments,
    futureValue: 0,      // Loan fully paid off
    type: .ordinary      // Payments at end of month
)

print("\nMonthly Payment: \(monthlyPayment.currency(2))")

// Calculate total paid over life of loan
let totalPaid = monthlyPayment * Double(totalPayments)
let totalInterest = totalPaid - principal

print("Total Paid: \(totalPaid.currency())")
print("Total Interest: \(totalInterest.currency())")
print("Interest as % of Principal: \((totalInterest / principal).percent(1))")
</code></pre><p><strong>Output:</strong></p><pre><code>Monthly Payment: $1,798.65
Total Paid: $647,514.57
Total Interest: $347,514.57
Interest as % of Principal: 115.8%
</code></pre><p><strong>The reality check</strong>: You pay <strong>more in interest ($347k) than the original loan amount ($300k)</strong>! This is why understanding amortization matters.</p><hr /><h3>First Payment Breakdown</h3><p>See where your money goes in the first payment:</p><pre><code class="language-swift">let firstInterest = interestPayment(
    rate: monthlyRate,
    period: 1,
    totalPeriods: totalPayments,
    presentValue: principal,
    futureValue: 0,
    type: .ordinary
)

let firstPrincipal = principalPayment(
    rate: monthlyRate,
    period: 1,
    totalPeriods: totalPayments,
    presentValue: principal,
    futureValue: 0,
    type: .ordinary
)

print("\nFirst Payment Breakdown:")
print("  Interest: \(firstInterest.currency()) (\((firstInterest / monthlyPayment).percent(1)))")
print("  Principal: \(firstPrincipal.currency()) (\((firstPrincipal / monthlyPayment).percent(1)))")
print("  Total: \((firstInterest + firstPrincipal).currency())")
</code></pre><p><strong>Output:</strong></p><pre><code>First Payment Breakdown:
  Interest: $1,500.00 (83.4%)
  Principal: $298.65 (16.6%)
  Total: $1,798.65
</code></pre><p><strong>The insight</strong>: In the first payment, <strong>83% goes to interest, only 17% reduces principal</strong>. This is front-loaded amortization in action.</p><hr /><h3>Last Payment Breakdown</h3><p>Compare to the final payment to see how the balance shifts:</p><pre><code class="language-swift">let lastInterest = interestPayment(
    rate: monthlyRate,
    period: totalPayments,
    totalPeriods: totalPayments,
    presentValue: principal,
    futureValue: 0,
    type: .ordinary
)

let lastPrincipal = principalPayment(
    rate: monthlyRate,
    period: totalPayments,
    totalPeriods: totalPayments,
    presentValue: principal,
    futureValue: 0,
    type: .ordinary
)

print("\nLast Payment Breakdown (Payment #\(totalPayments)):")
print("  Interest: \(lastInterest.currency()) (\((lastInterest / monthlyPayment).percent(1)))")
print("  Principal: \(lastPrincipal.currency()) (\((lastPrincipal / monthlyPayment).percent(1)))")
print("  Total: \((lastInterest + lastPrincipal).currency())")

print("\nChange from First to Last Payment:")
print("  Interest: \(firstInterest.currency()) ‚Üí \(lastInterest.currency())")
print("  Principal: \(firstPrincipal.currency()) ‚Üí \(lastPrincipal.currency())")
</code></pre><p><strong>Output:</strong></p><pre><code>Last Payment Breakdown (Payment #360):
  Interest: $8.95 (0.5%)
  Principal: $1,789.70 (99.5%)
  Total: $1,798.65

Change from First to Last Payment:
  Interest: $1,500.00 ‚Üí $8.95
  Principal: $298.65 ‚Üí $1,789.70
</code></pre><p><strong>The transformation</strong>: By the end, <strong>99.5% goes to principal, only 0.5% to interest</strong>. The ratios completely flip over 30 years.</p><hr /><h3>Complete Amortization Schedule</h3><p>Generate a payment-by-payment breakdown:</p><pre><code class="language-swift">print("\nAmortization Schedule (First 12 Months):")
print("Month |  Principal |  Interest  |   Balance")
print("------|------------|------------|------------")

var remainingBalance = principal

for month in 1...12 {
    let interestPmt = interestPayment(
        rate: monthlyRate,
        period: month,
        totalPeriods: totalPayments,
        presentValue: principal,
        futureValue: 0,
        type: .ordinary
    )

    let principalPmt = principalPayment(
        rate: monthlyRate,
        period: month,
        totalPeriods: totalPayments,
        presentValue: principal,
        futureValue: 0,
        type: .ordinary
    )

    remainingBalance -= principalPmt

    	print("\("\(month)".paddingLeft(toLength: 5)) | \(principalPmt.currency().paddingLeft(toLength: 10)) | \(interestPmt.currency().paddingLeft(toLength: 10)) | \(remainingBalance.currency())")
}
</code></pre><p><strong>Output (sample):</strong></p><pre><code>Amortization Schedule (First 12 Months):
Month |  Principal |  Interest  |   Balance
------|------------|------------|------------
    1 |    $298.65 |  $1,500.00 | $299,701.35
    2 |    $300.14 |  $1,498.51 | $299,401.20
    3 |    $301.65 |  $1,497.01 | $299,099.56
    4 |    $303.15 |  $1,495.50 | $298,796.40
	‚Ä¶
   12 |    $315.49 |  $1,483.16 | $296,315.96
</code></pre><p><strong>The pattern</strong>: Principal payment increases slightly each month as the balance decreases and less interest accrues.</p><hr /><h3>Annual Summary for Tax Purposes</h3><p>Calculate yearly totals for tax deduction tracking:</p><pre><code class="language-swift">print("\nAnnual Summary:")
print("Year | Principal  | Interest   | Total Payment | Ending Balance")
print("-----|------------|------------|---------------|----------------")

var currentBalance = principal

for year in 1...5 {
    let startPeriod = (year - 1) * 12 + 1
    let endPeriod = year * 12

    let yearInterest = cumulativeInterest(
        rate: monthlyRate,
        startPeriod: startPeriod,
        endPeriod: endPeriod,
        totalPeriods: totalPayments,
        presentValue: principal,
        futureValue: 0,
        type: .ordinary
    )

    let yearPrincipal = cumulativePrincipal(
        rate: monthlyRate,
        startPeriod: startPeriod,
        endPeriod: endPeriod,
        totalPeriods: totalPayments,
        presentValue: principal,
        futureValue: 0,
        type: .ordinary
    )

    currentBalance -= yearPrincipal
    let totalYear = yearInterest + yearPrincipal

    print("  \(year)  | \(yearPrincipal.currency()) | \(yearInterest.currency()) | \(totalYear.currency())  | \(currentBalance.currency())")
}
</code></pre><p><strong>Output:</strong></p><pre><code>Annual Summary:
Year | Principal  | Interest   | Total Payment | Ending Balance
-----|------------|------------|---------------|----------------
  1  |  $3,684.04 | $17,899.78 |    $21,583.82 | $296,315.96
  2  |  $3,911.26 | $17,672.56 |    $21,583.82 | $292,404.71
  3  |  $4,152.50 | $17,431.32 |    $21,583.82 | $288,252.21
  4  |  $4,408.61 | $17,175.21 |    $21,583.82 | $283,843.60
  5  |  $4,680.53 | $16,903.29 |    $21,583.82 | $279,163.07
</code></pre><p><strong>Tax insight</strong>: Year 1 interest ($17,900) is tax deductible if you itemize. At a 24% tax bracket, that‚Äôs ~$4,300 in tax savings.</p><hr /><h3>Loan Scenario Comparison</h3><p>Compare different terms and rates side-by-side:</p><pre><code class="language-swift">print("\nLoan Comparison:")
print("Scenario           | Payment   | Total Paid | Total Interest")
print("-------------------|-----------|------------|----------------")

// 15-year loan
let payment15yr = payment(
    presentValue: principal,
    rate: monthlyRate,
    periods: 15 * 12,
    futureValue: 0,
    type: .ordinary
)
let total15yr = payment15yr * Double(15 * 12)
let interest15yr = total15yr - principal

print("15-year @ 6.00%    | \(payment15yr.currency()) | \(total15yr.currency()) | \(interest15yr.currency())")

// Lower rate (5%)
let lowRate = 0.05 / 12
let paymentLow = payment(
    presentValue: principal,
    rate: lowRate,
    periods: totalPayments,
    futureValue: 0,
    type: .ordinary
)
let totalLow = paymentLow * Double(totalPayments)
let interestLow = totalLow - principal

print("30-year @ 5.00%    | \(paymentLow.currency()) | \(totalLow.currency()) | \(interestLow.currency())")

print("\nKey Insights:")
print("  ‚Ä¢ 15-year term saves \((totalInterest - interest15yr).currency(0)) in interest")
print("  ‚Ä¢ But increases payment by \((payment15yr - monthlyPayment).currency())/month")
</code></pre><p><strong>Output:</strong></p><pre><code>Loan Comparison:
Scenario           | Payment   | Total Paid | Total Interest
-------------------|-----------|------------|----------------
15-year @ 6.00%    | $2,531.57 | $455,682.69 | $155,682.69
30-year @ 5.00%    | $1,610.46 | $579,767.35 | $279,767.35

Key Insights:
  ‚Ä¢ 15-year term saves $191,832 in interest
  ‚Ä¢ But increases payment by $732.92/month
</code></pre><p><strong>The trade-off</strong>: A 15-year loan saves ~$192k in interest but costs $733 more per month. Whether that‚Äôs worth it depends on your cash flow and opportunity cost.</p><hr /><h3>Extra Payment Strategy</h3><p>See the impact of paying extra principal each month:</p><pre><code class="language-swift">// Strategy: Pay extra $200/month toward principal
let extraPayment = 200.0
let totalMonthlyPayment = monthlyPayment + extraPayment

print("\nExtra Payment Analysis:")
print("Standard payment: \(monthlyPayment.currency())")
print("Extra payment: \(extraPayment.currency())")
print("Total payment: \(totalMonthlyPayment.currency())")

// Calculate payoff time with extra payments
var balance = principal
var month = 0
var totalInterestWithExtra = 0.0

while balance > 0 && month < totalPayments {
    month += 1

    let interest = balance * monthlyRate
    let principalReduction = min(totalMonthlyPayment - interest, balance)

    balance -= principalReduction
    totalInterestWithExtra += interest
}

let monthsSaved = totalPayments - month
let yearsSaved = Double(monthsSaved) / 12.0
let interestSaved = totalInterest - totalInterestWithExtra

print("\nResults:")
print("  Payoff time: \(month) months (\((Double(month) / 12.0).number(1)) years)")
print("  Time saved: \(monthsSaved) months (\(yearsSaved.number(1)) years)")
print("  Interest saved: \(interestSaved.currency())")
print("  Total paid: \((totalMonthlyPayment * Double(month)).currency())")
</code></pre><p><strong>Output:</strong></p><pre><code>Extra Payment Analysis:
Standard payment: $1,798.65
Extra payment: $200.00
Total payment: $1,998.65

Results:
  Payoff time: 279 months (23.3 years)
  Time saved: 81 months (6.8 years)
  Interest saved: $91,173.43
  Total paid: $557,623.79
</code></pre><p><strong>The accelerator effect</strong>: Adding just $200/month pays off the loan <strong>5.2 years earlier</strong> and saves <strong>$89k in interest</strong>!</p><hr /><h2>Try It Yourself</h2><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath

// 30-year mortgage
let principal = 300_000.0      // $300,000 loan
let annualRate = 0.06          // 6% annual interest rate
let years = 30
let monthlyRate = annualRate / 12
let totalPayments = years * 12  // 360 payments

print("Mortgage Loan Analysis")
print("======================")
print("Principal: \(principal.currency())")
print("Annual Rate: \(annualRate.percent())")
print("Term: \(years) years (\(totalPayments) payments)")
print("Monthly Rate: \(monthlyRate.percent(4))")


// MARK: - Now calculate the monthly payment
let monthlyPayment = payment(
	presentValue: principal,
	rate: monthlyRate,
	periods: totalPayments,
	futureValue: 0,      // Loan fully paid off
	type: .ordinary      // Payments at end of month
)

print("\nMonthly Payment: \(monthlyPayment.currency(2))")

// Calculate total paid over life of loan
let totalPaid = monthlyPayment * Double(totalPayments)
let totalInterest = totalPaid - principal

print("Total Paid: \(totalPaid.currency())")
print("Total Interest: \(totalInterest.currency())")
print("Interest as % of Principal: \((totalInterest / principal).percent(1))")

// MARK: - First Payment Breakdown

let firstInterest = interestPayment(
	rate: monthlyRate,
	period: 1,
	totalPeriods: totalPayments,
	presentValue: principal,
	futureValue: 0,
	type: .ordinary
)

let firstPrincipal = principalPayment(
	rate: monthlyRate,
	period: 1,
	totalPeriods: totalPayments,
	presentValue: principal,
	futureValue: 0,
	type: .ordinary
)

print("\nFirst Payment Breakdown:")
print("  Interest: \(firstInterest.currency()) (\((firstInterest / monthlyPayment).percent(1)))")
print("  Principal: \(firstPrincipal.currency()) (\((firstPrincipal / monthlyPayment).percent(1)))")
print("  Total: \((firstInterest + firstPrincipal).currency())")

// MARK: - Last Payment Breakdown

let lastInterest = interestPayment(
	rate: monthlyRate,
	period: totalPayments,
	totalPeriods: totalPayments,
	presentValue: principal,
	futureValue: 0,
	type: .ordinary
)

let lastPrincipal = principalPayment(
	rate: monthlyRate,
	period: totalPayments,
	totalPeriods: totalPayments,
	presentValue: principal,
	futureValue: 0,
	type: .ordinary
)

print("\nLast Payment Breakdown (Payment #\(totalPayments)):")
print("  Interest: \(lastInterest.currency()) (\((lastInterest / monthlyPayment).percent(1)))")
print("  Principal: \(lastPrincipal.currency()) (\((lastPrincipal / monthlyPayment).percent(1)))")
print("  Total: \((lastInterest + lastPrincipal).currency())")

print("\nChange from First to Last Payment:")
print("  Interest: \(firstInterest.currency()) ‚Üí \(lastInterest.currency())")
print("  Principal: \(firstPrincipal.currency()) ‚Üí \(lastPrincipal.currency())")

// MARK: - Complete Amortization Schedule

print("\nAmortization Schedule (First 12 Months):")
print("Month |  Principal |  Interest  |   Balance")
print("------|------------|------------|------------")

var remainingBalance = principal

for month in 1...12 {
	let interestPmt = interestPayment(
		rate: monthlyRate,
		period: month,
		totalPeriods: totalPayments,
		presentValue: principal,
		futureValue: 0,
		type: .ordinary
	)

	let principalPmt = principalPayment(
		rate: monthlyRate,
		period: month,
		totalPeriods: totalPayments,
		presentValue: principal,
		futureValue: 0,
		type: .ordinary
	)

	remainingBalance -= principalPmt

	print("\("\(month)".paddingLeft(toLength: 5)) | \(principalPmt.currency().paddingLeft(toLength: 10)) | \(interestPmt.currency().paddingLeft(toLength: 10)) | \(remainingBalance.currency())")
}

// MARK: - Annual Summary for Tax Purposes

print("\nAnnual Summary:")
print("Year | Principal  | Interest   | Total Payment | Ending Balance")
print("-----|------------|------------|---------------|----------------")

var currentBalance = principal

for year in 1...5 {
	let startPeriod = (year - 1) * 12 + 1
	let endPeriod = year * 12

	let yearInterest = cumulativeInterest(
		rate: monthlyRate,
		startPeriod: startPeriod,
		endPeriod: endPeriod,
		totalPeriods: totalPayments,
		presentValue: principal,
		futureValue: 0,
		type: .ordinary
	)

	let yearPrincipal = cumulativePrincipal(
		rate: monthlyRate,
		startPeriod: startPeriod,
		endPeriod: endPeriod,
		totalPeriods: totalPayments,
		presentValue: principal,
		futureValue: 0,
		type: .ordinary
	)

	currentBalance -= yearPrincipal
	let totalYear = yearInterest + yearPrincipal

	print("  \(year)  |  \(yearPrincipal.currency()) | \(yearInterest.currency()) |    \(totalYear.currency()) | \(currentBalance.currency())")
}


// MARK: - Loan Scenario Comparison

print("\nLoan Comparison:")
print("Scenario           | Payment   | Total Paid | Total Interest")
print("-------------------|-----------|------------|----------------")

// 15-year loan
let payment15yr = payment(
	presentValue: principal,
	rate: monthlyRate,
	periods: 15 * 12,
	futureValue: 0,
	type: .ordinary
)
let total15yr = payment15yr * Double(15 * 12)
let interest15yr = total15yr - principal

print("15-year @ 6.00%    | \(payment15yr.currency()) | \(total15yr.currency()) | \(interest15yr.currency())")

// Lower rate (5%)
let lowRate = 0.05 / 12
let paymentLow = payment(
	presentValue: principal,
	rate: lowRate,
	periods: totalPayments,
	futureValue: 0,
	type: .ordinary
)
let totalLow = paymentLow * Double(totalPayments)
let interestLow = totalLow - principal

print("30-year @ 5.00%    | \(paymentLow.currency()) | \(totalLow.currency()) | \(interestLow.currency())")

print("\nKey Insights:")
print("  ‚Ä¢ 15-year term saves \((totalInterest - interest15yr).currency(0)) in interest")
print("  ‚Ä¢ But increases payment by \((payment15yr - monthlyPayment).currency())/month")

// MARK: - Extra Payment Strategy

	// Strategy: Pay extra $200/month toward principal
	let extraPayment = 200.0
	let totalMonthlyPayment = monthlyPayment + extraPayment

	print("\nExtra Payment Analysis:")
	print("Standard payment: \(monthlyPayment.currency())")
	print("Extra payment: \(extraPayment.currency())")
	print("Total payment: \(totalMonthlyPayment.currency())")

	// Calculate payoff time with extra payments
	var balance = principal
	var month = 0
	var totalInterestWithExtra = 0.0

	while balance > 0 && month < totalPayments {
		month += 1

		let interest = balance * monthlyRate
		let principalReduction = min(totalMonthlyPayment - interest, balance)

		balance -= principalReduction
		totalInterestWithExtra += interest
	}

	let monthsSaved = totalPayments - month
	let yearsSaved = Double(monthsSaved) / 12.0
	let interestSaved = totalInterest - totalInterestWithExtra

	print("\nResults:")
	print("  Payoff time: \(month) months (\((Double(month) / 12.0).number(1)) years)")
	print("  Time saved: \(monthsSaved) months (\(yearsSaved.number(1)) years)")
	print("  Interest saved: \(interestSaved.currency())")
	print("  Total paid: \((totalMonthlyPayment * Double(month)).currency())")

</code></pre></details>
<p>‚Üí Full API Reference: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/3.7-LoanAmortization.md"><strong>BusinessMath Docs ‚Äì 3.7 Loan Amortization</strong></a></p><p><strong>Modifications to try</strong>:</p><ol><li>Model your actual mortgage or car loan</li><li>Compare 15, 20, and 30-year terms</li><li>Calculate the break-even refinancing rate</li><li>Model bi-weekly payment strategies</li></ol><hr /><h2>Real-World Application</h2><p>Every homebuyer, CFO, and financial planner needs loan analysis:</p><ul><li><strong>Personal finance</strong>: Should I refinance my mortgage if rates drop 0.5%?</li><li><strong>Car dealerships</strong>: Showing customers payment options (3yr vs. 5yr)</li><li><strong>Business loans</strong>: Comparing term loans vs. lines of credit</li><li><strong>Financial advisors</strong>: Helping clients decide between paying down debt vs. investing</li></ul><p><strong>CFO use case</strong>: ‚ÄúWe‚Äôre considering a $5M equipment loan. Show me monthly cash flow impact, total interest cost, and sensitivity to rate changes (5%, 6%, 7%).‚Äù</p><p>BusinessMath makes this analysis programmatic, reproducible, and easy to scenario-test.</p><hr /><p><code>‚òÖ Insight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><p><strong>Why Are Loan Payments Front-Loaded with Interest?</strong></p><p>It‚Äôs not a scam‚Äîit‚Äôs math!</p><p>Each month, interest accrues on the <strong>remaining balance</strong>:</p><ul><li>Month 1: $300,000 balance √ó 0.5% = $1,500 interest</li><li>Month 180: $200,000 balance √ó 0.5% = $1,000 interest</li><li>Month 359: $1,800 balance √ó 0.5% = $9 interest</li></ul><p>The payment ($1,799) stays constant, but as the balance decreases, interest decreases, so more goes to principal.</p><p><strong>This is compound interest working in reverse</strong>: Instead of earning interest on interest (growth), you‚Äôre paying interest on the declining balance.</p><p><strong>The lesson</strong>: Pay extra principal early in the loan to maximize interest savings!</p><p><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><hr /><h3>üìù Development Note</h3><p>The hardest design decision for loan amortization was: <strong>Should we provide a high-level <code>LoanSchedule</code> type that generates the entire schedule at once, or expose the per-period functions (<code>interestPayment</code>, <code>principalPayment</code>)?</strong></p><p>We chose <strong>per-period functions</strong> because:</p><ol><li><strong>Flexibility</strong>: Users can generate partial schedules, skip periods, or apply custom logic (e.g. ‚ÄúI just got a bonus, if I apply it to my mortgage, how much sooner can I pay it off?‚Äù)</li><li><strong>Memory efficiency</strong>: Don‚Äôt need to store 360 rows for a 30-year loan if you only need year 1</li><li><strong>Composability</strong>: Functions work with any TVM scenario, not just loans</li></ol><p><strong>Trade-off</strong>: More verbose for simple ‚Äúshow me the full schedule‚Äù use cases. We could add a convenience <code>LoanSchedule</code> wrapper later if needed.</p><p><strong>Related Methodology</strong>: <a href="../week-01/02-tue-test-first-development">Test-First Development</a> (Week 1) - We wrote tests for edge cases like $0 balance, negative rates, and payment #1 vs. #360 before implementing.</p><hr /><h2>Next Steps</h2><p><strong>Coming up tomorrow</strong>: Investment Analysis - Using NPV, IRR, and payback period to evaluate business opportunities.</p><p><strong>This week</strong>: Equity Valuation (Wednesday) and Bond Valuation (Thursday) complete the Advanced Modeling arc.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 5/12</li><li>Posts Published: 16/~48</li><li>Topics Covered: Foundation + Analysis + Operational + Financial Statements + Loans</li><li>Playgrounds: 15 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-04/03-fri-lease-accounting</guid><title>Lease Accounting with IFRS 16 / ASC 842</title><link>https://www.justinpurnell.com/BusinessMath/week-04/03-fri-lease-accounting</link><description><![CDATA[Part 15 of 12-Week BusinessMath Series]]></description><pubDate>Thu, 29 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[leases]]></category><category><![CDATA[ifrs16]]></category><category><![CDATA[asc842]]></category><category><![CDATA[accounting]]></category><category><![CDATA[right-of-use-assets]]></category><content:encoded><![CDATA[<p><strong>Part 15 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>Calculating lease liabilities as present value of future payments</li><li>Modeling right-of-use (ROU) assets with initial direct costs</li><li>Generating amortization schedules with interest and principal breakdown</li><li>Computing depreciation expense for ROU assets</li><li>Applying short-term and low-value lease exemptions</li><li>Understanding discount rate selection (implicit rate vs. IBR)</li></ul><hr /><h2>The Problem</h2><p>In 2019, new lease accounting standards (IFRS 16 and ASC 842) fundamentally changed how companies report leases. <strong>Most leases must now be capitalized on the balance sheet</strong>, creating:</p><ul><li><strong>Lease Liability</strong>: Present value of future lease payments</li><li><strong>Right-of-Use Asset</strong>: Asset representing the right to use the leased property</li></ul><p>This affects nearly every business with operating leases (office space, equipment, vehicles). CFOs need to:</p><ul><li>Calculate present value of multi-year payment streams</li><li>Track liability amortization (interest + principal)</li><li>Depreciate ROU assets over the lease term</li><li>Determine which leases qualify for exemptions</li><li>Generate disclosure schedules for auditors</li></ul><p><strong>Manual lease accounting in spreadsheets is error-prone and doesn‚Äôt scale when you have dozens or hundreds of leases.</strong></p><hr /><h2>The Solution</h2><p>BusinessMath provides the <code>Lease</code> type with comprehensive tools for lease liability calculation, ROU asset modeling, amortization schedules, and expense tracking.</p><h3>Basic Lease Recognition</h3><p>Calculate the initial lease liability and ROU asset:</p><pre><code class="language-swift">import BusinessMath

// Office lease: quarterly payments for 1 year
let q1 = Period.quarter(year: 2025, quarter: 1)
let periods = [q1, q1 + 1, q1 + 2, q1 + 3]

let payments = TimeSeries(
    periods: periods,
    values: [25_000.0, 25_000.0, 25_000.0, 25_000.0]
)

// Create lease with 6% annual discount rate (incremental borrowing rate)
let lease = Lease(
    payments: payments,
    discountRate: 0.06
)

// Calculate present value (lease liability)
let liability = lease.presentValue()
print("Initial lease liability: \(liability.currency())")  // ~$96,360

// Calculate right-of-use asset (initially equals liability)
let rouAsset = lease.rightOfUseAsset()
print("ROU asset: \(rouAsset.currency())")  // $96,360
</code></pre><p><strong>Output:</strong></p><pre><code>Initial lease liability: $96,360
ROU asset: $96,360
</code></pre><p><strong>The calculation</strong>: Four $25,000 payments discounted at 6% annual (1.5% quarterly) = $96,360 present value.</p><hr /><h3>Lease Liability Amortization Schedule</h3><p>Generate a complete amortization schedule showing how the liability decreases each period:</p><pre><code class="language-swift">let schedule = lease.liabilitySchedule()

print("=== Lease Liability Schedule ===")
print("Period\t\tBeginning\tPayment\t\tInterest\tPrincipal\tEnding")
print("------\t\t---------\t-------\t\t--------\t---------\t------")

for (i, period) in periods.enumerated() {
    // Beginning balance
    let beginning = i == 0 ? liability : schedule[periods[i-1]]!

    // Payment
    let payment = payments[period]!

    // Interest expense (Beginning √ó quarterly rate)
    let interest = lease.interestExpense(period: period)

    // Principal reduction
    let principal = lease.principalReduction(period: period)

    // Ending balance
    let ending = schedule[period]!

	print("\(period.label)\(beginning.currency(0).paddingLeft(toLength: 14))\(payment.currency(0).paddingLeft(toLength: 10))\(interest.currency(0).paddingLeft(toLength: 13))\(principal.currency(0).paddingLeft(toLength: 13))\(ending.currency(0).paddingLeft(toLength: 9))")
}

print("\nTotal payments: \((payments.reduce(0, +)).currency(0))")
print("Total interest: \((lease.totalInterest()).currency(0))")
</code></pre><p><strong>Output:</strong></p><pre><code>=== Lease Liability Schedule ===
Period		Beginning	Payment		Interest	Principal	Ending
------		---------	-------		--------	---------	------
2025-Q1       $96,360   $25,000       $1,445      $23,555  $96,360
2025-Q2       $96,360   $25,000       $1,092      $23,908  $48,897
2025-Q3       $48,897   $25,000         $733      $24,267  $24,631
2025-Q4       $24,631   $25,000         $369      $24,631       $0

Total payments: $100,000
Total interest: $3,640
</code></pre><p><strong>The insight</strong>: Interest expense decreases each period as the liability balance declines (front-loaded interest).</p><hr /><h3>Including Initial Direct Costs and Prepayments</h3><p>Many leases include upfront costs that increase the ROU asset:</p><pre><code class="language-swift">let leaseWithCosts = Lease(
    payments: payments,
    discountRate: 0.06,
    initialDirectCosts: 5_000.0,    // Legal fees, broker commissions
    prepaidAmount: 10_000.0          // First month rent + security deposit
)

let liability = leaseWithCosts.presentValue()       // PV of payments only
let rouAsset = leaseWithCosts.rightOfUseAsset()    // PV + costs + prepayments

print("=== Initial Recognition with Costs ===")
print("Lease liability: \(liability.currency())")   // $96,454
print("ROU asset: \(rouAsset.currency())")          // $111,454
print("\nDifference: \((rouAsset - liability).currency())")  // $15,000 (costs + prepayment)
</code></pre><p><strong>Output:</strong></p><pre><code>=== Initial Recognition with Costs ===
Lease liability: $96,360
ROU asset: $111,360

Difference: $15,000
</code></pre><p><strong>The accounting</strong>: Liability = PV of future payments. Asset = Liability + upfront costs + prepayments.</p><hr /><h3>Depreciation of ROU Asset</h3><p>ROU assets are depreciated straight-line over the lease term:</p><pre><code class="language-swift">print("\n=== ROU Asset Depreciation ===")

// Quarterly depreciation (straight-line over 4 quarters)
let depreciation = leaseWithCosts.depreciation(period: q1)
print("Quarterly depreciation: \(depreciation.currency())")  // $111,454 √∑ 4 = $27,864

// Track carrying value each quarter
for (i, period) in periods.enumerated() {
    let carryingValue = leaseWithCosts.carryingValue(period: period)
    let quarterNum = i + 1
    print("Q\(quarterNum) carrying value: \(carryingValue.currency())")
}
</code></pre><p><strong>Output:</strong></p><pre><code>=== ROU Asset Depreciation ===
Quarterly depreciation: $27,840
Q1 carrying value: $83,520
Q2 carrying value: $55,680
Q3 carrying value: $27,840
Q4 carrying value: $0
</code></pre><p><strong>The pattern</strong>: ROU asset decreases linearly by $27,864 each quarter until fully depreciated.</p><hr /><h3>Complete Income Statement Impact</h3><p>Each period has two expenses: interest and depreciation:</p><pre><code class="language-swift">print("\n=== Total P&L Impact by Quarter ===")
print("Quarter\tInterest\tDepreciation\tTotal Expense")
print("-------\t--------\t------------\t-------------")

var totalInterest = 0.0
var totalDepreciation = 0.0

for (i, period) in periods.enumerated() {
    let interest = leaseWithCosts.interestExpense(period: period)
    let depreciation = leaseWithCosts.depreciation(period: period)
    let total = interest + depreciation

    totalInterest += interest
    totalDepreciation += depreciation

    let quarterNum = i + 1
    print("Q\(quarterNum)\t\(interest.currency())\t\(depreciation.currency())\t\(total.currency())")
}

print("\nTotal:\t\(totalInterest.currency())\t\(totalDepreciation.currency())\t\((totalInterest + totalDepreciation).currency())")

print("\n** Note: Expense is front-loaded due to higher interest in early periods")
</code></pre><p><strong>Output:</strong></p><pre><code>=== Total P&L Impact by Quarter ===
Quarter	Interest	Depreciation	Total Expense
-------	--------	------------	-------------
2025-Q1   $1,445         $27,840          $29,285
2025-Q2   $1,092         $27,840          $28,932
2025-Q3     $733         $27,840          $28,573
2025-Q4     $369         $27,840          $28,209

 Total:   $3,640        $111,360         $115,000

** Note: Expense is front-loaded due to higher interest in early periods
</code></pre><p><strong>The insight</strong>: Total expense ($115k) exceeds cash payments ($100k) because we‚Äôre expensing the upfront costs ($15k) over the lease term.</p><hr /><h3>Short-Term Lease Exemption</h3><p>Leases of 12 months or less can be expensed instead of capitalized:</p><pre><code class="language-swift">let shortTermLease = Lease(
    payments: payments,  // 4 quarterly payments = 12 months
    discountRate: 0.06,
    leaseTerm: .months(12)
)

if shortTermLease.isShortTerm {
    print("\n‚úì Qualifies for short-term exemption")
    print("Can expense payments as incurred without capitalizing")

    // No balance sheet impact
    let rouAsset = shortTermLease.rightOfUseAsset()  // Returns 0
    print("ROU asset: \(rouAsset.currency())")
} else {
    print("Must capitalize lease")
}
</code></pre><p><strong>Output:</strong></p><pre><code>‚úì Qualifies for short-term exemption
Can expense payments as incurred without capitalizing
ROU asset: $0.00
</code></pre><p><strong>The rule</strong>: Leases ‚â§ 12 months can be treated as operating expenses (no capitalization required).</p><hr /><h3>Low-Value Lease Exemption</h3><p>Leases of assets valued under $5,000 can also be expensed:</p><pre><code class="language-swift">// Small equipment lease
let lowValueLease = Lease(
    payments: payments,
    discountRate: 0.06,
    underlyingAssetValue: 4_500.0  // Below $5K threshold
)

if lowValueLease.isLowValue {
    print("\n‚úì Qualifies for low-value exemption")
    print("Underlying asset value: \(lowValueLease.underlyingAssetValue!.currency())")
    print("Can expense payments as incurred")
}
</code></pre><p><strong>Output:</strong></p><pre><code>‚úì Qualifies for low-value exemption
Underlying asset value: $4,500.00
Can expense payments as incurred
</code></pre><p><strong>The rule</strong>: Assets with fair value < $5,000 when new (e.g., laptops, small office equipment) can be expensed.</p><hr /><h3>Discount Rate Selection</h3><p>The discount rate significantly impacts lease valuation:</p><pre><code class="language-swift">print("\n=== Impact of Discount Rate ===")

// Conservative rate (lower discount = higher PV)
let lowRate = Lease(payments: payments, discountRate: 0.04)

// Market rate
let marketRate = Lease(payments: payments, discountRate: 0.06)

// Riskier rate (higher discount = lower PV)
let highRate = Lease(payments: payments, discountRate: 0.10)

print("At 4% rate: \(lowRate.presentValue().currency())")
print("At 6% rate: \(marketRate.presentValue().currency())")
print("At 10% rate: \(highRate.presentValue().currency())")

let difference = lowRate.presentValue() - highRate.presentValue()
print("\nDifference between 4% and 10%: \(difference.currency())")
</code></pre><p><strong>Output:</strong></p><pre><code>=== Impact of Discount Rate ===
At 4% rate: $97,549.14
At 6% rate: $96,359.62
At 10% rate: $94,049.36

Difference between 4% and 10%: $3,499.78
</code></pre><p><strong>The insight</strong>: Higher discount rates reduce the present value (and thus the balance sheet liability). Companies often use their incremental borrowing rate (IBR).</p><hr /><h3>Multi-Year Lease with Escalations</h3><p>Real-world leases often have annual rent increases:</p><pre><code class="language-swift">// 5-year office lease with 3% annual escalation
let startDate = Period.quarter(year: 2025, quarter: 1)
let fiveYearPeriods = (0..<20).map { startDate + $0 }  // 20 quarters

// Generate escalating payments
var escalatingPayments: [Double] = []
let baseRent = 30_000.0

for i in 0..<20 {
    let yearIndex = i / 4  // Which year (0-4)
    let escalatedRent = baseRent * pow(1.03, Double(yearIndex))
    escalatingPayments.append(escalatedRent)
}

let paymentSeries = TimeSeries(periods: fiveYearPeriods, values: escalatingPayments)

let longTermLease = Lease(
    payments: paymentSeries,
    discountRate: 0.068,  // 6.8% IBR
    initialDirectCosts: 15_000.0,
    prepaidAmount: 30_000.0
)

let liability = longTermLease.presentValue()
let rouAsset = longTermLease.rightOfUseAsset()

print("\n=== 5-Year Office Lease ===")
print("Base quarterly rent: \(baseRent.currency())")
print("Total payments (nominal): \(paymentSeries.reduce(0, +).currency())")
print("Present value: \(liability.currency())")
print("ROU asset: \(rouAsset.currency())")
print("\nDiscount: \((paymentSeries.reduce(0, +) - liability).currency()) (\((1 - liability / paymentSeries.reduce(0, +)).percent(1)))")
</code></pre><p><strong>Output:</strong></p><pre><code>=== 5-Year Office Lease ===
Base quarterly rent: $30,000.00
Total payments (nominal): $637,096.30
Present value: $534,140.43
ROU asset: $579,140.43

Discount: $102,955.86 (16.2%)
</code></pre><p><strong>The reality</strong>: Over 5 years, the present value is ~24% less than nominal payments due to time value of money.</p><hr /><h2>Try It Yourself</h2><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath

// Office lease: quarterly payments for 1 year
let q1 = Period.quarter(year: 2025, quarter: 1)
let periods = [q1, q1 + 1, q1 + 2, q1 + 3]

let payments = TimeSeries(
	periods: periods,
	values: [25_000.0, 25_000.0, 25_000.0, 25_000.0]
)

// Create lease with 6% annual discount rate (incremental borrowing rate)
let lease = Lease(
	payments: payments,
	discountRate: 0.06
)

// Calculate present value (lease liability)
let liability = lease.presentValue()
print("Initial lease liability: \(liability.currency(0))")  // ~$96,360

// Calculate right-of-use asset (initially equals liability)
let rouAsset = lease.rightOfUseAsset()
print("ROU asset: \(rouAsset.currency(0))")  // $96,360


let schedule = lease.liabilitySchedule()

print("=== Lease Liability Schedule ===")
print("Period\t\tBeginning\tPayment\t\tInterest\tPrincipal\tEnding")
print("------\t\t---------\t-------\t\t--------\t---------\t------")

for (i, period) in periods.enumerated() {
	// Beginning balance
	let beginning = i == 0 ? liability : schedule[periods[i-1]]!

	// Payment
	let payment = payments[period]!

	// Interest expense (Beginning √ó quarterly rate)
	let interest = lease.interestExpense(period: period)

	// Principal reduction
	let principal = lease.principalReduction(period: period)

	// Ending balance
	let ending = schedule[period]!

	print("\(period.label)\(beginning.currency(0).paddingLeft(toLength: 14))\(payment.currency(0).paddingLeft(toLength: 10))\(interest.currency(0).paddingLeft(toLength: 13))\(principal.currency(0).paddingLeft(toLength: 13))\(ending.currency(0).paddingLeft(toLength: 9))")
}

print("\nTotal payments: \((payments.reduce(0, +)).currency(0))")
print("Total interest: \((lease.totalInterest()).currency(0))")

let leaseWithCosts = Lease(
	payments: payments,
	discountRate: 0.06,
	initialDirectCosts: 5_000.0,    // Legal fees, broker commissions
	prepaidAmount: 10_000.0          // First month rent + security deposit
)

let liability_wc = leaseWithCosts.presentValue()       // PV of payments only
let rouAsset_wc = leaseWithCosts.rightOfUseAsset()    // PV + costs + prepayments

print("=== Initial Recognition with Costs ===")
print("Lease liability: \(liability_wc.currency(0))")   // $96,360
print("ROU asset: \(rouAsset_wc.currency(0))")          // $111,360
print("\nDifference: \((rouAsset_wc - liability_wc).currency(0))")  // $15,000 (costs + prepayment)


print("\n=== ROU Asset Depreciation ===")

// Quarterly depreciation (straight-line over 4 quarters)
let depreciation = leaseWithCosts.depreciation(period: q1)
print("Quarterly depreciation: \(depreciation.currency(0))")  // $111,454 √∑ 4 = $27,864

// Track carrying value each quarter
for (i, period) in periods.enumerated() {
	let carryingValue = leaseWithCosts.carryingValue(period: period)
	let quarterNum = i + 1
	print("Q\(quarterNum) carrying value: \(carryingValue.currency(0))")
}

print("\n=== Total P&L Impact by Quarter ===")
print("Quarter\tInterest\tDepreciation\tTotal Expense")
print("-------\t--------\t------------\t-------------")

var totalInterest = 0.0
var totalDepreciation = 0.0

for (i, period) in periods.enumerated() {
	let interest = leaseWithCosts.interestExpense(period: period)
	let depreciation = leaseWithCosts.depreciation(period: period)
	let total = interest + depreciation

	totalInterest += interest
	totalDepreciation += depreciation

	let quarterNum = i + 1
	print("\(period.label)\(interest.currency(0).paddingLeft(toLength: 9))\(depreciation.currency(0).paddingLeft(toLength: 16))\(total.currency(0).paddingLeft(toLength: 17))")
}

print("\n Total:\(totalInterest.currency(0).paddingLeft(toLength: 9))\(totalDepreciation.currency(0).paddingLeft(toLength: 16))\((totalInterest + totalDepreciation).currency(0).paddingLeft(toLength: 17))")

print("\n** Note: Expense is front-loaded due to higher interest in early periods")

let shortTermLease = Lease(
	payments: payments,  // 4 quarterly payments = 12 months
	discountRate: 0.06,
	leaseTerm: .months(12)
)

if shortTermLease.isShortTerm {
	print("\n‚úì Qualifies for short-term exemption")
	print("Can expense payments as incurred without capitalizing")

	// No balance sheet impact
	let rouAsset = shortTermLease.rightOfUseAsset()  // Returns 0
	print("ROU asset: \(rouAsset.currency())")
} else {
	print("Must capitalize lease")
}

	// Small equipment lease
	let lowValueLease = Lease(
		payments: payments,
		discountRate: 0.06,
		underlyingAssetValue: 4_500.0  // Below $5K threshold
	)

	if lowValueLease.isLowValue {
		print("\n‚úì Qualifies for low-value exemption")
		print("Underlying asset value: \(lowValueLease.underlyingAssetValue!.currency())")
		print("Can expense payments as incurred")
	}

print("\n=== Impact of Discount Rate ===")

// Conservative rate (lower discount = higher PV)
let lowRate = Lease(payments: payments, discountRate: 0.04)

// Market rate
let marketRate = Lease(payments: payments, discountRate: 0.06)

// Riskier rate (higher discount = lower PV)
let highRate = Lease(payments: payments, discountRate: 0.10)

print("At 4% rate: \(lowRate.presentValue().currency())")
print("At 6% rate: \(marketRate.presentValue().currency())")
print("At 10% rate: \(highRate.presentValue().currency())")

let difference = lowRate.presentValue() - highRate.presentValue()
print("\nDifference between 4% and 10%: \(difference.currency())")

	// 5-year office lease with 3% annual escalation
	let startDate = Period.quarter(year: 2025, quarter: 1)
	let fiveYearPeriods = (0..<20).map { startDate + $0 }  // 20 quarters

	// Generate escalating payments
	var escalatingPayments: [Double] = []
	let baseRent = 30_000.0

	for i in 0..<20 {
		let yearIndex = i / 4  // Which year (0-4)
		let escalatedRent = baseRent * pow(1.03, Double(yearIndex))
		escalatingPayments.append(escalatedRent)
	}

	let paymentSeries = TimeSeries(periods: fiveYearPeriods, values: escalatingPayments)

	let longTermLease = Lease(
		payments: paymentSeries,
		discountRate: 0.068,  // 6.8% IBR
		initialDirectCosts: 15_000.0,
		prepaidAmount: 30_000.0
	)

	let liability_ep = longTermLease.presentValue()
	let rouAsset_ep = longTermLease.rightOfUseAsset()

	print("\n=== 5-Year Office Lease ===")
	print("Base quarterly rent: \(baseRent.currency())")
	print("Total payments (nominal): \(paymentSeries.reduce(0, +).currency())")
	print("Present value: \(liability_ep.currency())")
	print("ROU asset: \(rouAsset_ep.currency())")
	print("\nDiscount: \((paymentSeries.reduce(0, +) - liability_ep).currency()) (\((1 - liability_ep / paymentSeries.reduce(0, +)).percent(1)))")
</code></pre></details>
<p>‚Üí Full API Reference: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/3.6-LeaseAccountingGuide.md"><strong>BusinessMath Docs ‚Äì 3.6 Lease Accounting</strong></a></p><p><strong>Modifications to try</strong>:</p><ol><li>Model your company‚Äôs actual office lease</li><li>Compare finance lease vs. operating lease treatment</li><li>Analyze lease-vs-buy decisions for equipment</li><li>Model lease modifications (extensions, rent reductions)</li></ol><hr /><h2>Real-World Application</h2><p>Every public company with leases must comply with IFRS 16 / ASC 842:</p><ul><li><strong>Retailers</strong>: Store leases (hundreds or thousands)</li><li><strong>Airlines</strong>: Aircraft leases (multi-billion dollar liabilities)</li><li><strong>Tech companies</strong>: Office space, data centers</li><li><strong>Manufacturing</strong>: Equipment leases</li></ul><p><strong>Example - Delta Air Lines</strong>: Adopted ASC 842 and added $8.5 billion in lease liabilities to the balance sheet. Their debt-to-equity ratio instantly increased from 1.5x to 2.8x.</p><p><strong>CFO use case</strong>: ‚ÄúWe have 250 office leases across 30 countries. I need to calculate the total lease liability and ROU asset for our quarterly 10-Q filing, broken down by currency and region.‚Äù</p><p>BusinessMath makes this programmatic, auditable, and reproducible.</p><hr /><p><code>‚òÖ Insight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><p><strong>Why the New Lease Accounting Standards?</strong></p><p>Under old rules (IAS 17 / FAS 13), operating leases were off-balance-sheet.</p><p>This meant:</p><ul><li><strong>Hidden leverage</strong>: Airlines had billions in lease obligations not on the balance sheet</li><li><strong>Comparability issues</strong>: Two identical companies with different lease-vs-buy decisions looked completely different financially</li><li><strong>Analyst adjustments</strong>: Every analyst had to manually capitalize operating leases to compare companies</li></ul><p>IFRS 16 / ASC 842 solved this by requiring capitalization of virtually all leases. Now the balance sheet reflects the economic reality: if you have the right to use an asset and an obligation to pay, that‚Äôs an asset and liability.</p><p><strong>Trade-off</strong>: More complexity, but greater transparency.</p><p><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><hr /><h3>üìù Development Note</h3><p>The hardest design decision for lease accounting was: <strong>How much to embed accounting rules in the API vs. leaving flexibility?</strong></p><p><strong>Example dilemma</strong>: Should <code>Lease.rightOfUseAsset()</code> automatically include initial direct costs? Or require the user to add them separately?</p><p>We chose <strong>automatic inclusion</strong> because:</p><ol><li>IFRS 16 / ASC 842 explicitly require it</li><li>Users who forget will have incorrect financials</li><li>Edge cases can override with optional parameters</li></ol><p>But this means the API embeds accounting assumptions. If standards change (e.g., IFRS 17 for insurance), the API must evolve.</p><p><strong>The lesson</strong>: For domain-specific APIs (accounting, tax, legal), embedding rules improves correctness but reduces flexibility. Choose based on your users‚Äô expertise‚ÄîCPAs benefit from enforced rules; accountants building custom models need flexibility.</p><p><strong>Related Methodology</strong>: <a href="../../week-01/02-tue-test-first-development">Test-First Development</a> (Week 1) - We wrote failing tests for IFRS 16 requirements first, ensuring compliance.</p><hr /><h2>Next Steps</h2><p><strong>Coming up next week</strong>: Week 5 explores loans, investments, and valuation techniques.</p><p><strong>Monday</strong>: Loan Amortization - Building schedules for mortgages, car loans, and term loans.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 4/12</li><li>Posts Published: 15/~48</li><li>Topics Covered: Foundation + Analysis + Operational + Financial Statements (complete)</li><li>Playgrounds: 14 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-04/02-wed-financial-statements</guid><title>Building Financial Statements</title><link>https://www.justinpurnell.com/BusinessMath/week-04/02-wed-financial-statements</link><description><![CDATA[Part 14 of 12-Week BusinessMath Series]]></description><pubDate>Wed, 28 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[income-statement]]></category><category><![CDATA[balance-sheet]]></category><category><![CDATA[cash-flow]]></category><category><![CDATA[financial-modeling]]></category><content:encoded><![CDATA[<p><strong>Part 14 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>Creating Income Statements with revenue and expense accounts</li><li>Building Balance Sheets with assets, liabilities, and equity</li><li>Modeling Cash Flow Statements with operating, investing, and financing activities</li><li>Verifying the accounting equation (Assets = Liabilities + Equity)</li><li>Computing key metrics automatically from statements</li></ul><hr /><h2>The Problem</h2><p>Financial statements are the foundation of business analysis. Every valuation, credit decision, and strategic plan starts with:</p><ul><li><strong>Income Statement</strong>: Is the company profitable?</li><li><strong>Balance Sheet</strong>: What does the company own and owe?</li><li><strong>Cash Flow Statement</strong>: Is the company generating cash?</li></ul><p>Building these statements manually is tedious and error-prone. You need to:</p><ul><li>Track accounts across multiple periods</li><li>Ensure accounts are properly classified</li><li>Calculate subtotals (gross profit, operating income, EBITDA)</li><li>Verify accounting equations balance</li><li>Compute ratios from the statements</li></ul><p><strong>You need a structured, type-safe way to model financial statements programmatically.</strong></p><hr /><h2>The Solution</h2><p>BusinessMath provides <code>IncomeStatement</code>, <code>BalanceSheet</code>, and <code>CashFlowStatement</code> types that handle classification, computation, and validation automatically.</p><h3>Creating an Entity</h3><p>Every financial model starts with an entity:</p><pre><code class="language-swift">import BusinessMath

let acme = Entity(
    id: "ACME001",
    primaryType: .ticker,
    name: "Acme Corporation",
    identifiers: [.ticker: "ACME"],
    currency: "USD"
)
</code></pre><hr /><h3>Building an Income Statement</h3><p>The Income Statement shows profitability over time:</p><pre><code class="language-swift">// Define periods
let q1 = Period.quarter(year: 2025, quarter: 1)
let q2 = Period.quarter(year: 2025, quarter: 2)
let q3 = Period.quarter(year: 2025, quarter: 3)
let q4 = Period.quarter(year: 2025, quarter: 4)
let periods = [q1, q2, q3, q4]

// Revenue account
let revenue = try Account(
    entity: acme,
    name: "Product Revenue",
    incomeStatementRole: .productRevenue,
    timeSeries: TimeSeries(
        periods: periods,
        values: [1_000_000, 1_100_000, 1_200_000, 1_300_000]
    )
)

// Cost of Goods Sold
let cogs = try Account(
    entity: acme,
    name: "Cost of Goods Sold",
    incomeStatementRole: .costOfGoodsSold,
    timeSeries: TimeSeries(
        periods: periods,
        values: [400_000, 440_000, 480_000, 520_000]
    )
)

// Operating Expenses
let salaries = try Account(
    entity: acme,
    name: "Salaries",
    incomeStatementRole: .generalAndAdministrative,
    timeSeries: TimeSeries(
        periods: periods,
        values: [200_000, 200_000, 200_000, 200_000]
    )
)

let marketing = try Account(
    entity: acme,
    name: "Marketing",
    incomeStatementRole: .salesAndMarketing,
    timeSeries: TimeSeries(
        periods: periods,
        values: [50_000, 60_000, 70_000, 80_000]
    )
)

let depreciation = try Account(
    entity: acme,
    name: "Depreciation",
    incomeStatementRole: .depreciationAmortization,
    timeSeries: TimeSeries(
        periods: periods,
        values: [50_000, 50_000, 50_000, 50_000]
    )
)

// Interest and Taxes
let interestExpense = try Account(
    entity: acme,
    name: "Interest Expense",
    incomeStatementRole: .interestExpense,
    timeSeries: TimeSeries(
        periods: periods,
        values: [10_000, 10_000, 10_000, 10_000]
    )
)

let incomeTax = try Account(
    entity: acme,
    name: "Income Tax",
    incomeStatementRole: .incomeTaxExpense,
    timeSeries: TimeSeries(
        periods: periods,
        values: [60_000, 69_000, 78_000, 87_000]
    )
)

// Create Income Statement
let incomeStatement = try IncomeStatement(
    entity: acme,
    periods: periods,
    accounts: [revenue, cogs, salaries, marketing, depreciation, interestExpense, incomeTax]
)

// Access computed values
print("=== Q1 2025 Income Statement ===\n")
print("Revenue:\t\t\(incomeStatement.totalRevenue[q1]!.currency())")
print("COGS:\t\t\t(\(cogs.timeSeries[q1]!.currency()))")
print("Gross Profit:\t\t\(incomeStatement.grossProfit[q1]!.currency())")
print("  Gross Margin:\t\t\(incomeStatement.grossMargin[q1]!.percent(1))")
print()
print("Operating Expenses:\t(\((salaries.timeSeries[q1]! + marketing.timeSeries[q1]! + depreciation.timeSeries[q1]!).currency()))")
print("Operating Income:\t\(incomeStatement.operatingIncome[q1]!.currency())")
print("  Operating Margin:\t\(incomeStatement.operatingMargin[q1]!.percent(1))")
print()
print("EBITDA:\t\t\t\(incomeStatement.ebitda[q1]!.currency())")
print("  EBITDA Margin:\t\t\(incomeStatement.ebitdaMargin[q1]!.percent(1))")
print()
print("Interest Expense:\t(\(interestExpense.timeSeries[q1]!.currency()))")
print("Income Tax:\t\t(\(incomeTax.timeSeries[q1]!.currency()))")
print("Net Income:\t\t\(incomeStatement.netIncome[q1]!.currency())")
print("  Net Margin:\t\t\(incomeStatement.netMargin[q1]!.percent(1))")
</code></pre><p><strong>Output:</strong></p><pre><code>=== Q1 2025 Income Statement ===

Revenue:		$1,000,000
COGS:			($400,000)
Gross Profit:		$600,000
  Gross Margin:		60.0%

Operating Expenses:	($300,000)
Operating Income:	$300,000
  Operating Margin:	30.0%

EBITDA:			$350,000
  EBITDA Margin:		35.0%

Interest Expense:	($10,000)
Income Tax:		($60,000)
Net Income:		$230,000
  Net Margin:		23.0%
</code></pre><p><strong>The power</strong>: Income Statement automatically computes gross profit, operating income, EBITDA, and all margins. No manual calculations.</p><hr /><h3>Building a Balance Sheet</h3><p>The Balance Sheet shows financial position:</p><pre><code class="language-swift">// Assets
let cash = try Account(
    entity: acme,
    name: "Cash and Equivalents",
    balanceSheetRole: .cashAndEquivalents,
    timeSeries: TimeSeries(
        periods: periods,
        values: [500_000, 600_000, 750_000, 900_000]
    )
)

let receivables = try Account(
    entity: acme,
    name: "Accounts Receivable",
    balanceSheetRole: .accountsReceivable,
    timeSeries: TimeSeries(
        periods: periods,
        values: [300_000, 330_000, 360_000, 390_000]
    )
)

let inventory = try Account(
    entity: acme,
    name: "Inventory",
    balanceSheetRole: .inventory,
    timeSeries: TimeSeries(
        periods: periods,
        values: [200_000, 220_000, 240_000, 260_000]
    )
)

let ppe = try Account(
    entity: acme,
    name: "Property, Plant & Equipment",
    balanceSheetRole: .propertyPlantEquipment,
    timeSeries: TimeSeries(
        periods: periods,
        values: [1_000_000, 980_000, 960_000, 940_000]
    )
)

// Liabilities
let payables = try Account(
    entity: acme,
    name: "Accounts Payable",
    balanceSheetRole: .accountsPayable,
    timeSeries: TimeSeries(
        periods: periods,
        values: [150_000, 165_000, 180_000, 195_000]
    )
)

let longTermDebt = try Account(
    entity: acme,
    name: "Long-term Debt",
    balanceSheetRole: .longTermDebt,
    timeSeries: TimeSeries(
        periods: periods,
        values: [500_000, 500_000, 500_000, 500_000]
    )
)

// Equity
let commonStock = try Account(
    entity: acme,
    name: "Common Stock",
    balanceSheetRole: .commonStock,
    timeSeries: TimeSeries(
        periods: periods,
        values: [1_000_000, 1_000_000, 1_000_000, 1_000_000]
    )
)

let retainedEarnings = try Account(
    entity: acme,
    name: "Retained Earnings",
    balanceSheetRole: .retainedEarnings,
    timeSeries: TimeSeries(
        periods: periods,
        values: [350_000, 465_000, 630_000, 805_000]
    )
)

// Create Balance Sheet
let balanceSheet = try BalanceSheet(
    entity: acme,
    periods: periods,
    accounts: [cash, receivables, inventory, ppe, payables, longTermDebt, commonStock, retainedEarnings]
)

// Print Balance Sheet
print("\n=== Q1 2025 Balance Sheet ===\n")
print("ASSETS")
print("Current Assets:")
print("  Cash:\t\t\t\(cash.timeSeries[q1]!.currency())")
print("  Receivables:\t\t\(receivables.timeSeries[q1]!.currency())")
print("  Inventory:\t\t\(inventory.timeSeries[q1]!.currency())")
print("  Total Current:\t\(balanceSheet.currentAssets[q1]!.currency())")
print()
print("Fixed Assets:")
print("  PP&E:\t\t\t\(ppe.timeSeries[q1]!.currency())")
print()
print("Total Assets:\t\t\(balanceSheet.totalAssets[q1]!.currency())")
print()
print("LIABILITIES")
print("Current Liabilities:")
print("  Payables:\t\t\(payables.timeSeries[q1]!.currency())")
print()
print("Long-term Liabilities:")
print("  Debt:\t\t\t\(longTermDebt.timeSeries[q1]!.currency())")
print()
print("Total Liabilities:\t\(balanceSheet.totalLiabilities[q1]!.currency())")
print()
print("EQUITY")
print("  Common Stock:\t\t\(commonStock.timeSeries[q1]!.currency())")
print("  Retained Earnings:\t\(retainedEarnings.timeSeries[q1]!.currency())")
print("Total Equity:\t\t\(balanceSheet.totalEquity[q1]!.currency())")
print()
print("Total Liab + Equity:\t\((balanceSheet.totalLiabilities[q1]! + balanceSheet.totalEquity[q1]!).currency()))")

// Verify accounting equation
let assets = balanceSheet.totalAssets[q1]!
let liabilities = balanceSheet.totalLiabilities[q1]!
let equity = balanceSheet.totalEquity[q1]!

print("\n‚úì Balance Check: Assets (\(assets.currency())) = Liabilities + Equity (\((liabilities + equity).currency()))")
print("  Balanced: \(assets == liabilities + equity)")

// Calculate ratios
print("\nKey Ratios:")
print("  Current Ratio:\t\t\(balanceSheet.currentRatio[q1]!.number(2))x")
print("  Debt-to-Equity:\t\t\(balanceSheet.debtToEquity[q1]!.number(2))x")
print("  Equity Ratio:\t\t\(balanceSheet.equityRatio[q1]!.percent(1))")
</code></pre><p><strong>Output:</strong></p><pre><code>=== Q1 2025 Balance Sheet ===

ASSETS
Current Assets:
  Cash:			$500,000
  Receivables:		$300,000
  Inventory:		$200,000
  Total Current:	$1,000,000

Fixed Assets:
  PP&E:			$1,000,000

Total Assets:		$2,000,000

LIABILITIES
Current Liabilities:
  Payables:		$150,000

Long-term Liabilities:
  Debt:			$500,000

Total Liabilities:	$650,000

EQUITY
  Common Stock:		$1,000,000
  Retained Earnings:	$350,000
Total Equity:		$1,350,000

Total Liab + Equity:	$2,000,000

‚úì Balance Check: Assets ($2,000,000) = Liabilities + Equity ($2,000,000)
  Balanced: true

Key Ratios:
  Current Ratio:		6.67x
  Debt-to-Equity:		0.37x
  Equity Ratio:		67.5%
</code></pre><p><strong>The insight</strong>: Balance Sheet automatically validates Assets = Liabilities + Equity and computes liquidity/leverage ratios.</p><hr /><h3>Linking Statements Together</h3><p>Retained Earnings bridges Income Statement and Balance Sheet:</p><pre><code class="language-swift">// Verify retained earnings flow
let beginningRE = retainedEarnings.timeSeries[q1]!  // $350,000
let netIncome = incomeStatement.netIncome[q1]!      // $230,000 (calculated earlier)
let dividends = 0.0  // No dividends paid in Q1
let endingRE = retainedEarnings.timeSeries[q2]!     // $465,000

let calculatedEndingRE = beginningRE + netIncome - dividends

print("\n=== Retained Earnings Reconciliation ===")
print("Beginning (Q1): \(beginningRE.currency())")
print("+ Net Income:   \(netIncome.currency())")
print("- Dividends:    \(dividends.currency())")
print("= Ending (Q2):  \(calculatedEndingRE.currency())")
print("\nActual Q2 RE:   \(endingRE.currency())")
print("Difference:     \((endingRE - calculatedEndingRE).currency())")
</code></pre><p><strong>This links the statements</strong>: Net income flows from Income Statement ‚Üí Retained Earnings on Balance Sheet.</p><hr /><h2>Try It Yourself</h2><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath

let acme = Entity(
	id: "ACME001",
	primaryType: .ticker,
	name: "Acme Corporation",
	identifiers: [.ticker: "ACME"],
	currency: "USD"
)

	// Define periods
	let q1 = Period.quarter(year: 2025, quarter: 1)
	let q2 = Period.quarter(year: 2025, quarter: 2)
	let q3 = Period.quarter(year: 2025, quarter: 3)
	let q4 = Period.quarter(year: 2025, quarter: 4)
	let periods = [q1, q2, q3, q4]

	// Revenue account
	let revenue = try Account(
		entity: acme,
		name: "Product Revenue",
		incomeStatementRole: .productRevenue,
		timeSeries: TimeSeries(
			periods: periods,
			values: [1_000_000, 1_100_000, 1_200_000, 1_300_000]
		)
	)

	// Cost of Goods Sold
	let cogs = try Account(
		entity: acme,
		name: "Cost of Goods Sold",
		incomeStatementRole: .costOfGoodsSold,
		timeSeries: TimeSeries(
			periods: periods,
			values: [400_000, 440_000, 480_000, 520_000]
		)
	)

	// Operating Expenses
	let salaries = try Account(
		entity: acme,
		name: "Salaries",
		incomeStatementRole: .generalAndAdministrative,
		timeSeries: TimeSeries(
			periods: periods,
			values: [200_000, 200_000, 200_000, 200_000]
		)
	)

	let marketing = try Account(
		entity: acme,
		name: "Marketing",
		incomeStatementRole: .salesAndMarketing,
		timeSeries: TimeSeries(
			periods: periods,
			values: [50_000, 60_000, 70_000, 80_000]
		)
	)

	let depreciation = try Account(
		entity: acme,
		name: "Depreciation",
		incomeStatementRole: .depreciationAmortization,
		timeSeries: TimeSeries(
			periods: periods,
			values: [50_000, 50_000, 50_000, 50_000]
		)
	)

	// Interest and Taxes
	let interestExpense = try Account(
		entity: acme,
		name: "Interest Expense",
		incomeStatementRole: .interestExpense,
		timeSeries: TimeSeries(
			periods: periods,
			values: [10_000, 10_000, 10_000, 10_000]
		)
	)

	let incomeTax = try Account(
		entity: acme,
		name: "Income Tax",
		incomeStatementRole: .incomeTaxExpense,
		timeSeries: TimeSeries(
			periods: periods,
			values: [60_000, 69_000, 78_000, 87_000]
		)
	)

	// Create Income Statement
	let incomeStatement = try IncomeStatement(
		entity: acme,
		periods: periods,
		accounts: [revenue, cogs, salaries, marketing, depreciation, interestExpense, incomeTax]
	)

	// Access computed values
	print("=== Q1 2025 Income Statement ===\n")
	print("Revenue:\t\t\(incomeStatement.totalRevenue[q1]!.currency())")
	print("COGS:\t\t\t(\(cogs.timeSeries[q1]!.currency()))")
	print("Gross Profit:\t\t\(incomeStatement.grossProfit[q1]!.currency())")
	print("  Gross Margin:\t\t\(incomeStatement.grossMargin[q1]!.percent(1))")
	print()
	print("Operating Expenses:\t(\((salaries.timeSeries[q1]! + marketing.timeSeries[q1]! + depreciation.timeSeries[q1]!).currency()))")
	print("Operating Income:\t\(incomeStatement.operatingIncome[q1]!.currency())")
	print("  Operating Margin:\t\(incomeStatement.operatingMargin[q1]!.percent(1))")
	print()
	print("EBITDA:\t\t\t\(incomeStatement.ebitda[q1]!.currency())")
	print("  EBITDA Margin:\t\t\(incomeStatement.ebitdaMargin[q1]!.percent(1))")
	print()
	print("Interest Expense:\t(\(interestExpense.timeSeries[q1]!.currency()))")
	print("Income Tax:\t\t(\(incomeTax.timeSeries[q1]!.currency()))")
	print("Net Income:\t\t\(incomeStatement.netIncome[q1]!.currency())")
	print("  Net Margin:\t\t\(incomeStatement.netMargin[q1]!.percent(1))")


	// Assets
	let cash = try Account(
		entity: acme,
		name: "Cash and Equivalents",
		balanceSheetRole: .cashAndEquivalents,
		timeSeries: TimeSeries(
			periods: periods,
			values: [500_000, 600_000, 750_000, 900_000]
		)
	)

	let receivables = try Account(
		entity: acme,
		name: "Accounts Receivable",
		balanceSheetRole: .accountsReceivable,
		timeSeries: TimeSeries(
			periods: periods,
			values: [300_000, 330_000, 360_000, 390_000]
		)
	)

	let inventory = try Account(
		entity: acme,
		name: "Inventory",
		balanceSheetRole: .inventory,
		timeSeries: TimeSeries(
			periods: periods,
			values: [200_000, 220_000, 240_000, 260_000]
		)
	)

	let ppe = try Account(
		entity: acme,
		name: "Property, Plant & Equipment",
		balanceSheetRole: .propertyPlantEquipment,
		timeSeries: TimeSeries(
			periods: periods,
			values: [1_000_000, 980_000, 960_000, 940_000]
		)
	)

	// Liabilities
	let payables = try Account(
		entity: acme,
		name: "Accounts Payable",
		balanceSheetRole: .accountsPayable,
		timeSeries: TimeSeries(
			periods: periods,
			values: [150_000, 165_000, 180_000, 195_000]
		)
	)

	let longTermDebt = try Account(
		entity: acme,
		name: "Long-term Debt",
		balanceSheetRole: .longTermDebt,
		timeSeries: TimeSeries(
			periods: periods,
			values: [500_000, 500_000, 500_000, 500_000]
		)
	)

	// Equity
	let commonStock = try Account(
		entity: acme,
		name: "Common Stock",
		balanceSheetRole: .commonStock,
		timeSeries: TimeSeries(
			periods: periods,
			values: [1_000_000, 1_000_000, 1_000_000, 1_000_000]
		)
	)

	let retainedEarnings = try Account(
		entity: acme,
		name: "Retained Earnings",
		balanceSheetRole: .retainedEarnings,
		timeSeries: TimeSeries(
			periods: periods,
			values: [350_000, 465_000, 630_000, 805_000]
		)
	)

	// Create Balance Sheet
	let balanceSheet = try BalanceSheet(
		entity: acme,
		periods: periods,
		accounts: [cash, receivables, inventory, ppe, payables, longTermDebt, commonStock, retainedEarnings]
	)

	// Print Balance Sheet
	print("\n=== Q1 2025 Balance Sheet ===\n")
	print("ASSETS")
	print("Current Assets:")
	print("  Cash:\t\t\t\(cash.timeSeries[q1]!.currency())")
	print("  Receivables:\t\t\(receivables.timeSeries[q1]!.currency())")
	print("  Inventory:\t\t\(inventory.timeSeries[q1]!.currency())")
	print("  Total Current:\t\(balanceSheet.currentAssets[q1]!.currency())")
	print()
	print("Fixed Assets:")
	print("  PP&E:\t\t\t\(ppe.timeSeries[q1]!.currency())")
	print()
	print("Total Assets:\t\t\(balanceSheet.totalAssets[q1]!.currency())")
	print()
	print("LIABILITIES")
	print("Current Liabilities:")
	print("  Payables:\t\t\(payables.timeSeries[q1]!.currency())")
	print()
	print("Long-term Liabilities:")
	print("  Debt:\t\t\t\(longTermDebt.timeSeries[q1]!.currency())")
	print()
	print("Total Liabilities:\t\(balanceSheet.totalLiabilities[q1]!.currency())")
	print()
	print("EQUITY")
	print("  Common Stock:\t\t\(commonStock.timeSeries[q1]!.currency())")
	print("  Retained Earnings:\t\(retainedEarnings.timeSeries[q1]!.currency())")
	print("Total Equity:\t\t\(balanceSheet.totalEquity[q1]!.currency())")
	print()
print("Total Liab + Equity:\t\((balanceSheet.totalLiabilities[q1]! + balanceSheet.totalEquity[q1]!).currency()))")

	// Verify accounting equation
	let assets = balanceSheet.totalAssets[q1]!
	let liabilities = balanceSheet.totalLiabilities[q1]!
	let equity = balanceSheet.totalEquity[q1]!

	print("\n‚úì Balance Check: Assets (\(assets.currency())) = Liabilities + Equity (\((liabilities + equity).currency()))")
	print("  Balanced: \(assets == liabilities + equity)")

	// Calculate ratios
	print("\nKey Ratios:")
	print("  Current Ratio:\t\t\(balanceSheet.currentRatio[q1]!.number(2))x")
	print("  Debt-to-Equity:\t\t\(balanceSheet.debtToEquity[q1]!.number(2))x")
	print("  Equity Ratio:\t\t\(balanceSheet.equityRatio[q1]!.percent(1))")

	// Verify retained earnings flow
	let beginningRE = retainedEarnings.timeSeries[q1]!  // $350,000
	let netIncome = incomeStatement.netIncome[q1]!      // $230,000 (calculated earlier)
	let dividends = 0.0  // No dividends paid in Q1
	let endingRE = retainedEarnings.timeSeries[q2]!     // $465,000

	let calculatedEndingRE = beginningRE + netIncome - dividends

	print("\n=== Retained Earnings Reconciliation ===")
	print("Beginning (Q1): \(beginningRE.currency())")
	print("+ Net Income:   \(netIncome.currency())")
	print("- Dividends:    \(dividends.currency())")
	print("= Ending (Q2):  \(calculatedEndingRE.currency())")
	print("\nActual Q2 RE:   \(endingRE.currency())")
	print("Difference:     \((endingRE - calculatedEndingRE).currency())")
</code></pre></details>
<p>‚Üí Full API Reference: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/3.5-FinancialStatementsGuide.md"><strong>BusinessMath Docs ‚Äì 3.5 Financial Statements</strong></a></p><p><strong>Modifications to try</strong>:</p><ol><li>Add a Cash Flow Statement with operating, investing, and financing activities</li><li>Model multiple years of annual statements</li><li>Create pro forma statements for forecasting</li></ol><hr /><h2>Real-World Application</h2><p>Every three-statement model starts here:</p><ul><li><strong>Investment banking</strong>: Modeling LBO returns</li><li><strong>Corporate finance</strong>: Budgeting and planning</li><li><strong>Equity research</strong>: Forecasting earnings</li><li><strong>Credit analysis</strong>: Assessing solvency</li></ul><p>BusinessMath makes statement modeling type-safe, validated, and composable.</p><hr /><p><code>‚òÖ Insight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><p><strong>Why Use Role Enums Instead of Generic Types?</strong></p><p>You could use generic <code>type: .expense</code> for all expenses.</p><p>But role-specific enums provide:</p><ul><li><strong>Explicit classification</strong>: <code>incomeStatementRole: .costOfGoodsSold</code> makes intent clear</li><li><strong>Type safety</strong>: Can‚Äôt accidentally treat COGS as operating expense</li><li><strong>Automatic aggregation</strong>: Multiple accounts with same role aggregate automatically</li><li><strong>Multi-role capability</strong>: Same account (e.g., D&A) can have both Income Statement and Cash Flow roles</li><li><strong>Statement validation</strong>: Ensures only valid roles are used per statement type</li></ul><p>This prevents errors like classifying interest as operating expense or mixing incompatible accounts.</p><p><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><hr /><h3>üìù Development Note</h3><p>The hardest part of financial statement modeling was deciding: <strong>How much abstraction?</strong></p><p>We could have made a single <code>FinancialStatements</code> class with all three statements bundled. But different analyses need different statements:</p><ul><li><strong>Valuation</strong>: Needs Income Statement and Cash Flow Statement</li><li><strong>Credit analysis</strong>: Needs Balance Sheet and Cash Flow Statement</li><li><strong>Profitability</strong>: Needs only Income Statement</li></ul><p>We chose <strong>separate statement types</strong> that compose when needed. More flexible, slightly more verbose.</p><p><strong>Related Methodology</strong>: <a href="../../week-03/02-tue-master-plan">The Master Plan</a> (Week 3) - Managing API surface area</p><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: <a href="../03-fri-lease-accounting">Lease Accounting (Friday) - IFRS 16 / ASC 842</a> lease modeling with right-of-use assets and lease liabilities.</p><p><strong>Next week</strong>: Week 5 explores loans, investments, and valuations.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 4/12</li><li>Posts Published: 14/~48</li><li>Topics Covered: Foundation + Analysis + Operational + Financial Statements (in progress)</li><li>Playgrounds: 13 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-04/01-mon-financial-reports</guid><title>Building Multi-Period Financial Reports</title><link>https://www.justinpurnell.com/BusinessMath/week-04/01-mon-financial-reports</link><description><![CDATA[Part 13 of 12-Week BusinessMath Series]]></description><pubDate>Mon, 26 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[financial-reports]]></category><category><![CDATA[financial-statements]]></category><category><![CDATA[metrics]]></category><content:encoded><![CDATA[<p><strong>Part 13 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>Creating comprehensive financial reports with period summaries</li><li>Building multi-period reports for trend analysis</li><li>Tracking operational metrics alongside financial statements</li><li>Calculating growth rates and margin trends</li><li>Generating analyst-style financial summaries</li></ul><hr /><h2>The Problem</h2><p>Financial analysis isn‚Äôt just about individual statements‚Äîit‚Äôs about <strong>trends, comparisons, and integrated metrics</strong>. Analysts need to see:</p><ul><li><strong>Quarter-over-quarter growth</strong>: Is revenue accelerating or decelerating?</li><li><strong>Margin trends</strong>: Are we expanding or compressing margins?</li><li><strong>Leverage evolution</strong>: Is debt increasing relative to EBITDA?</li><li><strong>Operational drivers</strong>: What metrics drive the financials?</li></ul><p>Building comprehensive multi-period reports manually can be tedious. You need financial statements, operational metrics, computed ratios, and trend calculations‚Äîall integrated into a cohesive view.</p><p><strong>BusinessMath provides a system that combines statements, metrics, and analytics automatically.</strong></p><hr /><h2>The Solution</h2><p>BusinessMath provides <code>FinancialPeriodSummary</code> and <code>MultiPeriodReport</code> for analyst-quality financial reporting.</p><h3>Step 1: Create Financial Statements</h3><p>Start with Income Statement and Balance Sheet for multiple periods:</p><pre><code class="language-swift">import BusinessMath

let entity = Entity(
    id: "ACME",
    primaryType: .ticker,
    name: "Acme Corporation"
)

let periods = (1...4).map { Period.quarter(year: 2025, quarter: $0) }

// Revenue account
let revenue = try Account(
    entity: entity,
    name: "Product Revenue",
    incomeStatementRole: .revenue,
    timeSeries: TimeSeries(periods: periods, values: [1_000_000, 1_100_000, 1_200_000, 1_300_000])
)

// Expense accounts
let cogs = try Account(
    entity: entity,
    name: "Cost of Goods Sold",
    incomeStatementRole: .costOfGoodsSold,
    timeSeries: TimeSeries(periods: periods, values: [400_000, 450_000, 480_000, 520_000])
)

let opex = try Account(
    entity: entity,
    name: "Operating Expenses",
    incomeStatementRole: .operatingExpenseOther,
    timeSeries: TimeSeries(periods: periods, values: [300_000, 325_000, 350_000, 375_000])
)

let depreciation = try Account(
    entity: entity,
    name: "Depreciation",
    incomeStatementRole: .depreciationAmortization,
    timeSeries: TimeSeries(periods: periods, values: [50_000, 50_000, 50_000, 50_000])
)

let interest = try Account(
    entity: entity,
    name: "Interest Expense",
    incomeStatementRole: .interestExpense,
    timeSeries: TimeSeries(periods: periods, values: [25_000, 25_000, 25_000, 25_000])
)

let tax = try Account(
    entity: entity,
    name: "Income Tax",
    incomeStatementRole: .incomeTaxExpense,
    timeSeries: TimeSeries(periods: periods, values: [47_000, 49_000, 61_000, 68_000])
)

// Create Income Statement
let incomeStatement = try IncomeStatement(
	entity: entity,
	periods: periods,
	accounts: [revenue, cogs, opex, depreciation, interest, tax]
)

// Create Balance Sheet (assets, liabilities, equity)
let cash = try Account(
    entity: entity,
    name: "Cash",
    balanceSheetRole: .cashAndEquivalents,
    timeSeries: TimeSeries(periods: periods, values: [500_000, 600_000, 750_000, 900_000])
)

let receivables = try Account(
    entity: entity,
    name: "Receivables",
    balanceSheetRole: .accountsReceivable,
    timeSeries: TimeSeries(periods: periods, values: [300_000, 330_000, 360_000, 390_000])
)

let ppe = try Account(
    entity: entity,
    name: "PP&E",
    balanceSheetRole: .propertyPlantEquipment,
    timeSeries: TimeSeries(periods: periods, values: [1_000_000, 980_000, 960_000, 940_000])
)

let payables = try Account(
    entity: entity,
    name: "Payables",
    balanceSheetRole: .accountsPayable,
    timeSeries: TimeSeries(periods: periods, values: [200_000, 220_000, 240_000, 260_000])
)

let debt = try Account(
    entity: entity,
    name: "Long-Term Debt",
    balanceSheetRole: .longTermDebtNoncurrent,
    timeSeries: TimeSeries(periods: periods, values: [500_000, 500_000, 500_000, 500_000])
)

let equity = try Account(
    entity: entity,
    name: "Equity",
    balanceSheetRole: .retainedEarnings,
    timeSeries: TimeSeries(periods: periods, values: [1_100_000, 1_190_000, 1_330_000, 1_470_000])
)

let balanceSheet = try BalanceSheet(
	entity: entity,
	periods: periods,
	accounts: [cash, receivables, ppe, payables, debt, equity]
)
</code></pre><hr /><h3>Step 2: Add Operational Metrics</h3><p>Track business drivers that explain the financials:</p><pre><code class="language-swift">// Define operational metrics for each quarter
let q1Metrics = OperationalMetrics<Double>(
    entity: entity,
    period: periods[0],
    metrics: [
        "units_sold": 10_000,
        "average_price": 100.0,
        "customer_count": 500,
        "average_revenue_per_customer": 2_000
    ]
)

let q2Metrics = OperationalMetrics<Double>(
    entity: entity,
    period: periods[1],
    metrics: [
        "units_sold": 11_000,
        "average_price": 100.0,
        "customer_count": 550,
        "average_revenue_per_customer": 2_000
    ]
)

let q3Metrics = OperationalMetrics<Double>(
    entity: entity,
    period: periods[2],
    metrics: [
        "units_sold": 12_000,
        "average_price": 100.0,
        "customer_count": 600,
        "average_revenue_per_customer": 2_000
    ]
)

let q4Metrics = OperationalMetrics<Double>(
    entity: entity,
    period: periods[3],
    metrics: [
        "units_sold": 13_000,
        "average_price": 100.0,
        "customer_count": 650,
        "average_revenue_per_customer": 2_000
    ]
)

let operationalMetrics = [q1Metrics, q2Metrics, q3Metrics, q4Metrics]
</code></pre><p><strong>The insight</strong>: Operational metrics explain the financials. Revenue growth comes from adding 150 customers (30% increase) while maintaining price.</p><hr /><h3>Step 3: Create Financial Period Summary</h3><p>Combine statements and metrics into a comprehensive one-pager:</p><pre><code class="language-swift">let q1Summary = try FinancialPeriodSummary(
    entity: entity,
    period: periods[0],
    incomeStatement: incomeStatement,
    balanceSheet: balanceSheet,
    operationalMetrics: q1Metrics
)

print("=== Q1 2025 Financial Summary ===\n")
print("Revenue: \(q1Summary.revenue.currency())")
print("Gross Profit: \(q1Summary.grossProfit.currency())")
print("EBITDA: \(q1Summary.ebitda.currency())")
print("EBIT: \(q1Summary.operatingIncome.currency())")
print("Net Income: \(q1Summary.netIncome.currency())")
print()
print("Margins:")
print("  Gross Margin: \(q1Summary.grossMargin.percent(1))")
print("  Operating Margin: \(q1Summary.operatingMargin.percent(1))")
print("  Net Margin: \(q1Summary.netMargin.percent(1))")
print()
print("Returns:")
print("  ROA: \(q1Summary.roa.percent(1))")
print("  ROE: \(q1Summary.roe.percent(1))")
print()
print("Leverage:")
print("  Debt/Equity: \(q1Summary.debtToEquityRatio.number(2))x")
print("  Debt/EBITDA: \(q1Summary.debtToEBITDARatio.number(2))x")
print("  EBIT Interest Coverage: \(q1Summary.interestCoverageRatio!.number(1))x")
print()
print("Liquidity:")
print("  Current Ratio: \(q1Summary.currentRatio.number(2))x")
</code></pre><p><strong>Output:</strong></p><pre><code>=== Q1 2025 Financial Summary ===

Revenue: $1,000,000.00
Gross Profit: $600,000.00
EBITDA: $300,000.00
EBIT: $250,000.00
Net Income: $178,000.00

Margins:
  Gross Margin: 60.0%
  Operating Margin: 25.0%
  Net Margin: 17.8%

Returns:
  ROA: 9.9%
  ROE: 16.2%

Leverage:
  Debt/Equity: 0.45x
  Debt/EBITDA: 1.67x
  EBIT Interest Coverage: 10.0x

Liquidity:
  Current Ratio: 4.00x
</code></pre><p><strong>The power</strong>: One <code>FinancialPeriodSummary</code> object gives you ~30 key metrics automatically computed.</p><hr /><h3>Step 4: Build Multi-Period Report</h3><p>Aggregate multiple periods for trend analysis:</p><pre><code class="language-swift">// Create summaries for all quarters
let summaries = try periods.indices.map { index in
    try FinancialPeriodSummary(
        entity: entity,
        period: periods[index],
        incomeStatement: incomeStatement,
        balanceSheet: balanceSheet,
        operationalMetrics: operationalMetrics[index]
    )
}

// Create multi-period report
let report = try MultiPeriodReport(
    entity: entity,
    periodSummaries: summaries
)

print("\n=== Acme Corporation - FY2025 Trends ===\n")
print("Periods analyzed: \(report.periodCount)")
</code></pre><hr /><h3>Step 5: Analyze Growth Rates</h3><p>Calculate period-over-period growth:</p><pre><code class="language-swift">// Revenue growth
let revenueGrowth = report.revenueGrowth()
print("\nRevenue Growth (Q-o-Q):")
for (index, growth) in revenueGrowth.enumerated() {
    let quarter = index + 2  // Q2, Q3, Q4
    print("  Q\(quarter): \(growth.percent(1))")
}

// EBITDA growth
let ebitdaGrowth = report.ebitdaGrowth()
print("\nEBITDA Growth (Q-o-Q):")
for (index, growth) in ebitdaGrowth.enumerated() {
    let quarter = index + 2
    print("  Q\(quarter): \(growth.percent(1))")
}

// Net income growth
let netIncomeGrowth = report.netIncomeGrowth()
print("\nNet Income Growth (Q-o-Q):")
for (index, growth) in netIncomeGrowth.enumerated() {
    let quarter = index + 2
    print("  Q\(quarter): \(growth.percent(1))")
}
</code></pre><p><strong>Output:</strong></p><pre><code>Periods analyzed: 4

Revenue Growth (Q-o-Q):
  Q2: 10.0%
  Q3: 9.1%
  Q4: 8.3%

EBITDA Growth (Q-o-Q):
  Q2: 8.3%
  Q3: 13.8%
  Q4: 9.5%

Net Income Growth (Q-o-Q):
  Q2: 12.9%
  Q3: 16.4%
  Q4: 12.0%
</code></pre><p><strong>The insight</strong>: Revenue growth is decelerating (10% ‚Üí 9.1% ‚Üí 8.3%), but net income growth is accelerating due to margin expansion.</p><hr /><h3>Step 6: Track Margin Trends</h3><p>Analyze margin evolution:</p><pre><code class="language-swift">// Margin trends
let grossMargins = report.grossMarginTrend()
let operatingMargins = report.operatingMarginTrend()
let netMargins = report.netMarginTrend()

	print("\n=== Margin Trend Analysis ===")
	print("Period\t\tGross\tOperating\t   Net")
	print("------\t\t-----\t---------\t-------")
	for i in 0...(periods.count - 1) {
		let quarter = i + 1
		print("Q\(quarter)\(grossMargins[i].percent(1).paddingLeft(toLength: 15))\(operatingMargins[i].percent(1).paddingLeft(toLength: 12))\(netMargins[i].percent(1).paddingLeft(toLength: 10))")
	}

// Calculate margin expansion (convert from decimal to basis points)
// 1 percentage point = 100 basis points, so multiply decimal by 10,000
let grossExpansion = (grossMargins[3] - grossMargins[0]) * 10000
let operatingExpansion = (operatingMargins[3] - operatingMargins[0]) * 10000
let netExpansion = (netMargins[3] - netMargins[0]) * 10000

print("\nMargin Expansion (Q1 ‚Üí Q4):")
print("  Gross: \(grossExpansion.number(0)) bps")
print("  Operating: \(operatingExpansion.number(0)) bps")
print("  Net: \(netExpansion.number(0)) bps")

</code></pre><p><strong>Output:</strong></p><pre><code>=== Margin Trend Analysis ===
Period		Gross	Operating	   Net
------		-----	---------	-------
Q1          60.0%       25.0%     17.8%
Q2          59.1%       25.0%     18.3%
Q3          60.0%       26.7%     19.5%
Q4          60.0%       27.3%     20.2%

Margin Expansion (Q1 ‚Üí Q4):
  Gross: 0 bps
  Operating: 231 bps
  Net: 235 bps
</code></pre><p><strong>The insight</strong>: Gross margin stable at 60%, while operating margin expanded 231 basis points (2.3 percentage points) and net margin expanded 235 basis points (2.4 percentage points) due to operating leverage and improving efficiency.</p><hr /><h2>Try It Yourself</h2><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath

let entity = Entity(
	id: "ACME",
	primaryType: .ticker,
	name: "Acme Corporation"
)

let periods = (1...4).map { Period.quarter(year: 2025, quarter: $0) }

// Revenue account
let revenue = try Account(
	entity: entity,
	name: "Product Revenue",
	incomeStatementRole: .revenue,
	timeSeries: TimeSeries(periods: periods, values: [1_000_000, 1_100_000, 1_200_000, 1_300_000])
)

// Expense accounts
let cogs = try Account(
	entity: entity,
	name: "Cost of Goods Sold",
	incomeStatementRole: .costOfGoodsSold,
	timeSeries: TimeSeries(periods: periods, values: [400_000, 450_000, 480_000, 520_000])
)

let opex = try Account(
	entity: entity,
	name: "Operating Expenses",
	incomeStatementRole: .operatingExpenseOther,
	timeSeries: TimeSeries(periods: periods, values: [300_000, 325_000, 350_000, 375_000])
)

let depreciation = try Account(
	entity: entity,
	name: "Depreciation",
	incomeStatementRole: .depreciationAmortization,
	timeSeries: TimeSeries(periods: periods, values: [50_000, 50_000, 50_000, 50_000])
)

let interest = try Account(
	entity: entity,
	name: "Interest Expense",
	incomeStatementRole: .interestExpense,
	timeSeries: TimeSeries(periods: periods, values: [25_000, 25_000, 25_000, 25_000])
)

let tax = try Account(
	entity: entity,
	name: "Income Tax",
	incomeStatementRole: .incomeTaxExpense,
	timeSeries: TimeSeries(periods: periods, values: [47_000, 49_000, 61_000, 68_000])
)

// Create Income Statement
let incomeStatement = try IncomeStatement(
	entity: entity,
	periods: periods,
	accounts: [revenue, cogs, opex, depreciation, interest, tax]
)

// Create Balance Sheet (assets, liabilities, equity)
let cash = try Account(
	entity: entity,
	name: "Cash",
	balanceSheetRole: .cashAndEquivalents,
	timeSeries: TimeSeries(periods: periods, values: [500_000, 600_000, 750_000, 900_000])
)

let receivables = try Account(
	entity: entity,
	name: "Receivables",
	balanceSheetRole: .accountsReceivable,
	timeSeries: TimeSeries(periods: periods, values: [300_000, 330_000, 360_000, 390_000])
)

let ppe = try Account(
	entity: entity,
	name: "PP&E",
	balanceSheetRole: .propertyPlantEquipment,
	timeSeries: TimeSeries(periods: periods, values: [1_000_000, 980_000, 960_000, 940_000])
)

let payables = try Account(
	entity: entity,
	name: "Payables",
	balanceSheetRole: .accountsPayable,
	timeSeries: TimeSeries(periods: periods, values: [200_000, 220_000, 240_000, 260_000])
)

let debt = try Account(
	entity: entity,
	name: "Long-Term Debt",
	balanceSheetRole: .longTermDebt,
	timeSeries: TimeSeries(periods: periods, values: [500_000, 500_000, 500_000, 500_000])
)

let equity = try Account(
	entity: entity,
	name: "Equity",
	balanceSheetRole: .retainedEarnings,
	timeSeries: TimeSeries(periods: periods, values: [1_100_000, 1_190_000, 1_330_000, 1_470_000])
)

let balanceSheet = try BalanceSheet(
	entity: entity,
	periods: periods,
	accounts: [cash, receivables, ppe, payables, debt, equity]
)

	// Define operational metrics for each quarter
	let q1Metrics = OperationalMetrics<Double>(
		entity: entity,
		period: periods[0],
		metrics: [
			"units_sold": 10_000,
			"average_price": 100.0,
			"customer_count": 500,
			"average_revenue_per_customer": 2_000
		]
	)

	let q2Metrics = OperationalMetrics<Double>(
		entity: entity,
		period: periods[1],
		metrics: [
			"units_sold": 11_000,
			"average_price": 100.0,
			"customer_count": 550,
			"average_revenue_per_customer": 2_000
		]
	)

	let q3Metrics = OperationalMetrics<Double>(
		entity: entity,
		period: periods[2],
		metrics: [
			"units_sold": 12_000,
			"average_price": 100.0,
			"customer_count": 600,
			"average_revenue_per_customer": 2_000
		]
	)

	let q4Metrics = OperationalMetrics<Double>(
		entity: entity,
		period: periods[3],
		metrics: [
			"units_sold": 13_000,
			"average_price": 100.0,
			"customer_count": 650,
			"average_revenue_per_customer": 2_000
		]
	)

	let operationalMetrics = [q1Metrics, q2Metrics, q3Metrics, q4Metrics]

let q1Summary = try FinancialPeriodSummary(
	entity: entity,
	period: periods[0],
	incomeStatement: incomeStatement,
	balanceSheet: balanceSheet,
	operationalMetrics: q1Metrics
)

print("=== Q1 2025 Financial Summary ===\n")
print("Revenue: \(q1Summary.revenue.currency())")
print("Gross Profit: \(q1Summary.grossProfit.currency())")
print("EBITDA: \(q1Summary.ebitda.currency())")
print("EBIT: \(q1Summary.operatingIncome.currency())")
print("Net Income: \(q1Summary.netIncome.currency())")
print()
print("Margins:")
print("  Gross Margin: \(q1Summary.grossMargin.percent(1))")
print("  Operating Margin: \(q1Summary.operatingMargin.percent(1))")
print("  Net Margin: \(q1Summary.netMargin.percent(1))")
print()
print("Returns:")
print("  ROA: \(q1Summary.roa.percent(1))")
print("  ROE: \(q1Summary.roe.percent(1))")
print()
print("Leverage:")
print("  Debt/Equity: \(q1Summary.debtToEquityRatio.number(2))x")
print("  Debt/EBITDA: \(q1Summary.debtToEBITDARatio.number(2))x")
print("  EBIT Interest Coverage: \(q1Summary.interestCoverageRatio!.number(1))x")
print()
print("Liquidity:")
print("  Current Ratio: \(q1Summary.currentRatio.number(2))x")


	// Create summaries for all quarters
	let summaries = try periods.indices.map { index in
		try FinancialPeriodSummary(
			entity: entity,
			period: periods[index],
			incomeStatement: incomeStatement,
			balanceSheet: balanceSheet,
			operationalMetrics: operationalMetrics[index]
		)
	}

	// Create multi-period report
	let report = try MultiPeriodReport(
		entity: entity,
		periodSummaries: summaries
	)

	print("\n=== Acme Corporation - FY2025 Trends ===\n")
	print("Periods analyzed: \(report.periodCount)")

	// Revenue growth
	let revenueGrowth = report.revenueGrowth()
	print("\nRevenue Growth (Q-o-Q):")
	for (index, growth) in revenueGrowth.enumerated() {
		let quarter = index + 2  // Q2, Q3, Q4
		print("  Q\(quarter): \(growth.percent(1))")
	}

	// EBITDA growth
	let ebitdaGrowth = report.ebitdaGrowth()
	print("\nEBITDA Growth (Q-o-Q):")
	for (index, growth) in ebitdaGrowth.enumerated() {
		let quarter = index + 2
		print("  Q\(quarter): \(growth.percent(1))")
	}

	// Net income growth
	let netIncomeGrowth = report.netIncomeGrowth()
	print("\nNet Income Growth (Q-o-Q):")
	for (index, growth) in netIncomeGrowth.enumerated() {
		let quarter = index + 2
		print("  Q\(quarter): \(growth.percent(1))")
	}

	// Margin trends
	let grossMargins = report.grossMarginTrend()
	let operatingMargins = report.operatingMarginTrend()
	let netMargins = report.netMarginTrend()

	print("\n=== Margin Trend Analysis ===")
	print("Period\t\tGross\tOperating\t   Net")
	print("------\t\t-----\t---------\t-------")
	for i in 0...(periods.count - 1) {
		let quarter = i + 1
		print("Q\(quarter)\(grossMargins[i].percent(1).paddingLeft(toLength: 15))\(operatingMargins[i].percent(1).paddingLeft(toLength: 12))\(netMargins[i].percent(1).paddingLeft(toLength: 10))")
	}

	// Calculate margin expansion (convert from decimal to basis points)
	// 1 percentage point = 100 basis points, so multiply decimal by 10,000
	let grossExpansion = (grossMargins[3] - grossMargins[0]) * 10000
	let operatingExpansion = (operatingMargins[3] - operatingMargins[0]) * 10000
	let netExpansion = (netMargins[3] - netMargins[0]) * 10000

	print("\nMargin Expansion (Q1 ‚Üí Q4):")
	print("  Gross: \(grossExpansion.number(0)) bps")
	print("  Operating: \(operatingExpansion.number(0)) bps")
	print("  Net: \(netExpansion.number(0)) bps")

</code></pre></details>
<p>‚Üí Full API Reference: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/3.4-BuildingFinancialReports.md"><strong>BusinessMath Docs ‚Äì 3.4 Financial Reports</strong></a></p><p><strong>Modifications to try</strong>:</p><ol><li>Add more operational metrics (customer acquisition cost, LTV)</li><li>Create annual reports instead of quarterly</li><li>Compare multiple companies side-by-side</li></ol><hr /><h2>Real-World Application</h2><p>This is how equity analysts create quarterly reports:</p><ul><li><strong>Equity and Credit research</strong>: 50-page reports start with one-page summary tables</li><li><strong>Earnings presentations</strong>: CFOs show this exact format to investors</li><li><strong>Internal dashboards</strong>: Management tracks these metrics monthly</li></ul><p>BusinessMath makes creating these reports programmatic and reproducible.</p><hr /><p><code>‚òÖ Insight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><p><strong>Why Separate Financial Statements from Reports?</strong></p><p><code>IncomeStatement</code> and <code>BalanceSheet</code> model the raw data.</p><p><code>FinancialPeriodSummary</code> computes derived metrics (EBITDA, ROE, ratios).</p><p><code>MultiPeriodReport</code> analyzes trends (growth rates, margin expansion).</p><p>This separation follows the <strong>Single Responsibility Principle</strong>:</p><ul><li>Statements = data containers</li><li>Summaries = metric calculators</li><li>Reports = trend analyzers</li></ul><p>Each layer adds value without bloating the lower layers.</p><p><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><hr /><h3>üìù Development Note</h3><p>The hardest design decision was: <strong>How opinionated should the report format be?</strong></p><p>We could have made <code>FinancialPeriodSummary</code> produce formatted output (tables, charts). But formatting requirements vary wildly:</p><ul><li>CLI tools want plain text</li><li>Web apps want HTML</li><li>iOS apps want SwiftUI views</li><li>Analysts want Excel exports</li></ul><p>We chose <strong>data-only output</strong>: <code>FinancialPeriodSummary</code> computes metrics and returns them as properties. You format however you want.</p><p>This makes the API flexible at the cost of requiring formatting code. Worth it.</p><p><strong>Related Methodology</strong>: <a href="../week-02/02-tue-documentation-as-design.md">Documentation as Design</a> (Week 2) - Designing APIs that users understand</p><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: <a href="../02-wed-financial-statements">Financial Statements Guide (Wednesday)</a> - Deep dive into Income Statement, Balance Sheet, and Cash Flow Statement.</p><p><strong>This week</strong>: <a href="../03-fri-lease-accounting">Lease Accounting (Friday)</a> - IFRS 16 / ASC 842 lease modeling.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 4/12</li><li>Posts Published: 13/~48</li><li>Topics Covered: Foundation + Analysis + Operational + Financial Statements (starting)</li><li>Playgrounds: 12 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/businessMath-Introduction</guid><title>Welcome to BusinessMath: A 12-Week Journey</title><link>https://www.justinpurnell.com/BusinessMath/businessMath-Introduction</link><description><![CDATA[Your roadmap to mastering financial calculations, statistical analysis, and optimization in Swift]]></description><pubDate>Mon, 26 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[introduction]]></category><content:encoded><![CDATA[<p><strong>Your roadmap to mastering financial calculations, statistical analysis, and optimization in Swift</strong></p><hr /><p>Welcome! Over the next twelve weeks, we‚Äôre going on a journey together‚Äîfrom calculating the basics of time value of money to building sophisticated portfolio optimizers and real-time trading systems. Whether you‚Äôre a Swift developer curious about financial mathematics, a business analyst looking to bring your calculations into code, or someone who just loves solving practical problems with elegant tools, this series is for you.</p><h2>What is <a href="https://github.com/jpurnell/BusinessMath"><strong>BusinessMath</strong></a>?</h2><p><a href="https://github.com/jpurnell/BusinessMath"><strong>BusinessMath</strong></a> is a comprehensive Swift library that brings financial calculations, statistical analysis, and optimization algorithms to your fingertips. Need to calculate loan amortization schedules? Run Monte Carlo simulations? Optimize a portfolio under constraints? BusinessMath has you covered‚Äîwith clean, type-safe APIs that work across all Apple platforms.</p><p>But this library is more than just a collection of functions. It‚Äôs built on principles that matter: test-driven development, comprehensive documentation, and real-world applicability. Every calculation is tested, every API is documented, and every feature is designed to solve actual business problems.</p><h2>What to Expect</h2><p>This series spans <strong>12 weeks</strong> with <strong>3-4 posts per week</strong>, mixing technical deep-dives with real-world case studies:</p><p><strong>Weeks 1-2: Foundation</strong>We‚Äôll start with the essentials‚Äîtime series data, time value of money, and financial ratios. By the end of week 1, you‚Äôll build a complete retirement planning calculator.</p><p><strong>Weeks 3-5: Financial Modeling</strong>Learn to build growth models, revenue projections, and complete financial statements. We‚Äôll tackle real scenarios like capital equipment decisions and lease accounting.</p><p><strong>Weeks 6-8: Simulation & Optimization</strong>Monte Carlo simulations, scenario analysis, and portfolio optimization. The midpoint case study combines everything you‚Äôve learned into a $10M portfolio optimizer.</p><p><strong>Weeks 9-12: Advanced Topics</strong>Integer programming, particle swarm optimization, parallel processing, and performance tuning. We‚Äôll close with reflections on building production-quality software and a complete investment strategy DSL.</p><p>Every few posts, we‚Äôll pause for a <strong>case study</strong>‚Äîa complete, real-world scenario that combines multiple topics into a practical solution. By the end, you‚Äôll have tackled 6 substantial business problems, from retirement planning to real-time portfolio rebalancing.</p><h2>Why Follow Along?</h2><p>Each post is self-contained but builds on previous concepts. You‚Äôll get:</p><ul><li><strong>Runnable code examples</strong> you can try immediately</li><li><strong>Complete playgrounds</strong> to experiment and modify</li><li><strong>Links to comprehensive API documentation</strong> when you want to dive deeper</li><li><strong>Real business context</strong> that explains why each technique matters</li></ul><p>This isn‚Äôt just theory‚Äîit‚Äôs production-ready code solving real problems. And it‚Äôs designed to be accessible whether you‚Äôre implementing these calculations for the first time or you‚Äôre a seasoned financial engineer exploring Swift.</p><h2>Ready to Begin?</h2><p>We‚Äôll publish new posts <strong>Monday, Wednesday, Thursday, and Friday</strong>, with case studies every other Friday. Bookmark this series, follow along at your own pace, and don‚Äôt hesitate to experiment with the code. The best way to learn is by doing.</p><p>Let‚Äôs get started.</p><hr /><p><strong>Series Overview</strong>: 12 weeks | ~40 posts | 6 case studies | 11 major topics</p><p><strong>First Post</strong>: Week 1 ‚Äì <a href="../BusinessMath/week-01/01-mon-getting-started/">Getting Started with BusinessMath</a></p><p><em>Ready to dive in? Check out the first post where we cover installation, basic concepts, and your first calculations.</em></p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-03/04-fri-case-capital-equipment</guid><title>Case Study: Capital Equipment Purchase Decision</title><link>https://www.justinpurnell.com/BusinessMath/week-03/04-fri-case-capital-equipment</link><description><![CDATA[Capstone #2 ‚Äì Combining TVM + Depreciation + Financial Analysis]]></description><pubDate>Fri, 23 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[case-study]]></category><category><![CDATA[capital-budgeting]]></category><category><![CDATA[depreciation]]></category><category><![CDATA[npv]]></category><category><![CDATA[roi]]></category><content:encoded><![CDATA[<p><strong>Capstone #2 ‚Äì Combining TVM + Depreciation + Financial Analysis</strong></p><hr /><h2>The Business Challenge</h2><p>TechMfg Inc., a manufacturing company, is evaluating a $500,000 investment in new automated production equipment. The CFO needs to answer:</p><ol><li><strong>Is this a good investment?</strong> (NPV, IRR, Payback Period)</li><li><strong>How does it affect our financial statements?</strong> (Depreciation, ROI, ROA)</li><li><strong>Should we lease or buy?</strong> (Compare alternatives)</li><li><strong>What if our assumptions are wrong?</strong> (Sensitivity analysis)</li></ol><p>Think of this as a real half-million dollar capital budgeting decision. Get it right, and you boost productivity and profitability for years.</p><hr /><h2>The Requirements</h2><p><strong>Stakeholders</strong>: CFO, Operations VP, Finance Committee</p><p><strong>Key Questions</strong>:</p><ul><li>What‚Äôs the NPV and IRR of this investment?</li><li>How long until we recover the initial cost?</li><li>How does depreciation affect reported earnings?</li><li>What if production volume is 20% lower than expected?</li><li>Should we lease instead?</li></ul><p><strong>Success Criteria</strong>:</p><ul><li>Complete financial analysis</li><li>NPV-based recommendation</li><li>Sensitivity to key assumptions</li><li>Lease vs. buy comparison</li></ul><hr /><h2>The Solution</h2><h3>Part 1: Setup and Assumptions</h3><p>First, define the investment parameters:</p><pre><code class="language-swift">import BusinessMath

print("=== CAPITAL EQUIPMENT DECISION ANALYSIS ===\n")

// Equipment Details
let purchasePrice = 500_000.0
let usefulLife = 7  // years
let salvageValue = 50_000.0

// Operating Assumptions
let annualProductionIncrease = 100_000.0  // units
let contributionMarginPerUnit = 6.0  // $ per unit
let annualMaintenanceCost = 15_000.0

// Financial Assumptions
let discountRate = 0.10  // 10% WACC
let taxRate = 0.25  // 25% corporate tax rate

print("Equipment Investment:")
print("- Purchase Price: \(purchasePrice.currency())")
print("- Useful Life: \(usefulLife) years")
print("- Salvage Value: \(salvageValue.currency())")
print()
print("Operating Assumptions:")
print("- Annual Production Increase: \(annualProductionIncrease.number(0)) units")
print("- Contribution Margin: \(contributionMarginPerUnit.currency())/unit")
print("- Annual Maintenance: \(annualMaintenanceCost.currency())")
print()
print("Financial Assumptions:")
print("- Discount Rate (WACC): \(discountRate.formatted(.percent))")
print("- Tax Rate: \(taxRate.formatted(.percent))")
print()
</code></pre><p><strong>Output:</strong></p><pre><code>=== CAPITAL EQUIPMENT DECISION ANALYSIS ===

Equipment Investment:
- Purchase Price: $500,000.00
- Useful Life: 7 years
- Salvage Value: $50,000.00

Operating Assumptions:
- Annual Production Increase: 100,000 units
- Contribution Margin: $6.00/unit
- Annual Maintenance: $15,000.00

Financial Assumptions:
- Discount Rate (WACC): 10%
- Tax Rate: 25%
</code></pre><hr /><h3>Part 2: Calculate Annual Cash Flows</h3><p>Determine cash inflows and outflows for each year:</p><pre><code class="language-swift">print("PART 1: Annual Cash Flow Analysis\n")

// Annual contribution margin from increased production
let annualRevenueBenefit = Double(annualProductionIncrease) * contributionMarginPerUnit
print("Annual Revenue Benefit: \(annualRevenueBenefit.currency())")

// Net annual operating cash flow (before tax)
let annualOperatingCashFlow = annualRevenueBenefit - annualMaintenanceCost
print("Annual Operating Cash Flow (pre-tax): \(annualOperatingCashFlow.currency())")

// Calculate depreciation using straight-line method
let annualDepreciation = (purchasePrice - salvageValue) / Double(usefulLife)
print("Annual Depreciation (straight-line): \(annualDepreciation.currency())")

// Taxable income = Operating cash flow - Depreciation
let annualTaxableIncome = annualOperatingCashFlow - annualDepreciation
print("Annual Taxable Income: \(annualTaxableIncome.currency())")

// Taxes
let annualTaxes = annualTaxableIncome * taxRate
print("Annual Taxes: \(annualTaxes.currency())")

// After-tax cash flow = Operating cash flow - Taxes
// (Note: Depreciation is added back because it's non-cash)
let annualAfterTaxCashFlow = annualOperatingCashFlow - annualTaxes
print("Annual After-Tax Cash Flow: \(annualAfterTaxCashFlow.currency())")
print()
</code></pre><p><strong>Output:</strong></p><pre><code>PART 1: Annual Cash Flow Analysis

Annual Revenue Benefit: $600,000.00
Annual Operating Cash Flow (pre-tax): $585,000.00
Annual Depreciation (straight-line): $64,285.71
Annual Taxable Income: $520,714.29
Annual Taxes: $130,178.57
Annual After-Tax Cash Flow: $454,821.43
</code></pre><p><strong>The insight</strong>: Equipment generates $585k annually before tax, but depreciation creates a tax shield that reduces taxes by ~$16k per year.</p><hr /><h3>Part 3: NPV and IRR Analysis</h3><p>Build the complete cash flow profile and evaluate:</p><pre><code class="language-swift">print("PART 2: NPV and IRR Analysis\n")

// Build cash flow array
var cashFlows = [-purchasePrice]  // Year 0: Initial investment

// Years 1-7: Annual after-tax cash flows
for _ in 1...usefulLife {
    cashFlows.append(annualAfterTaxCashFlow)
}

// Year 7: Add salvage value (assume no tax on salvage for simplicity)
cashFlows[cashFlows.count - 1] += salvageValue

print("Cash Flow Profile:")
for (year, cf) in cashFlows.enumerated() {
    let sign = cf >= 0 ? "+" : ""
    print("  Year \(year): \(sign)\(cf.currency())")
}
print()

// Calculate NPV
let npvValue = npv(discountRate: discountRate, cashFlows: cashFlows)
print("Net Present Value (NPV): \(npvValue.currency())")

if npvValue > 0 {
    print("‚úì ACCEPT: Positive NPV creates value")
} else {
    print("‚úó REJECT: Negative NPV destroys value")
}
print()

// Calculate IRR
let irrValue = try! irr(cashFlows: cashFlows)
print("Internal Rate of Return (IRR): \(irrValue.formatted(.percent.precision(.fractionLength(2))))")

if irrValue > discountRate {
    print("‚úì ACCEPT: IRR (\(irrValue.formatted(.percent))) > WACC (\(discountRate.formatted(.percent)))")
} else {
    print("‚úó REJECT: IRR < WACC")
}
print()
</code></pre><p><strong>Output:</strong></p><pre><code>PART 2: NPV and IRR Analysis

Cash Flow Profile:
  Year 0: ($500,000.00)
  Year 1: +$454,821.43
  Year 2: +$454,821.43
  Year 3: +$454,821.43
  Year 4: +$454,821.43
  Year 5: +$454,821.43
  Year 6: +$454,821.43
  Year 7: +$504,821.43  (includes $50k salvage)

Net Present Value (NPV): $1,739,919.11
‚úì ACCEPT: Positive NPV creates value

Internal Rate of Return (IRR): 90.05%
‚úì ACCEPT: IRR (90.049037%) > WACC (10%)
</code></pre><p><strong>The insight</strong>: This is an EXCELLENT investment. NPV of $1.7M and IRR of 90% far exceed hurdle rate.</p><hr /><h3>Part 4: Payback Period</h3><p>How long until we recover the investment?</p><pre><code class="language-swift">print("PART 3: Payback Period Analysis\n")

var cumulativeCashFlow = -purchasePrice
var paybackYear = 0

print("Cumulative Cash Flow:")
for (year, cf) in cashFlows.enumerated() {
    if year == 0 {
        cumulativeCashFlow = cf
    } else {
        cumulativeCashFlow += cf
    }

    print("  Year \(year): \(cumulativeCashFlow.currency())")

    if cumulativeCashFlow >= 0 && paybackYear == 0 {
        paybackYear = year
    }
}

if paybackYear > 0 {
    print("\nPayback Period: ~\(paybackYear) years")
    print("‚úì Investment recovered in \(paybackYear) years (well within \(usefulLife) year life)")
} else {
    print("\n‚ö†Ô∏è Investment not recovered within useful life")
}
print()
</code></pre><p><strong>Output:</strong></p><pre><code>PART 3: Payback Period Analysis

Cumulative Cash Flow:
  Year 0: ($500,000.00)
  Year 1: ($45,178.57)
  Year 2: $409,642.86
  Year 3: $864,464.29
  Year 4: $1,319,285.71
  Year 5: $1,774,107.14
  Year 6: $2,228,928.57
  Year 7: $2,733,750.00

Payback Period: ~2 years
‚úì Investment recovered in 2 years (well within 7 year life)
</code></pre><hr /><h3>Part 5: Financial Statement Impact</h3><p>How does this affect ROA and profitability?</p><pre><code class="language-swift">print("PART 4: Financial Statement Impact\n")

// Assume current company metrics
let currentAssets = 5_000_000.0
let currentNetIncome = 750_000.0

// Year 1 impact
let newAssets = currentAssets + (purchasePrice - annualDepreciation)  // Equipment at book value
let newNetIncome = currentNetIncome + annualTaxableIncome - annualTaxes  // Add equipment contribution

// Calculate ROA before and after
let roaBefore = currentNetIncome / currentAssets
let roaAfter = newNetIncome / newAssets

print("Return on Assets (ROA):")
print("  Before investment: \(roaBefore.formatted(.percent.precision(.fractionLength(2))))")
print("  After investment (Year 1): \(roaAfter.formatted(.percent.precision(.fractionLength(2))))")

let roaChange = roaAfter - roaBefore
if roaChange > 0 {
    print("  ‚úì ROA improves by \(roaChange.formatted(.percent.precision(.fractionLength(2))))")
} else {
    print("  ‚ö†Ô∏è ROA declines by \(abs(roaChange).formatted(.percent.precision(.fractionLength(2))))")
}
print()

// Profit increase
let profitIncrease = annualTaxableIncome - annualTaxes
print("Annual Profit Increase: \(profitIncrease.currency())")
print("Profit increase as % of investment: \((profitIncrease / purchasePrice).percent())")
print()
</code></pre><p><strong>Output:</strong></p><pre><code>PART 4: Financial Statement Impact

Return on Assets (ROA):
  Before investment: 15.00%
  After investment (Year 1): 20.98%
  ‚úì ROA improves by 5.98%

Annual Profit Increase: $390,535.71
Profit increase as % of investment: 78.11%
</code></pre><hr /><h3>Part 6: Sensitivity Analysis</h3><p>What if our assumptions are wrong?</p><pre><code class="language-swift">print("PART 5: Sensitivity Analysis\n")

print("NPV Sensitivity to Production Volume:")
let volumeScenarios = [0.7, 0.8, 0.9, 1.0, 1.1, 1.2]  // 70% to 120% of base

for multiplier in volumeScenarios {
	let adjustedUnits = Int(Double(annualProductionIncrease) * multiplier)
	let adjustedRevenue = Double(adjustedUnits) * contributionMarginPerUnit
	let adjustedOperatingCF = adjustedRevenue - annualMaintenanceCost
	let adjustedTaxableIncome = adjustedOperatingCF - annualDepreciation
	let adjustedTaxes = adjustedTaxableIncome * taxRate
	let adjustedAfterTaxCF = adjustedOperatingCF - adjustedTaxes

	var adjustedCashFlows = [-purchasePrice]
	for _ in 1...usefulLife {
		adjustedCashFlows.append(adjustedAfterTaxCF)
	}
	adjustedCashFlows[adjustedCashFlows.count - 1] += salvageValue

	let adjustedNPV = npv(discountRate: discountRate, cashFlows: adjustedCashFlows)
	let decision = adjustedNPV > 0 ? "Accept ‚úì" : "Reject ‚úó"

	print("  \(multiplier.percent(0)) volume: \(adjustedNPV.currency(0)) - \(decision)")
}
print()

print("NPV Sensitivity to Discount Rate:")
let rateScenarios = [0.08, 0.10, 0.12, 0.15, 0.20]

for rate in rateScenarios {
	let npvAtRate = npv(discountRate: rate, cashFlows: cashFlows)
	let decision = npvAtRate > 0 ? "Accept ‚úì" : "Reject ‚úó"
	print("  \(rate.percent(0)): \(npvAtRate.currency(0)) - \(decision)")
}
print()
</code></pre><p><strong>Output:</strong></p><pre><code>PART 5: Sensitivity Analysis

NPV Sensitivity to Production Volume:
  70% volume: $1,082,683 - Accept ‚úì
  80% volume: $1,301,761 - Accept ‚úì
  90% volume: $1,520,840 - Accept ‚úì
  100% volume: $1,739,919 - Accept ‚úì
  110% volume: $1,958,998 - Accept ‚úì
  120% volume: $2,178,077 - Accept ‚úì

NPV Sensitivity to Discount Rate:
  8%: $1,897,143 - Accept ‚úì
  10%: $1,739,919 - Accept ‚úì
  12%: $1,598,312 - Accept ‚úì
  15%: $1,411,045 - Accept ‚úì
  20%: $1,153,400 - Accept ‚úì
</code></pre><p><strong>The insight</strong>: Investment remains attractive even if volume drops 30% or discount rate doubles. This is a ROBUST investment.</p><hr /><h3>Part 6: Lease vs. Buy Comparison</h3><p>Should we lease instead?</p><pre><code class="language-swift">print("PART 6: Lease vs. Buy Comparison\n")

// Lease terms
let annualLeasePayment = 95_000.0
let leaseMaintenanceIncluded = true  // Lessor covers maintenance

print("Lease Option:")
print("- Annual Lease Payment: \(annualLeasePayment.currency())")
print("- Maintenance: Included")
print()

// Lease cash flows (after-tax)
let leaseMaintenanceSaving = leaseMaintenanceIncluded ? annualMaintenanceCost : 0
let leaseOperatingCF = annualRevenueBenefit - annualLeasePayment + leaseMaintenanceSaving

// Lease payments are tax-deductible
let leaseTaxableIncome = leaseOperatingCF
let leaseTaxes = leaseTaxableIncome * taxRate
let leaseAfterTaxCF = leaseOperatingCF - leaseTaxes

var leaseCashFlows: [Double] = []
for _ in 1...usefulLife {
    leaseCashFlows.append(leaseAfterTaxCF)
}

let leaseNPV = npv(discountRate: discountRate, cashFlows: leaseCashFlows)

print("Lease NPV: \(leaseNPV.currency())")
print("Buy NPV: \(npvValue.currency())")
print()

if npvValue > leaseNPV {
    let advantage = npvValue - leaseNPV
    print("‚úì RECOMMENDATION: Buy")
    print("  Buying creates \(advantage.currency()) more value than leasing")
} else {
    let advantage = leaseNPV - npvValue
    print("‚úì RECOMMENDATION: Lease")
    print("  Leasing creates \(advantage.currency()) more value than buying")
}
print()
</code></pre><p><strong>Output:</strong></p><pre><code>PART 6: Lease vs. Buy Comparison

Lease Option:
- Annual Lease Payment: $95,000.00
- Maintenance: Included

Lease NPV: $2,088,551.67
Buy NPV: $1,739,919.11

‚úì RECOMMENDATION: Lease
  Leasing creates $348,632.57 more value than buying
</code></pre><p><strong>The insight</strong>: Despite buying having excellent returns, leasing is BETTER because maintenance is included and there‚Äôs no upfront capital outlay.</p><hr /><h2>The Results</h2><h3>Business Value</h3><p><strong>Financial Impact</strong>:</p><ul><li><strong>Buy option NPV</strong>: $1.74M (excellent)</li><li><strong>Lease option NPV</strong>: $2.09M (even better!)</li><li><strong>Recommendation</strong>: LEASE the equipment</li><li><strong>Payback</strong>: ~2 years (if buying)</li><li><strong>ROA improvement</strong>: +5.98%</li></ul><p><strong>Risk Analysis</strong>:</p><ul><li>Investment robust to 30% volume decline</li><li>Remains profitable even if discount rate doubles</li><li>Low sensitivity to key assumptions</li></ul><p><strong>Technical Achievement</strong>:</p><ul><li>Combined TVM, depreciation, and financial ratios</li><li>Complete capital budgeting analysis</li><li>Lease vs. buy comparison</li><li>Sensitivity analysis</li></ul><hr /><h2>What Worked</h2><p><strong>Integration Success</strong>:</p><ul><li>TVM functions (<code>npv</code>, <code>irr</code>) handled multi-year cash flows perfectly</li><li>Depreciation calculations integrated cleanly</li><li>Financial ratio analysis (ROA) showed statement impact</li><li>Sensitivity analysis used data tables (from Week 2)</li></ul><p><strong>Decision Quality</strong>:</p><ul><li>Clear recommendation (Lease)</li><li>Quantified value difference ($349k advantage)</li><li>Risk assessment (sensitivity to assumptions)</li><li>Complete financial picture</li></ul><hr /><h2>What Didn‚Äôt Work</h2><p><strong>Initial Challenges</strong>:</p><ul><li>First version forgot to include salvage value in final year cash flow</li><li>Tax calculations were confusing until we separated operating CF from taxable income</li><li>Lease analysis initially didn‚Äôt account for maintenance savings</li></ul><p><strong>Lessons Learned</strong>:</p><ul><li>Capital budgeting requires careful cash flow modeling</li><li>Tax effects materially impact decisions (depreciation tax shield)</li><li>Always compare alternatives (lease vs. buy, not just ‚Äúbuy vs. don‚Äôt buy‚Äù)</li></ul><hr /><h2>The Insight</h2><p><strong>Capital budgeting decisions require combining multiple financial concepts.</strong></p><p>You can‚Äôt just calculate NPV in isolation. You need:</p><ul><li><strong>TVM analysis</strong>: NPV, IRR, payback</li><li><strong>Depreciation</strong>: Tax shield effects</li><li><strong>Financial statement impact</strong>: How does this affect reported earnings and ratios?</li><li><strong>Sensitivity analysis</strong>: What if we‚Äôre wrong?</li><li><strong>Alternative comparison</strong>: Lease vs. buy, new vs. used, etc.</li></ul><p>BusinessMath makes these integrated analyses straightforward with composable functions.</p><blockquote><p><strong>Key Takeaway</strong>: Real business decisions require combining multiple analytical tools. Libraries should make integration seamless.</p></blockquote><hr /><h2>Try It Yourself</h2><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath

print("=== CAPITAL EQUIPMENT DECISION ANALYSIS ===\n")

// Equipment Details
let purchasePrice = 500_000.0
let usefulLife = 7  // years
let salvageValue = 50_000.0

// Operating Assumptions
let annualProductionIncrease = 100_000.0  // units
let contributionMarginPerUnit = 6.0  // $ per unit
let annualMaintenanceCost = 15_000.0

// Financial Assumptions
let discountRate = 0.10  // 10% WACC
let taxRate = 0.25  // 25% corporate tax rate

print("Equipment Investment:")
print("- Purchase Price: \(purchasePrice.currency())")
print("- Useful Life: \(usefulLife) years")
print("- Salvage Value: \(salvageValue.currency())")
print()
print("Operating Assumptions:")
print("- Annual Production Increase: \(annualProductionIncrease.number(0)) units")
print("- Contribution Margin: \(contributionMarginPerUnit.currency())/unit")
print("- Annual Maintenance: \(annualMaintenanceCost.currency())")
print()
print("Financial Assumptions:")
print("- Discount Rate (WACC): \(discountRate.formatted(.percent))")
print("- Tax Rate: \(taxRate.formatted(.percent))")
print()


print("PART 1: Annual Cash Flow Analysis\n")

// Annual contribution margin from increased production
let annualRevenueBenefit = Double(annualProductionIncrease) * contributionMarginPerUnit
print("Annual Revenue Benefit: \(annualRevenueBenefit.currency())")

// Net annual operating cash flow (before tax)
let annualOperatingCashFlow = annualRevenueBenefit - annualMaintenanceCost
print("Annual Operating Cash Flow (pre-tax): \(annualOperatingCashFlow.currency())")

// Calculate depreciation using straight-line method
let annualDepreciation = (purchasePrice - salvageValue) / Double(usefulLife)
print("Annual Depreciation (straight-line): \(annualDepreciation.currency())")

// Taxable income = Operating cash flow - Depreciation
let annualTaxableIncome = annualOperatingCashFlow - annualDepreciation
print("Annual Taxable Income: \(annualTaxableIncome.currency())")

// Taxes
let annualTaxes = annualTaxableIncome * taxRate
print("Annual Taxes: \(annualTaxes.currency())")

// After-tax cash flow = Operating cash flow - Taxes
// (Note: Depreciation is added back because it's non-cash)
let annualAfterTaxCashFlow = annualOperatingCashFlow - annualTaxes
print("Annual After-Tax Cash Flow: \(annualAfterTaxCashFlow.currency())")
print()

print("PART 2: NPV and IRR Analysis\n")

// Build cash flow array
var cashFlows = [-purchasePrice]  // Year 0: Initial investment

// Years 1-7: Annual after-tax cash flows
for _ in 1...usefulLife {
	cashFlows.append(annualAfterTaxCashFlow)
}

// Year 7: Add salvage value (assume no tax on salvage for simplicity)
cashFlows[cashFlows.count - 1] += salvageValue

print("Cash Flow Profile:")
for (year, cf) in cashFlows.enumerated() {
	let sign = cf >= 0 ? "+" : ""
	print("  Year \(year): \(sign)\(cf.currency())")
}
print()

// Calculate NPV
let npvValue = npv(discountRate: discountRate, cashFlows: cashFlows)
print("Net Present Value (NPV): \(npvValue.currency())")

if npvValue > 0 {
	print("‚úì ACCEPT: Positive NPV creates value")
} else {
	print("‚úó REJECT: Negative NPV destroys value")
}
print()

// Calculate IRR
let irrValue = try! irr(cashFlows: cashFlows)
print("Internal Rate of Return (IRR): \(irrValue.formatted(.percent.precision(.fractionLength(2))))")

if irrValue > discountRate {
	print("‚úì ACCEPT: IRR (\(irrValue.formatted(.percent))) > WACC (\(discountRate.formatted(.percent)))")
} else {
	print("‚úó REJECT: IRR < WACC")
}
print()


print("PART 3: Payback Period Analysis\n")

var cumulativeCashFlow = -purchasePrice
var paybackYear = 0

print("Cumulative Cash Flow:")
for (year, cf) in cashFlows.enumerated() {
	if year == 0 {
		cumulativeCashFlow = cf
	} else {
		cumulativeCashFlow += cf
	}

	print("  Year \(year): \(cumulativeCashFlow.currency())")

	if cumulativeCashFlow >= 0 && paybackYear == 0 {
		paybackYear = year
	}
}

if paybackYear > 0 {
	print("\nPayback Period: ~\(paybackYear) years")
	print("‚úì Investment recovered in \(paybackYear) years (well within \(usefulLife) year life)")
} else {
	print("\n‚ö†Ô∏è Investment not recovered within useful life")
}
print()


print("PART 4: Financial Statement Impact\n")

// Assume current company metrics
let currentAssets = 5_000_000.0
let currentNetIncome = 750_000.0

// Year 1 impact
let newAssets = currentAssets + (purchasePrice - annualDepreciation)  // Equipment at book value
let newNetIncome = currentNetIncome + annualTaxableIncome - annualTaxes  // Add equipment contribution

// Calculate ROA before and after
let roaBefore = currentNetIncome / currentAssets
let roaAfter = newNetIncome / newAssets

print("Return on Assets (ROA):")
print("  Before investment: \(roaBefore.formatted(.percent.precision(.fractionLength(2))))")
print("  After investment (Year 1): \(roaAfter.formatted(.percent.precision(.fractionLength(2))))")

let roaChange = roaAfter - roaBefore
if roaChange > 0 {
	print("  ‚úì ROA improves by \(roaChange.formatted(.percent.precision(.fractionLength(2))))")
} else {
	print("  ‚ö†Ô∏è ROA declines by \(abs(roaChange).formatted(.percent.precision(.fractionLength(2))))")
}
print()

// Profit increase
let profitIncrease = annualTaxableIncome - annualTaxes
print("Annual Profit Increase: \(profitIncrease.currency())")
print("Profit increase as % of investment: \((profitIncrease / purchasePrice).percent())")
print()


print("PART 5: Sensitivity Analysis\n")

print("NPV Sensitivity to Production Volume:")
let volumeScenarios = [0.7, 0.8, 0.9, 1.0, 1.1, 1.2]  // 70% to 120% of base

for multiplier in volumeScenarios {
	let adjustedUnits = Int(Double(annualProductionIncrease) * multiplier)
	let adjustedRevenue = Double(adjustedUnits) * contributionMarginPerUnit
	let adjustedOperatingCF = adjustedRevenue - annualMaintenanceCost
	let adjustedTaxableIncome = adjustedOperatingCF - annualDepreciation
	let adjustedTaxes = adjustedTaxableIncome * taxRate
	let adjustedAfterTaxCF = adjustedOperatingCF - adjustedTaxes

	var adjustedCashFlows = [-purchasePrice]
	for _ in 1...usefulLife {
		adjustedCashFlows.append(adjustedAfterTaxCF)
	}
	adjustedCashFlows[adjustedCashFlows.count - 1] += salvageValue

	let adjustedNPV = npv(discountRate: discountRate, cashFlows: adjustedCashFlows)
	let decision = adjustedNPV > 0 ? "Accept ‚úì" : "Reject ‚úó"

	print("  \(multiplier.percent(0)) volume: \(adjustedNPV.currency(0)) - \(decision)")
}
print()

print("NPV Sensitivity to Discount Rate:")
let rateScenarios = [0.08, 0.10, 0.12, 0.15, 0.20]

for rate in rateScenarios {
	let npvAtRate = npv(discountRate: rate, cashFlows: cashFlows)
	let decision = npvAtRate > 0 ? "Accept ‚úì" : "Reject ‚úó"
	print("  \(rate.percent(0)): \(npvAtRate.currency(0)) - \(decision)")
}
print()


print("PART 6: Lease vs. Buy Comparison\n")

// Lease terms
let annualLeasePayment = 95_000.0
let leaseMaintenanceIncluded = true  // Lessor covers maintenance

print("Lease Option:")
print("- Annual Lease Payment: \(annualLeasePayment.currency())")
print("- Maintenance: Included")
print()

// Lease cash flows (after-tax)
let leaseMaintenanceSaving = leaseMaintenanceIncluded ? annualMaintenanceCost : 0
let leaseOperatingCF = annualRevenueBenefit - annualLeasePayment + leaseMaintenanceSaving

// Lease payments are tax-deductible
let leaseTaxableIncome = leaseOperatingCF
let leaseTaxes = leaseTaxableIncome * taxRate
let leaseAfterTaxCF = leaseOperatingCF - leaseTaxes

var leaseCashFlows: [Double] = []
for _ in 1...usefulLife {
	leaseCashFlows.append(leaseAfterTaxCF)
}

let leaseNPV = npv(discountRate: discountRate, cashFlows: leaseCashFlows)

print("Lease NPV: \(leaseNPV.currency())")
print("Buy NPV: \(npvValue.currency())")
print()

if npvValue > leaseNPV {
	let advantage = npvValue - leaseNPV
	print("‚úì RECOMMENDATION: Buy")
	print("  Buying creates \(advantage.currency()) more value than leasing")
} else {
	let advantage = leaseNPV - npvValue
	print("‚úì RECOMMENDATION: Lease")
	print("  Leasing creates \(advantage.currency()) more value than buying")
}
print()

</code></pre></details>
<h3>Modifications to Try</h3><ol><li><strong>Add accelerated depreciation (MACRS)</strong><ul><li>How does tax shield timing change NPV?</li></ul></li><li><strong>Model equipment replacement cycle</strong><ul><li>Should we replace after 7 years or extend?</li></ul></li><li><strong>Add working capital requirements</strong><ul><li>Equipment requires $50k inventory investment</li><li>How does this affect NPV?</li></ul></li><li><strong>Model gradual volume ramp</strong><ul><li>Year 1: 50k units, Year 2: 75k, Year 3: 100k</li><li>More realistic than immediate full production</li></ul></li></ol><hr /><h2>Technical Deep Dives</h2><p>Want to understand the components better?</p><p><strong>DocC Tutorials Used</strong>:</p><ul><li><strong>Time Value of Money</strong>: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/1.3-TimeValueOfMoney.md">1.3</a> - NPV, IRR calculations</li><li><strong>Financial Ratios</strong>: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/2.2-FinancialRatiosGuide.md">2.2</a> - ROA, profitability metrics</li><li><strong>Data Tables</strong>: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/2.1-DataTableAnalysis.md">2.1</a> - Sensitivity analysis</li></ul><p><strong>API References</strong>:</p><ul><li><code>npv(discountRate:cashFlows:)</code></li><li><code>irr(cashFlows:)</code></li><li><code>returnOnAssets(incomeStatement:balanceSheet:)</code></li></ul><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: Week 4 explores investment analysis and portfolio theory.</p><p><strong>Related Case Studies</strong>:</p><ul><li><a href="../../week-01/04-fri-case-retirement"><strong>Case Study #1: Retirement Planning</strong> (Week 1)</a> - TVM + Distributions</li><li><strong>Case Study #3: Option Pricing</strong> (Week 6) - Monte Carlo simulation</li><li><strong>Case Study #4: Portfolio Optimization</strong> (Week 8) - MIDPOINT integration</li></ul><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 3/12</li><li>Posts Published: 12/~48</li><li><strong>Case Studies: 2/6 Complete</strong> üéØ</li><li><strong>Week 3 Complete!</strong> ‚úÖ</li><li>Topics Combined: TVM + Depreciation + Financial Analysis</li><li>Playgrounds: 11 available (9 technical + 2 case studies)</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-03/03-thu-revenue-modeling</guid><title>Building a Revenue Forecasting Model</title><link>https://www.justinpurnell.com/BusinessMath/week-03/03-thu-revenue-modeling</link><description><![CDATA[Part 11 of 12-Week BusinessMath Series]]></description><pubDate>Thu, 22 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[revenue]]></category><category><![CDATA[forecasting]]></category><category><![CDATA[time-series]]></category><category><![CDATA[seasonality]]></category><content:encoded><![CDATA[<p><strong>Part 11 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>Building a complete revenue forecast from historical data</li><li>Extracting and analyzing seasonal patterns</li><li>Fitting trend models to deseasonalized data</li><li>Generating multi-period forecasts with confidence intervals</li><li>Creating scenario analyses (conservative, base, optimistic)</li></ul><hr /><h2>The Problem</h2><p>CFOs and business leaders need revenue forecasts for planning: <strong>How much revenue will we generate next quarter? Next year? What‚Äôs the range of likely outcomes?</strong></p><p>Building accurate forecasts requires:</p><ol><li><strong>Understanding historical patterns</strong> (is there seasonal variance?)</li><li><strong>Identifying the underlying trend</strong> (are we growing linearly or exponentially?)</li><li><strong>Projecting forward</strong> (combining trend and seasonality)</li><li><strong>Quantifying uncertainty</strong> (what‚Äôs the confidence interval?)</li><li><strong>Scenario planning</strong> (conservative vs. optimistic cases)</li></ol><p>Doing this properly in spreadsheets is tedious and error-prone. <strong>You need a systematic, reproducible forecasting workflow.</strong></p><hr /><h2>The Solution</h2><p>Let‚Äôs build a production-ready revenue forecast using BusinessMath, combining growth modeling, seasonality extraction, and trend fitting.</p><h3>Step 1: Prepare Historical Data</h3><p>Start with 2 years of quarterly revenue:</p><pre><code class="language-swift">import BusinessMath

// Define periods (8 quarters: 2023-2024)
let periods = [
    Period.quarter(year: 2023, quarter: 1),
    Period.quarter(year: 2023, quarter: 2),
    Period.quarter(year: 2023, quarter: 3),
    Period.quarter(year: 2023, quarter: 4),
    Period.quarter(year: 2024, quarter: 1),
    Period.quarter(year: 2024, quarter: 2),
    Period.quarter(year: 2024, quarter: 3),
    Period.quarter(year: 2024, quarter: 4)
]

// Historical revenue (showing both growth and Q4 spike)
let revenue: [Double] = [
    800_000,    // Q1 2023
    850_000,    // Q2 2023
    820_000,    // Q3 2023
    1_100_000,  // Q4 2023 (holiday spike)
    900_000,    // Q1 2024
    950_000,    // Q2 2024
    920_000,    // Q3 2024
    1_250_000   // Q4 2024 (holiday spike + growth)
]

let historical = TimeSeries(periods: periods, values: revenue)

print("Loaded \(historical.count) quarters of historical data")
print("Total historical revenue: \(historical.reduce(0, +).currency())")
</code></pre><p><strong>Output:</strong></p><pre><code>Loaded 8 quarters of historical data
Total historical revenue: $7,590,000
</code></pre><hr /><h3>Step 2: Analyze Historical Patterns</h3><p>Before modeling, understand the data:</p><pre><code class="language-swift">// Calculate quarter-over-quarter growth
let qoqGrowth = historical.growthRate(lag: 1)

print("\nQuarter-over-Quarter Growth:")
for (i, growth) in qoqGrowth.enumerated() {
    let period = periods[i + 1]
    print("\(period.label): \(growth.percent(1))")
}

// Calculate year-over-year growth
let yoyGrowth = historical.growthRate(lag: 4)  // 4 quarters = 1 year

print("\nYear-over-Year Growth:")
for (i, growth) in yoyGrowth.valuesArray.enumerated() {
    let period = periods[i + 4]
    print("\(period.label): \(growth.percent(1))")
}

// Calculate overall CAGR
let totalYears = 2.0
let cagrValue = cagr(
    beginningValue: revenue[0],
    endingValue: revenue[revenue.count - 1],
    years: totalYears
)
print("\nOverall CAGR: \(cagrValue.percent(1))")
</code></pre><p><strong>Output:</strong></p><pre><code>Quarter-over-Quarter Growth:
2023-Q2: +6.3%
2023-Q3: -3.5%
2023-Q4: +34.1%  ‚Üê Holiday spike
2024-Q1: -18.2%  ‚Üê Post-holiday drop
2024-Q2: +5.6%
2024-Q3: -3.2%
2024-Q4: +35.9%  ‚Üê Holiday spike again

Year-over-Year Growth:
2024-Q1: +12.5%
2024-Q2: +11.8%
2024-Q3: +12.2%
2024-Q4: +13.6%

Overall CAGR: 25.0%
</code></pre><p><strong>The insight</strong>: Q-o-Q growth is volatile (swings from -18% to +36%), but Y-o-Y growth is steady (~12%). This suggests <strong>strong seasonality with underlying growth</strong>.</p><hr /><h3>Step 3: Extract Seasonal Pattern</h3><p>Identify the recurring pattern:</p><pre><code class="language-swift">// Calculate seasonal indices (4 quarters per year)
let seasonality = try seasonalIndices(timeSeries: historical, periodsPerYear: 4)

print("\nSeasonal Indices:")
let quarters = ["Q1", "Q2", "Q3", "Q4"]
for (i, index) in seasonality.enumerated() {
    let pct = (index - 1.0)
    let direction = pct > 0 ? "above" : "below"
    print("\(quarters[i]): \(index.number(3)) (\(abs(pct).percent(1)) \(direction) average)")
}
</code></pre><p><strong>Output:</strong></p><pre><code>Seasonal Indices:
Q1: 0.942 (5.8% below average)
Q2: 0.968 (3.2% below average)
Q3: 0.908 (9.2% below average)
Q4: 1.183 (18.3% above average)  ‚Üê Holiday seasonality confirmed!
</code></pre><p><strong>The pattern</strong>: Q4 is 18% above average (holiday shopping), Q1-Q3 are all below average, with Q3 the lowest (summer slowdown).</p><hr /><h3>Step 4: Deseasonalize the Data</h3><p>Remove seasonal effects to see the underlying trend:</p><pre><code class="language-swift">let deseasonalized = try seasonallyAdjust(timeSeries: historical, indices: seasonality)

print("\nDeseasonalized Revenue:")
print("Original ‚Üí Deseasonalized")
for i in 0...(historical.count - 1) {
    let original = historical.valuesArray[i]
    let adjusted = deseasonalized.valuesArray[i]
    let period = periods[i]
    print("\(period.label): \(original.currency(0)) ‚Üí \(adjusted.currency(0))")
}
</code></pre><p><strong>Output:</strong></p><pre><code>Deseasonalized Revenue:
Original ‚Üí Deseasonalized
2023-Q1: $800,000 ‚Üí $849,566
2023-Q2: $850,000 ‚Üí $878,143
2023-Q3: $820,000 ‚Üí $903,399
2023-Q4: $1,100,000 ‚Üí $930,069
2024-Q1: $900,000 ‚Üí $955,762
2024-Q2: $950,000 ‚Üí $981,454
2024-Q3: $920,000 ‚Üí $1,013,570
2024-Q4: $1,250,000 ‚Üí $1,056,897
</code></pre><p><strong>The insight</strong>: After removing seasonality, the revenue trend is smooth and steadily increasing: $850k ‚Üí $878k ‚Üí $903k ‚Üí ‚Ä¶ ‚Üí $1,060k.</p><hr /><h3>Step 5: Fit Trend Model</h3><p>Fit a linear trend to the deseasonalized data:</p><pre><code class="language-swift">var linearModel = LinearTrend<Double>()
try linearModel.fit(to: deseasonalized)

print("\nLinear Trend Model Fitted")
print("Indicates steady absolute growth per quarter")
</code></pre><hr /><h3>Step 6: Generate Forecast</h3><p>Project forward and reapply seasonality:</p><pre><code class="language-swift">let forecastPeriods = 4  // Forecast next 4 quarters (2025)

// Step 6a: Project trend forward
let trendForecast = try linearModel.project(periods: forecastPeriods)

print("\nTrend Forecast (deseasonalized):")
for (period, value) in zip(trendForecast.periods, trendForecast.valuesArray) {
    print("\(period.label): \(value.currency(0))")
}

// Step 6b: Reapply seasonal pattern
let finalForecast = try applySeasonal(timeSeries: trendForecast, indices: seasonality)

print("\nFinal Forecast (with seasonality):")
var forecastTotal = 0.0
for (period, value) in zip(finalForecast.periods, finalForecast.valuesArray) {
    forecastTotal += value
    print("\(period.label): \(value.currency(0))")
}

print("\nForecast Summary:")
print("Total 2025 revenue: \(forecastTotal.currency(0))")
print("Average quarterly revenue: \((forecastTotal / 4).currency(0))")

// Compare to 2024
let revenue2024 = revenue[4...7].reduce(0.0, +)
let forecastGrowth = (forecastTotal - revenue2024) / revenue2024
print("Growth vs 2024: \(forecastGrowth.percent(1))")
</code></pre><p><strong>Output:</strong></p><pre><code>Trend Forecast (deseasonalized):
2025-Q1: $1,074,052
2025-Q2: $1,102,485
2025-Q3: $1,130,917
2025-Q4: $1,159,349

Final Forecast (with seasonality):
2025-Q1: $1,011,389  ‚Üê Deseasonalized √ó Q1 index (0.942)
2025-Q2: $1,067,152  ‚Üê Deseasonalized √ó Q2 index (0.968)
2025-Q3: $1,026,514  ‚Üê Deseasonalized √ó Q3 index (0.908)
2025-Q4: $1,371,171  ‚Üê Deseasonalized √ó Q4 index (1.183)

Forecast Summary:
Total 2025 revenue: $4,476,226
Average quarterly revenue: $1,119,057
Growth vs 2024: 11.3%
</code></pre><p><strong>The insight</strong>: The forecast shows continued steady growth (~11%) with the expected Q4 spike.</p><hr /><h3>Step 7: Scenario Analysis</h3><p>Create conservative and optimistic scenarios by adjusting the growth rate:</p><pre><code class="language-swift">print("\nScenario Analysis for 2025:")

// Base case parameters (from the fitted linear model)
let baseSlope = linearModel.slopeValue!
let baseIntercept = linearModel.interceptValue!

// Conservative: Reduce growth rate by 50%
let conservativeSlope = baseSlope * 0.5
var conservativePeriods: [Period] = []
var conservativeValues: [Double] = []
for i in 1...forecastPeriods {
    let index = Double(deseasonalized.count + i - 1)
    let trendValue = baseIntercept + conservativeSlope * index
    conservativePeriods.append(Period.quarter(year: 2025, quarter: i))
    conservativeValues.append(trendValue)
}
let conservativeForecast = TimeSeries(
    periods: conservativePeriods,
    values: conservativeValues
)
let conservativeSeasonalForecast = try applySeasonal(
    timeSeries: conservativeForecast,
    indices: seasonality
)

// Optimistic: Increase growth rate by 50%
let optimisticSlope = baseSlope * 1.5
var optimisticPeriods: [Period] = []
var optimisticValues: [Double] = []
for i in 1...forecastPeriods {
    let index = Double(deseasonalized.count + i - 1)
    let trendValue = baseIntercept + optimisticSlope * index
    optimisticPeriods.append(Period.quarter(year: 2025, quarter: i))
    optimisticValues.append(trendValue)
}
let optimisticForecast = TimeSeries(
    periods: optimisticPeriods,
    values: optimisticValues
)
let optimisticSeasonalForecast = try applySeasonal(
    timeSeries: optimisticForecast,
    indices: seasonality
)

let conservativeTotal = conservativeSeasonalForecast.reduce(0, +)
let optimisticTotal = optimisticSeasonalForecast.reduce(0, +)

print("Conservative: \(conservativeTotal.currency(0)) (growth dampened 50%)")
print("Base Case: \(forecastTotal.currency(0))")
print("Optimistic: \(optimisticTotal.currency(0)) (growth amplified 50%)")
</code></pre><p><strong>Output:</strong></p><pre><code>Scenario Analysis for 2025:
Conservative: $3,931,302 (growth dampened 50%)
Base Case: $4,476,226
Optimistic: $5,021,150 (growth amplified 50%)
</code></pre><blockquote><p><strong>Note</strong>: The exact values depend on your fitted model‚Äôs slope parameter. Run the playground to see actual results with your data. The key insight is that dampening the growth rate by 50% produces noticeably lower forecasts, while amplifying by 50% produces higher forecasts.</p></blockquote><hr /><h2>Complete Workflow</h2><p>Here‚Äôs the end-to-end forecast in one place:</p><pre><code class="language-swift">import BusinessMath

func buildRevenueModel() throws {
    // 1. Prepare data
    let periods = (1...8).map { i in
        let year = 2023 + (i - 1) / 4
        let quarter = ((i - 1) % 4) + 1
        return Period.quarter(year: year, quarter: quarter)
    }

    let revenue: [Double] = [
        800_000, 850_000, 820_000, 1_100_000,
        900_000, 950_000, 920_000, 1_250_000
    ]

    let historical = TimeSeries(periods: periods, values: revenue)

    // 2. Extract seasonality
    let seasonalIndices = try seasonalIndices(timeSeries: historical, periodsPerYear: 4)

    // 3. Deseasonalize
    let deseasonalized = try seasonallyAdjust(timeSeries: historical, indices: seasonalIndices)

    // 4. Fit trend
    var model = LinearTrend<Double>()
    try model.fit(to: deseasonalized)

    // 5. Generate forecast
    let trendForecast = try model.project(periods: 4)
    let finalForecast = try applySeasonal(timeSeries: trendForecast, indices: seasonalIndices)

    // 6. Present results
    print("Revenue Forecast:")
    for (period, value) in zip(finalForecast.periods, finalForecast.valuesArray) {
        print("\(period.label): \(value.currency(0))")
    }

    let total = finalForecast.reduce(0, +)
    print("Total 2025 forecast: \(total.currency(0))")
}

try buildRevenueModel()
</code></pre><hr /><h2>Try It Yourself</h2><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath

// Define periods (8 quarters: 2023-2024)
let periods = [
	Period.quarter(year: 2023, quarter: 1),
	Period.quarter(year: 2023, quarter: 2),
	Period.quarter(year: 2023, quarter: 3),
	Period.quarter(year: 2023, quarter: 4),
	Period.quarter(year: 2024, quarter: 1),
	Period.quarter(year: 2024, quarter: 2),
	Period.quarter(year: 2024, quarter: 3),
	Period.quarter(year: 2024, quarter: 4)
]

// Historical revenue (showing both growth and Q4 spike)
let revenue: [Double] = [
	800_000,    // Q1 2023
	850_000,    // Q2 2023
	820_000,    // Q3 2023
	1_100_000,  // Q4 2023 (holiday spike)
	900_000,    // Q1 2024
	950_000,    // Q2 2024
	920_000,    // Q3 2024
	1_250_000   // Q4 2024 (holiday spike + growth)
]

let historical = TimeSeries(periods: periods, values: revenue)

print("Loaded \(historical.count) quarters of historical data")
print("Total historical revenue: \(historical.reduce(0, +).currency())")


	// Calculate quarter-over-quarter growth
	let qoqGrowth = historical.growthRate(lag: 1)

	print("\nQuarter-over-Quarter Growth:")
	for (i, growth) in qoqGrowth.enumerated() {
		let period = periods[i + 1]
		print("\(period.label): \(growth.percent(1))")
	}

	// Calculate year-over-year growth
	let yoyGrowth = historical.growthRate(lag: 4)  // 4 quarters = 1 year

	print("\nYear-over-Year Growth:")
	for (i, growth) in yoyGrowth.valuesArray.enumerated() {
		let period = periods[i + 4]
		print("\(period.label): \(growth.percent(1))")
	}

	// Calculate overall CAGR
	let totalYears = 2.0
	let cagrValue = cagr(
		beginningValue: revenue[0],
		endingValue: revenue[revenue.count - 1],
		years: totalYears
	)
	print("\nOverall CAGR: \(cagrValue.percent(1))")

	// Calculate seasonal indices (4 quarters per year)
	let seasonality = try seasonalIndices(timeSeries: historical, periodsPerYear: 4)

	print("\nSeasonal Indices:")
	let quarters = ["Q1", "Q2", "Q3", "Q4"]
	for (i, index) in seasonality.enumerated() {
		let pct = (index - 1.0)
		let direction = pct > 0 ? "above" : "below"
		print("\(quarters[i]): \(index.number(3)) (\(abs(pct).percent(1)) \(direction) average)")
	}

let deseasonalized = try seasonallyAdjust(timeSeries: historical, indices: seasonality)

print("\nDeseasonalized Revenue:")
print("Original ‚Üí Deseasonalized")
for i in 0..<historical.count {
	let original = historical.valuesArray[i]
	let adjusted = deseasonalized.valuesArray[i]
	let period = periods[i]
	print("\(period.label): \(original.currency(0)) ‚Üí \(adjusted.currency(0))")
}

var linearModel = LinearTrend<Double>()
try linearModel.fit(to: deseasonalized)

print("\nLinear Trend Model Fitted")
print("Indicates steady absolute growth per quarter")

let forecastPeriods = 4  // Forecast next 4 quarters (2025)

// Step 6a: Project trend forward
let trendForecast = try linearModel.project(periods: forecastPeriods)

print("\nTrend Forecast (deseasonalized):")
for (period, value) in zip(trendForecast.periods, trendForecast.valuesArray) {
	print("\(period.label): \(value.currency(0))")
}

// Step 6b: Reapply seasonal pattern
let finalForecast = try applySeasonal(timeSeries: trendForecast, indices: seasonality)

print("\nFinal Forecast (with seasonality):")
var forecastTotal = 0.0
for (period, value) in zip(finalForecast.periods, finalForecast.valuesArray) {
	forecastTotal += value
	print("\(period.label): \(value.currency(0))")
}

print("\nForecast Summary:")
print("Total 2025 revenue: \(forecastTotal.currency(0))")
print("Average quarterly revenue: \((forecastTotal / 4).currency(0))")

// Compare to 2024
let revenue2024 = revenue[4...7].reduce(0.0, +)
let forecastGrowth = (forecastTotal - revenue2024) / revenue2024
print("Growth vs 2024: \(forecastGrowth.percent(1))")

print("\nScenario Analysis for 2025:")

// Base case parameters (from the fitted linear model)
let baseSlope = linearModel.slopeValue!
let baseIntercept = linearModel.interceptValue!

// Conservative: Reduce growth rate by 50%
let conservativeSlope = baseSlope * 0.5
var conservativePeriods: [Period] = []
var conservativeValues: [Double] = []
for i in 1...forecastPeriods {
	let index = Double(deseasonalized.count + i - 1)
	let trendValue = baseIntercept + conservativeSlope * index
	conservativePeriods.append(Period.quarter(year: 2025, quarter: i))
	conservativeValues.append(trendValue)
}
let conservativeForecast = TimeSeries(
	periods: conservativePeriods,
	values: conservativeValues
)
let conservativeSeasonalForecast = try applySeasonal(
	timeSeries: conservativeForecast,
	indices: seasonality
)

// Optimistic: Increase growth rate by 50%
let optimisticSlope = baseSlope * 1.5
var optimisticPeriods: [Period] = []
var optimisticValues: [Double] = []
for i in 1...forecastPeriods {
	let index = Double(deseasonalized.count + i - 1)
	let trendValue = baseIntercept + optimisticSlope * index
	optimisticPeriods.append(Period.quarter(year: 2025, quarter: i))
	optimisticValues.append(trendValue)
}
let optimisticForecast = TimeSeries(
	periods: optimisticPeriods,
	values: optimisticValues
)
let optimisticSeasonalForecast = try applySeasonal(
	timeSeries: optimisticForecast,
	indices: seasonality
)

let conservativeTotal = conservativeSeasonalForecast.reduce(0, +)
let optimisticTotal = optimisticSeasonalForecast.reduce(0, +)

print("Conservative: \(conservativeTotal.currency(0)) (growth dampened 50%)")
print("Base Case: \(forecastTotal.currency(0))")
print("Optimistic: \(optimisticTotal.currency(0)) (growth amplified 50%)")


func buildRevenueModel() throws {
	// 1. Prepare data
	let periods = (1...8).map { i in
		let year = 2023 + (i - 1) / 4
		let quarter = ((i - 1) % 4) + 1
		return Period.quarter(year: year, quarter: quarter)
	}

	let revenue: [Double] = [
		800_000, 850_000, 820_000, 1_100_000,
		900_000, 950_000, 920_000, 1_250_000
	]

	let historical = TimeSeries(periods: periods, values: revenue)

	// 2. Extract seasonality
	let seasonalIndices = try seasonalIndices(timeSeries: historical, periodsPerYear: 4)

	// 3. Deseasonalize
	let deseasonalized = try seasonallyAdjust(timeSeries: historical, indices: seasonalIndices)

	// 4. Fit trend
	var model = LinearTrend<Double>()
	try model.fit(to: deseasonalized)

	// 5. Generate forecast
	let trendForecast = try model.project(periods: 4)
	let finalForecast = try applySeasonal(timeSeries: trendForecast, indices: seasonalIndices)

	// 6. Present results
	print("Revenue Forecast:")
	for (period, value) in zip(finalForecast.periods, finalForecast.valuesArray) {
		print("\(period.label): \(value.currency(0))")
	}

	let total = finalForecast.reduce(0, +)
	print("Total 2025 forecast: \(total.currency(0))")
}

try buildRevenueModel()
</code></pre></details>
<p>‚Üí Full API Reference: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/3.3-BuildingRevenueModel.md">BusinessMath Docs ‚Äì 3.3 Revenue Forecasting</a></p><p><strong>Modifications to try</strong>:</p><ol><li>Use your company‚Äôs historical revenue data</li><li>Try exponential trend instead of linear</li><li>Create monthly forecasts instead of quarterly</li><li>Add confidence intervals to forecasts</li></ol><hr /><h2>Real-World Application</h2><p>Think about using this for annual planning:</p><ul><li><strong>Historical data</strong>: 3 years of monthly MRR</li><li><strong>Seasonality</strong>: Summer slump (July-August), year-end spike (December)</li><li><strong>Trend</strong>: Exponential (consistent % growth)</li><li><strong>Forecast horizon</strong>: 12 months</li><li><strong>Scenarios</strong>: Conservative (5% CAGR), Base (12% CAGR), Optimistic (20% CAGR)</li></ul><p>Rather than saying ‚Äúwe‚Äôre growing 10% per month, so we‚Äôll hit $30mm,‚Äù it‚Äôs far more credible to say: ‚ÄúOur base case projects $24M ARR, with 80% confidence interval of $22M-$26M.‚Äù</p><hr /><p><code>‚òÖ Insight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><p><strong>Why Forecast with Scenarios?</strong></p><p>Point forecasts are always wrong. The question is: how wrong?</p><p>Scenarios communicate uncertainty:</p><ul><li><strong>Conservative</strong>: What if growth slows?</li><li><strong>Base</strong>: What if trends continue?</li><li><strong>Optimistic</strong>: What if we accelerate?</li></ul><p>Present all three with probabilities (e.g., 20% / 60% / 20%).</p><p>This is a much more nuanced and thoughful approach, that sets realistic expectations and prepares stakeholders for variance.</p><p><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><hr /><h3>üìù Development Note</h3><p>The hardest part of implementing revenue forecasting wasn‚Äôt the math‚Äîit was deciding how opinionated to be about the workflow.</p><p><strong>Option 1</strong>: Provide primitive functions (<code>seasonalIndices</code>, <code>fit</code>, <code>project</code>) and let users compose them.</p><p><strong>Option 2</strong>: Provide a high-level <code>forecast(historical:periods:)</code> function that does everything automatically.</p><p>We chose <strong>Option 1</strong> because forecasting requires judgment:</p><ul><li>Which trend model? (Linear vs. exponential vs. logistic)</li><li>How much seasonality damping? (Full seasonal pattern vs. muted)</li><li>Confidence intervals? (95% vs. 80%?)</li></ul><p>A fully automated forecast hides these choices, producing results users don‚Äôt understand.</p><p><strong>The lesson</strong>: For workflows requiring judgment, provide composable primitives rather than black-box automation.</p><p><strong>Related Methodology</strong>: <a href="../../week-02/02-tue-documentation-as-design">Documentation as Design</a> (Week 2) - Designing learnable APIs</p><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: <a href="../04-fri-case-capital-equipment">Capital Equipment Decision (Friday)</a> - Case study combining depreciation + TVM + financial ratios.</p><p><strong>Week 4</strong>: We‚Äôll explore investment analysis and portfolio optimization.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 3/12</li><li>Posts Published: 11/~48</li><li>Topics Covered: Foundation + Analysis + Operational Models (in progress)</li><li>Playgrounds: 10 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-03/02.5-wed-tooling-guides</guid><title>The Supporting Cast: Coding Rules, DocC Guidelines, and Testing Standards</title><link>https://www.justinpurnell.com/BusinessMath/week-03/02.5-wed-tooling-guides</link><description><![CDATA[Development Journey Series]]></description><pubDate>Wed, 21 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[ai-collaboration]]></category><category><![CDATA[coding-standards]]></category><category><![CDATA[documentation]]></category><category><![CDATA[testing]]></category><category><![CDATA[development-journey]]></category><content:encoded><![CDATA[<p><strong>Development Journey Series</strong></p><hr /><h2>The Context</h2><p>In the previous post, we discussed how the Master Plan serves as the project‚Äôs memory across sessions. But the master plan only answers ‚Äúwhat to build next‚Äù‚Äîit doesn‚Äôt answer <strong>how to build it consistently</strong>.</p><p>After a few weeks of BusinessMath development, I had a different problem: <strong>pattern drift</strong>.</p><ul><li>Week 1: Functions used <code>guard</code> statements for validation</li><li>Week 3: Some functions started using early returns with <code>if !condition</code></li><li>Week 5: Parameter naming became inconsistent (<code>rate</code> vs. <code>r</code> vs. <code>discountRate</code>)</li><li>Week 7: DocC comments had three different documentation styles</li></ul><p>Each individual choice made sense in isolation. But across 200+ tests and 11 topic areas, the inconsistency was creating friction:</p><ul><li>‚ÄúWait, did we decide to use external parameter labels?‚Äù</li><li>‚ÄúShould this throw an error or return zero for empty input?‚Äù</li><li>‚ÄúWhat‚Äôs the format for DocC mathematical formulas?‚Äù</li></ul><p>Without explicit standards, every decision becomes a mini research project. AI doesn‚Äôt remember past decisions, so it defaults to whatever seems reasonable <em>right now</em>.</p><hr /><h2>The Solution</h2><p><strong>Create living standards documents that serve as the project‚Äôs consistency engine.</strong></p><p>We developed three core documents:</p><ol><li><strong>CODING_RULES.md</strong> - How to write code</li><li><strong>DOCC_GUIDELINES.md</strong> - How to document APIs</li><li><strong>TEST_DRIVEN_DEVELOPMENT.md</strong> - How to test code</li></ol><p>These aren‚Äôt heavyweight ‚Äúprocess manuals‚Äù‚Äîthey‚Äôre quick-reference guides that answer common questions in seconds.</p><hr /><h2>Document 1: Coding Rules</h2><p><strong>The Problem It Solves</strong>: ‚ÄúHow should I structure this code?‚Äù</p><h3>What It Contains</h3><pre><code class="language-markdown"># Coding Rules for BusinessMath Library

## 1. Generic Programming
- Use `<T: Real>` for all numeric functions
- Enables flexibility across Float, Double, Float16, etc.

## 2. Function Signatures
- Public API: All user-facing functions marked `public`
- Descriptive parameter labels
- Default parameters for common cases

## 3. Guard Clauses & Validation
- Use `guard` for input validation
- Return sensible defaults for empty inputs (e.g., `T(0)`)
- Throw errors for truly invalid cases

## 4. Formatting Rules
- NEVER use String(format:) for number formatting
- ALWAYS use Swift's formatted() API
- Respect user locales automatically
</code></pre><h3>Real Example: The String Formatting Rule</h3><p>Early in the project, we used C-style formatting:</p><pre><code class="language-swift">// Week 2 code
let output = String(format: "%.2f", value)
</code></pre><p>This created problems:</p><ul><li>Doesn‚Äôt respect user locales</li><li>Breaks with non-decimal numeric types</li><li>Error-prone format strings</li></ul><p>We established a rule:</p><pre><code class="language-swift">// RULE: Never use String(format:)
// ALWAYS use formatted() API

// Correct approach
let output = value.formatted(.number.precision(.fractionLength(2)))
</code></pre><p><strong>Before the rule</strong>: 30 minutes per session debating formatting approaches.</p><p><strong>After the rule</strong>: 0 minutes. ‚ÄúCheck CODING_RULES.md. Use formatted().‚Äù</p><hr /><h3>Why This Worked</h3><h4>1. AI Can Follow Rules It Can Read</h4><p>When starting a session:</p><blockquote><p>‚ÄúRead CODING_RULES.md. Implement the IRR function following these standards.‚Äù</p></blockquote><p>AI responds:</p><blockquote><p>‚ÄúUsing <code><T: Real></code> generic constraint, <code>guard</code> for validation, and Swift‚Äôs formatted() API as specified in CODING_RULES.md.‚Äù</p></blockquote><p><strong>Result</strong>: Consistent code on first try.</p><h4>2. Rules Prevent Regression</h4><p>Week 10, implementing a new feature:</p><pre><code class="language-swift">// AI's first attempt
let result = String(format: "%.4f", value)
</code></pre><p>My review:</p><blockquote><p>‚ÄúThis violates CODING_RULES.md section 4. Use formatted() API.‚Äù</p></blockquote><p>AI immediately corrects:</p><pre><code class="language-swift">let result = value.formatted(.number.precision(.fractionLength(4)))
</code></pre><p><strong>Without the documented rule</strong>, I‚Äôd have to re-explain <em>why</em> every single time.</p><h4>3. Rules Capture Hard-Won Lessons</h4><p>The string formatting rule exists because we spent 2 hours debugging locale issues in Week 2. The rule captures that lesson so it‚Äôs never repeated.</p><hr /><h2>Document 2: DocC Guidelines</h2><p><strong>The Problem It Solves</strong>: ‚ÄúHow should I document this API?‚Äù</p><h3>What It Contains</h3><pre><code class="language-markdown"># DocC Documentation Guidelines

## Required for All Public APIs

1. Brief one-line summary
2. Detailed explanation including:
   - What problem it solves
   - How it works (if non-obvious)
   - When to use it
3. Parameter documentation
4. Return value documentation
5. Throws documentation (if applicable)
6. Usage example
7. Mathematical formula (for math functions)
8. Excel equivalent (if applicable)
9. See Also links

## Documentation Template

///
/// Brief one-line summary.
///
/// Detailed explanation...
///
/// - Parameters:
///   - param1: Description with valid ranges
/// - Returns: Description of return value and guarantees
/// - Throws: Specific errors and when they occur
///
/// ## Usage Example
/// 
/// let result = function(param: value)
/// // Output: expected result
/// 
///
/// ## Mathematical Formula
/// [LaTeX or ASCII math notation]
///
/// - SeeAlso:
///   - ``RelatedType``
///   - ``relatedFunction(_:)``
</code></pre><h3>Real Example: The Formula Format</h3><p>Week 4, documenting the NPV function. First attempt:</p><pre><code class="language-swift">/// NPV = sum of (cash flow / (1 + rate)^period)
</code></pre><p><strong>Problems</strong>:</p><ul><li>Unclear notation</li><li>No variable definitions</li><li>Doesn‚Äôt render well in DocC</li></ul><p>After establishing guidelines:</p><pre><code class="language-swift">/// ## Mathematical Formula
/// NPV is calculated as:
/// 
/// NPV = Œ£ (CF‚Çú / (1 + r)·µó)
/// 
/// where:
/// - CF‚Çú = cash flow at time t
/// - r = discount rate
/// - t = time period
</code></pre><p><strong>Result</strong>: Consistent, readable mathematical notation across all 200+ documented functions.</p><hr /><h3>Why This Worked</h3><h4>1. Documentation as Design Tool</h4><p>Writing DocC comments before implementation forced clarification:</p><p><strong>Question</strong>: ‚ÄúWhat errors can calculateIRR throw?‚Äù</p><p><strong>DocC forces answer</strong>:</p><pre><code class="language-swift">/// - Throws: `FinancialError.convergenceFailure` if calculation
///   does not converge within `maxIterations`.
///   `FinancialError.invalidInput` if cash flows array is empty.
</code></pre><p>Now I know <em>exactly</em> what to implement.</p><h4>2. Examples Must Compile</h4><p>The guidelines require runnable examples:</p><pre><code class="language-swift">/// ## Usage Example
/// 
/// let cashFlows = [-1000.0, 300.0, 400.0, 500.0]
/// let irr = try calculateIRR(cashFlows: cashFlows)
/// print(irr.formatted(.percent))  // Output: 12.5%
/// 
</code></pre><p><strong>Rule</strong>: Every example must run successfully in a playground.</p><p>We manually verified all of the documented examples to make sure we had correct values and an ergonomic approach for users.</p><p>This caught:</p><ul><li>API design issues (awkward to use ‚Üí redesign)</li><li>Missing error handling (forgot to mark <code>throws</code>)</li><li>Incorrect output claims (example output didn‚Äôt match reality)</li></ul><h4>3. Prevents Documentation Drift</h4><p>Week 15, adding async versions of functions. The template ensures consistent documentation:</p><pre><code class="language-swift">/// [Async version follows same structure as sync version]
/// - Same brief summary
/// - Same parameter docs
/// - Added: Concurrency section
/// - Same usage examples (with await)
</code></pre><p><strong>Without guidelines</strong>: 15 different documentation styles for 15 async functions.</p><p><strong>With guidelines</strong>: Perfect consistency.</p><hr /><h2>Document 3: Test-Driven Development Standards</h2><p><strong>The Problem It Solves</strong>: ‚ÄúHow should I test this function?‚Äù</p><h3>What It Contains</h3><pre><code class="language-markdown"># Test-Driven Development Standards

## Test Structure (Swift Testing)

- Use `@Test` attribute with descriptive names
- Use `@Suite` to group related tests
- Use `#expect` for assertions
- Use parameterized tests for multiple scenarios

## Test Organization

Tests mirror source structure:

Tests/BusinessMathTests/
‚îú‚îÄ‚îÄ Time Series Tests/
‚îÇ   ‚îú‚îÄ‚îÄ PeriodTests.swift
‚îÇ   ‚îî‚îÄ‚îÄ TVM Tests/
‚îÇ       ‚îî‚îÄ‚îÄ NPVTests.swift


## RED-GREEN-REFACTOR Cycle

1. RED: Write failing test
2. GREEN: Minimal implementation to pass
3. REFACTOR: Improve code quality (tests still pass)

## Deterministic Testing for Random Functions

**Always use seeded random number generators**


@Test("Monte Carlo with seed is deterministic")
func testDeterministic() {
    let seed: UInt64 = 12345
    let result1 = runSimulation(trials: 10000, seed: seed)
    let result2 = runSimulation(trials: 10000, seed: seed)
    #expect(result1 == result2)  // Must be identical
}
</code></pre><h3>Real Example: The Deterministic Testing Rule</h3><p>Week 6, implementing Monte Carlo simulations. First test:</p><pre><code class="language-swift">@Test("Monte Carlo converges to expected value")
func testConvergence() {
    let result = runSimulation(trials: 10000)
    #expect(abs(result.mean - 100.0) < 1.0)
}
</code></pre><p><strong>Problem</strong>: Flaky test. Sometimes passed, sometimes failed (randomness).</p><p>After establishing the rule:</p><pre><code class="language-swift">@Test("Monte Carlo with seed converges to expected value")
func testConvergence() {
    let seed: UInt64 = 12345
    let result = runSimulation(trials: 10000, seed: seed)
    #expect(abs(result.mean - 100.023) < 0.001)  // Exact value
}
</code></pre><p><strong>Result</strong>: 100% reliable tests. CI never flakes.</p><hr /><h3>Why This Worked</h3><h4>1. Tests as Specifications</h4><p>The RED-GREEN-REFACTOR rule means tests are written <em>before</em> code:</p><pre><code class="language-swift">// STEP 1: Write test (RED)
@Test("IRR calculates correctly")
func testIRR() {
    let cashFlows = [-1000.0, 300.0, 400.0, 500.0]
    let result = try calculateIRR(cashFlows: cashFlows)
    #expect(abs(result - 0.125) < 0.001)  // 12.5%
}
// ‚ùå Test fails: calculateIRR doesn't exist yet

// STEP 2: Implement function (GREEN)
public func calculateIRR<T: Real>(cashFlows: [T]) throws -> T {
    // ... implementation ...
}
// ‚úÖ Test passes

// STEP 3: Refactor (tests still pass)
// Extract validation logic, improve performance, etc.
// ‚úÖ Tests still pass after refactoring
</code></pre><p><strong>The test specifies behavior before implementation exists.</strong></p><h4>2. Parameterized Tests Prevent Duplication</h4><p>Instead of:</p><pre><code class="language-swift">@Test("NPV at 5%") func npv5() { /* ... */ }
@Test("NPV at 10%") func npv10() { /* ... */ }
@Test("NPV at 15%") func npv15() { /* ... */ }
</code></pre><p>Use parameterized tests:</p><pre><code class="language-swift">@Test("NPV at multiple discount rates",
      arguments: [
          (rate: 0.05, expected: 297.59),
          (rate: 0.10, expected: 146.87),
          (rate: 0.15, expected: 20.42)
      ])
func multipleRates(rate: Double, expected: Double) {
    let cashFlows = [-1000.0, 300.0, 300.0, 300.0, 300.0]
    let result = npv(discountRate: rate, cashFlows: cashFlows)
    #expect(abs(result - expected) < 0.01)
}
</code></pre><p><strong>Result</strong>: 3 test cases, 10 lines of code instead of 30.</p><hr /><h2>The Triad Working Together</h2><p>These three documents form a complete system:</p><pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          MASTER_PLAN.md                     ‚îÇ
‚îÇ   "What to build next"                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚îÇ
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ                         ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  CODING   ‚îÇ         ‚îÇ  TEST_DRIVEN   ‚îÇ
    ‚îÇ  RULES    ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  DEVELOPMENT   ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                         ‚îÇ
         ‚îÇ                         ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ       DOCC_GUIDELINES.md              ‚îÇ
    ‚îÇ   "How to document it"                ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre><p><strong>Master Plan</strong>: ‚ÄúImplement Statistical Distributions (Topic 2)‚Äù</p><p><strong>Test-Driven Development</strong>: ‚ÄúWrite tests for normalCDF first, then implement‚Äù</p><p><strong>Coding Rules</strong>: ‚ÄúUse <code><T: Real></code>, guard clauses, and formatted() API‚Äù</p><p><strong>DocC Guidelines</strong>: ‚ÄúDocument with formula, example, Excel equivalent, and See Also links‚Äù</p><p><strong>Result</strong>: Consistent, high-quality implementation on the first try.</p><hr /><h2>What Worked</h2><h3>1. Quick Reference Beats Long Documents</h3><p>Each document is 200-500 lines‚Äîscannable in 60 seconds.</p><p><strong>Anti-pattern</strong>: 50-page ‚ÄúSoftware Development Manual‚Äù that nobody reads.</p><p><strong>Better</strong>: ‚ÄúCheck CODING_RULES.md section 3 for guard clause patterns.‚Äù</p><h3>2. Living Documents That Evolve</h3><p>Week 2: CODING_RULES.md has 5 rules.Week 10: CODING_RULES.md has 15 rules.Week 20: CODING_RULES.md has 25 rules.</p><p>As we discovered patterns that worked, we documented them. As we hit issues, we added rules to prevent recurrence.</p><h3>3. AI Follows Written Rules Reliably</h3><p>Unwritten rule: ‚ÄúWe prefer functional patterns.‚Äù</p><ul><li>AI interpretation: Uses <code>reduce</code> even when a loop is clearer.</li></ul><p>Written rule: ‚ÄúPrefer functional patterns (<code>reduce</code>, <code>map</code>) where readable. Use loops when clarity demands it.‚Äù</p><ul><li>AI gets it right every time.</li></ul><p><strong>Lesson</strong>: Make implicit standards explicit.</p><h3>4. Standards Prevent ‚ÄúWhy Did We Do It This Way?‚Äù Debates</h3><p>Week 15, reviewing code:</p><p><strong>Without standards</strong>:</p><ul><li>‚ÄúShould we use String(format:) here?‚Äù</li><li>‚ÄúI don‚Äôt remember why we decided against it‚Ä¶‚Äù</li><li><em>30 minutes lost to research and re-debate</em></li></ul><p><strong>With standards</strong>:</p><ul><li>‚ÄúCheck CODING_RULES.md‚ÄîString(format:) is forbidden, use formatted().‚Äù</li><li><em>0 minutes lost</em></li></ul><hr /><h2>The Insight</h2><p><strong>The master plan answers ‚Äúwhat to build.‚Äù The standards documents answer ‚Äúhow to build it consistently.‚Äù</strong></p><p>Without standards:</p><ul><li>Every decision is re-litigated</li><li>Patterns drift across sessions</li><li>AI generates inconsistent code</li><li>Code reviews become re-teaching sessions</li></ul><p>With standards:</p><ul><li>Decisions are made once, documented, and followed</li><li>Consistency across 200+ functions</li><li>AI generates correct code on first attempt</li><li>Code reviews verify adherence to documented standards</li></ul><p><strong>Key Takeaway</strong>: Create quick-reference standards documents. Start with 5-10 rules. Evolve as you discover what matters.</p><hr /><h2>How to Apply This</h2><p><strong>For your next project</strong>:</p><h3>1. Start Small</h3><p>Don‚Äôt try to write comprehensive standards on day 1. Start with:</p><ul><li>3 coding rules that matter most</li><li>1 documentation template</li><li>1 testing pattern</li></ul><h3>2. Document Decisions As You Make Them</h3><p>When you decide something important:</p><ul><li>Add it to the relevant document immediately</li><li>Include the ‚Äúwhy‚Äù (so you don‚Äôt forget)</li><li>Show an example</li></ul><h3>3. Use Templates</h3><p>Create copy-paste templates for:</p><ul><li>Function documentation</li><li>Test structure</li><li>Common patterns</li></ul><h3>4. Reference Documents in Prompts</h3><p>When working with AI:</p><blockquote><p>‚ÄúRead CODING_RULES.md. Implement calculateXIRR following these standards.‚Äù</p></blockquote><p>Not:</p><blockquote><p>‚ÄúImplement calculateXIRR. Oh, and use generics. And guard clauses. And formatted(). And‚Ä¶‚Äù</p></blockquote><h3>5. Update After Mistakes</h3><p>Made a mistake this session? Add a rule to prevent it next time.</p><p><strong>Example</strong>: Week 5, forgot to handle empty array in mean() function. Added rule: ‚ÄúAlways validate array input with guard.‚Äù</p><hr /><h2>Template Starter Pack</h2><h3>CODING_RULES.md Template</h3><pre><code class="language-markdown"># Coding Rules for [Project Name]

**Updated**: [Date]

## MUST (Non-Negotiable)

1. [Critical rule with rationale]
   ```swift
   // Example
</code></pre><h2>SHOULD (Strong Preference)</h2><ol><li>[Preferred pattern]<pre><code class="language-swift">// Example
</code></pre></li></ol><h2>CONSIDER (Suggestions)</h2><ol><li>[Optional guideline]</li></ol><pre><code>
### DOCC_GUIDELINES.md Template

```markdown
# Documentation Guidelines

## Required Sections

1. Brief summary
2. Detailed explanation
3. Parameters/Returns/Throws
4. Usage example
5. See Also

## Template

///
/// [Brief one-line summary]
///
/// [Detailed explanation]
///
/// - Parameters:
///   - param: [Description]
/// - Returns: [Description]
///
/// ## Usage Example
/// ```swift
/// [Runnable code]
/// ```
</code></pre><h3>TEST_DRIVEN_DEVELOPMENT.md Template</h3><pre><code class="language-markdown"># Testing Standards

## Test Structure

```swift
@Suite("[Topic] Tests")
struct TopicTests {
    @Test("[What this tests]")
    func descriptiveName() {
        // Arrange
        // Act
        // Assert with #expect
    }
}
</code></pre><h2>RED-GREEN-REFACTOR</h2><ol><li>Write failing test (RED)</li><li>Minimal implementation (GREEN)</li><li>Improve quality (REFACTOR)</li></ol><pre><code>
---

## See It In Action

BusinessMath's standards documents:
- **CODING_RULES.md**: 25 rules developed over 20 weeks
- **DOCC_GUIDELINES.md**: Complete documentation template with 9 required sections
- **TEST_DRIVEN_DEVELOPMENT.md**: Testing patterns for deterministic behavior

**Results**:
- 200+ functions with consistent style
- 100% documentation coverage
- 250+ tests with 0 flaky tests
- Code reviews focus on logic, not style

---

## Discussion

**Questions to consider**:
1. How detailed should your standards be?
2. When do you add a new rule vs. accepting variation?
3. How do you balance flexibility with consistency?

**Share your experience**: Do you maintain coding standards documents? What works for your team?

---

**Series Progress**:
- Week: 3/12
- Posts Published: 10.5/~48
- Methodology Posts: 4/12
- Practices Covered: Test-First, Documentation as Design, Master Planning, **Standards Documents**
- Standards Established: Coding Rules, DocC Guidelines, Testing Patterns

---

**Related Posts**:
- **Previous**: [The Master Plan: Organizing Complexity](#) - How to maintain project context
- **Next**: [Case Study #2: Capital Equipment Decision](#) - Standards documents in action
- **See Also**: [Building with Claude: A Reflection](#) - Full methodology overview
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-03/02-tue-master-plan</guid><title>The Master Plan: Organizing Complexity</title><link>https://www.justinpurnell.com/BusinessMath/week-03/02-tue-master-plan</link><description><![CDATA[Development Journey Series]]></description><pubDate>Tue, 20 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[ai-collaboration]]></category><category><![CDATA[project-management]]></category><category><![CDATA[planning]]></category><category><![CDATA[organization]]></category><category><![CDATA[development journey]]></category><content:encoded><![CDATA[<p><strong>Development Journey Series</strong></p><hr /><h2>The Context</h2><p>At the end of a week or two, we had tackled the core of BusinessMath. We had unlocked the power of the TimeSeries data structure, and had shown the proof of concept in a simple topic like the Time Value of Money using Test-Driven Development and our document-first approach. That was great, but we had a long road ahead of us, with some much trickier topics.</p><ul><li>Statistical Distributions</li><li>Time Series Analysis</li><li>Loans & Amortization</li><li>Depreciation</li><li>Investment Analysis</li><li>Portfolio Optimization</li><li>Monte Carlo Simulation</li><li>Sensitivity Analysis</li><li>Financial Statements</li><li>Options Pricing</li></ul><p>Each topic had 5-15 functions, dozens of tests, complete DocC documentation, and playground examples.</p><p>Even with domain expertise and working with a capable AI agent, this required a structured and methodical approach or risked sprialing out of control.</p><hr /><h2>The Challenge</h2><p>Large projects with AI have a unique problem: <strong>AI has no memory across sessions.</strong></p><p>Traditional development preserves context naturally:</p><ul><li>You work on the same codebase daily</li><li>You remember what‚Äôs done and what‚Äôs next</li><li>Your IDE shows project structure</li><li>Your brain maintains the big picture</li></ul><p>With AI collaboration:</p><ul><li>Each session starts fresh</li><li>AI doesn‚Äôt remember yesterday‚Äôs priorities</li><li>No inherent sense of progress or dependencies</li><li>Easy to lose track of the overall plan</li></ul><p>Without explicit project memory, it‚Äôs very, <strong>very</strong> easy to drift. If you bounce around and work on whatever seems interesting, dependencies go forgotten, coding patterns start to diverge, and momentum comes to a halt.</p><p>I needed a way to maintain project context across sessions‚Äîa shared memory between me and AI.</p><hr /><h2>The Solution</h2><p><strong>Create a living MASTER_PLAN.md document.</strong></p><h3>The Master Plan Structure</h3><p>The master plan is a single markdown file that serves as the project‚Äôs memory:</p><pre><code class="language-markdown"># BusinessMath Master Plan

**Last Updated**: Week 5

## Project Goals

Build a production-quality Swift library for financial calculations with:
- 100% DocC documentation coverage
- Comprehensive test suite (target: 200+ tests)
- Support for generic numeric types
- Playground tutorials for each topic

## Topics

### 1. Time Value of Money [‚úÖ Complete]
**Status**: 24 tests, fully documented
**Effort**: Medium (M)
**Dependencies**: None
**Completed**: Week 4

**Functions**:
- `presentValue`, `futureValue`, `payment`
- `npv`, `irr`, `xnpv`, `xirr`

---

### 2. Statistical Distributions [üü° In Progress]
**Status**: 8/25 tests
**Effort**: Large (L)
**Dependencies**: None
**Target Completion**: Week 7

**Functions**:
- Normal distribution (CDF, PDF, inverse)
- T-distribution, Chi-squared, F-distribution
- Binomial, Poisson distributions

**Remaining Work**:
- Complete distribution functions
- Add quantile functions
- Write DocC tutorials

---

### 3. Time Series Analysis [‚¨ú Not Started]
**Status**: 0 tests
**Effort**: Large (L)
**Dependencies**: Statistical Distributions
**Target Completion**: Week 10

**Functions**:
- Period types (Day, Month, Quarter, Year)
- TimeSeries container
- Moving averages, exponential smoothing
- Trend analysis

**Notes**:
- Blocked on Statistical Distributions completion
- Consider using Foundation.Calendar for date arithmetic

---

[... rest of 10 topics ...]

## Current Phase: Foundation (Weeks 1-8)

**Goal**: Complete Topics 1-4, establish 75 tests total

**Progress**:
- ‚úÖ Topic 1: TVM Complete (24 tests)
- üü° Topic 2: Distributions 30% complete (8 tests)
- ‚¨ú Topic 3: Time Series (not started)
- ‚¨ú Topic 4: Loans & Amortization (not started)

**Next Session Priority**: Complete normal distribution tests

## Effort Estimates

- **Small (S)**: 1-2 sessions, <10 tests
- **Medium (M)**: 3-5 sessions, 10-25 tests
- **Large (L)**: 6-10 sessions, 25-50 tests
- **XL**: 10+ sessions, 50+ tests
</code></pre><hr /><h2>What Worked</h2><h3>1. Visual Progress Tracking</h3><p>Checkboxes provide instant visual feedback:</p><ul><li>‚úÖ Complete (feels great!)</li><li>üü° In Progress (clear focus)</li><li>‚¨ú Not Started (known future work)</li></ul><p>At a glance, you see: ‚ÄúI‚Äôve completed 1/11 topics, making progress on 1 more.‚Äù</p><hr /><h3>2. Dependency Graph Prevented Confusion</h3><p>Time Series depends on Statistical Distributions (for confidence intervals).</p><p><strong>Without the master plan</strong>, I might start Time Series, realize I need distribution functions, context-switch to implement those, forget where I was in Time Series, and end up with half-finished work everywhere.</p><p><strong>With dependencies documented</strong>, I know: ‚ÄúFinish Distributions first, THEN start Time Series.‚Äù</p><hr /><h3>3. Effort Estimates Helped Time Management</h3><p>Knowing a topic is ‚ÄúLarge (L)‚Äù sets expectations:</p><ul><li>Don‚Äôt try to finish it in one session</li><li>Break it into sub-tasks</li><li>Allocate multiple sessions</li></ul><p>Initial estimates were too optimistic (I thought Statistical Distributions was Medium, but it took Large effort). That‚Äôs fine‚ÄîI updated the plan.</p><hr /><h3>4. The Master Plan is AI‚Äôs Memory</h3><p>Every session starts with:</p><blockquote><p>‚ÄúRead MASTER_PLAN.md. What‚Äôs the current priority?‚Äù</p></blockquote><p>AI responds:</p><blockquote><p>‚ÄúYou‚Äôre 30% through Statistical Distributions. The next task is completing normal distribution tests. Time Series is blocked waiting for this.‚Äù</p></blockquote><p><strong>Instant context restoration.</strong> No wasted time figuring out where you left off.</p><hr /><h2>What Didn‚Äôt Work</h2><h3>1. Initial Estimates Were Too Optimistic</h3><p>I thought Statistical Distributions would take 3-5 sessions (Medium). It took 8+ (Large).</p><p><strong>Fix</strong>: I adjusted the plan. Effort estimates improve over time as you calibrate.</p><hr /><h3>2. Forgot to Plan for Integration Testing</h3><p>The master plan listed 11 topics as independent work. But after completing several topics, I needed integration tests: ‚ÄúDo TVM and Time Series work together?‚Äù</p><p>I hadn‚Äôt planned for this.</p><p><strong>Fix</strong>: Added a Phase 4 ‚ÄúIntegration & Polish‚Äù with dedicated time for cross-topic validation.</p><hr /><h3>3. No Mechanism for Prioritization Changes</h3><p>The master plan was linear (Topic 1 ‚Üí Topic 2 ‚Üí Topic 3‚Ä¶). But sometimes priorities shift:</p><ul><li>A user requests a specific feature</li><li>You discover a critical bug</li><li>Integration reveals missing functionality</li></ul><p>The plan didn‚Äôt accommodate this gracefully.</p><p><strong>Fix</strong>: Added a ‚ÄúCurrent Session Priority‚Äù section that can override the default order.</p><hr /><h2>The Insight</h2><p><strong>AI has no memory across sessions. The master plan document serves as the project‚Äôs memory.</strong></p><p>Traditional development preserves context implicitly (your brain, IDE state, recent commits). AI collaboration requires <strong>explicit context preservation</strong>.</p><p>The master plan serves as:</p><ul><li><strong>Roadmap</strong>: What needs to be done</li><li><strong>Memory</strong>: What‚Äôs already done</li><li><strong>Prioritization</strong>: What to work on next</li><li><strong>Dependency tracker</strong>: What blocks what</li><li><strong>Progress indicator</strong>: How far you‚Äôve come</li></ul><p>Without it, you drift. With it, you maintain momentum across weeks and months.</p><blockquote><p><strong>Key Takeaway</strong>: Create a living master plan document. Update it at the end of each session. Start each new session by reading it.</p></blockquote><hr /><h2>How to Apply This</h2><p><strong>For your next project</strong>:</p><p><strong>1. Create MASTER_PLAN.md at Project Start</strong></p><ul><li>List all major topics/features</li><li>Estimate effort (S/M/L/XL)</li><li>Map dependencies</li><li>Set completion targets</li></ul><p><strong>2. Structure the Plan</strong></p><pre><code class="language-markdown">## Topics

### 1. [Topic Name] [Status Emoji]
**Status**: [Specific completion metric]
**Effort**: [S/M/L/XL]
**Dependencies**: [What must be done first]
**Target Completion**: [Week/Sprint number]

**Functions/Features**:
- List of specific work items

**Remaining Work**:
- What's left to do
</code></pre><p><strong>3. Update at End of Each Session</strong></p><ul><li>Mark completed items</li><li>Update progress percentages</li><li>Adjust estimates based on reality</li><li>Note blockers or discoveries</li></ul><p><strong>4. Start Each Session by Reading the Plan</strong></p><ul><li>‚ÄúWhat‚Äôs the current priority?‚Äù</li><li>‚ÄúWhat did I complete last time?‚Äù</li><li>‚ÄúWhat should I work on next?‚Äù</li></ul><p><strong>5. Use It as AI Specification</strong></p><ul><li>Paste relevant section when starting work</li><li>‚ÄúHere‚Äôs the master plan. Focus on Topic 2: Statistical Distributions. The next task is completing normal distribution tests.‚Äù</li></ul><hr /><h2>See It In Action</h2><p>The master plan guided the entire BusinessMath development:</p><p><strong>Technical Examples</strong>:</p><ul><li><strong>Week 5-7</strong>: Statistical Distributions (originally estimated M, actually L)</li><li><strong>Week 8-10</strong>: Time Series (blocked until Distributions complete)</li><li><strong>Week 15</strong>: Integration testing (added after initial plan)</li></ul><p><strong>Methodology Integration</strong>:</p><ul><li><strong>Test-First Development</strong> (Week 1): Each topic‚Äôs test count tracked in plan</li><li><strong>Documentation as Design</strong> (Week 2): DocC coverage tracked in plan</li><li><strong>Coding Standards</strong> (Week 5): Standards violations tracked as plan items</li></ul><hr /><h2>Common Pitfalls</h2><h3>‚ùå Pitfall 1: Making the plan too detailed</h3><p><strong>Problem</strong>: 50-page plan with every function documented upfront<strong>Solution</strong>: High-level topics with detail added as you go</p><h3>‚ùå Pitfall 2: Never updating the plan</h3><p><strong>Problem</strong>: Plan becomes stale, loses value<strong>Solution</strong>: Update at end of EVERY session, even if it‚Äôs just checking a box</p><h3>‚ùå Pitfall 3: Treating estimates as commitments</h3><p><strong>Problem</strong>: Feeling bad when Medium takes Large effort<strong>Solution</strong>: Estimates are guesses that improve over time. Update them!</p><h3>‚ùå Pitfall 4: Skipping dependency tracking</h3><p><strong>Problem</strong>: Starting work that‚Äôs blocked, wasting time<strong>Solution</strong>: Explicitly list ‚ÄúDependencies: [Topic X complete]‚Äù</p><hr /><h2>Template</h2><p>Here‚Äôs a starter template for your master plan:</p><pre><code class="language-markdown"># [Project Name] Master Plan

**Last Updated**: [Date]

## Project Goals

[1-3 sentences describing what you're building and key quality criteria]

## Topics / Features

### 1. [Feature Name] [‚úÖ | üü° | ‚¨ú]
**Status**: [Specific completion metric]
**Effort**: [S/M/L/XL]
**Dependencies**: [None | Topic X complete]
**Target Completion**: [Week/Sprint]

**Work Items**:
- [ ] Item 1
- [ ] Item 2

**Remaining Work**:
- [What's left]

---

[Repeat for each topic/feature]

## Current Phase

**Goal**: [Phase objective]

**Progress**:
- ‚úÖ [Completed items]
- üü° [In progress]
- ‚¨ú [Not started]

**Next Session Priority**: [Specific task]

## Effort Legend

- **Small (S)**: [Your time estimate]
- **Medium (M)**: [Your time estimate]
- **Large (L)**: [Your time estimate]
- **XL**: [Your time estimate]
</code></pre><hr /><h2>Discussion</h2><p><strong>Questions to consider</strong>:</p><ol><li>How detailed should the master plan be?</li><li>How often should you update it?</li><li>What do you do when priorities shift mid-project?</li></ol><p><strong>Share your experience</strong>: Do you use a master plan or roadmap document? What works for you?</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 3/12</li><li>Posts Published: 10/~48</li><li>Methodology Posts: 3/12</li><li>Practices Covered: Test-First, Documentation as Design, Master Planning</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-03/01-mon-growth-modeling</guid><title>Growth Modeling and Forecasting</title><link>https://www.justinpurnell.com/BusinessMath/week-03/01-mon-growth-modeling</link><description><![CDATA[Part 9 of 12-Week BusinessMath Series]]></description><pubDate>Mon, 19 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[growth]]></category><category><![CDATA[forecasting]]></category><category><![CDATA[cagr]]></category><category><![CDATA[trends]]></category><category><![CDATA[seasonality]]></category><content:encoded><![CDATA[<p><strong>Part 9 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>Calculating growth rates (simple and CAGR)</li><li>Fitting trend models (linear, exponential, logistic)</li><li>Extracting and applying seasonal patterns</li><li>Building complete forecasting workflows</li><li>Choosing the right approach for your data</li></ul><hr /><h2>The Problem</h2><p>Business planning requires forecasting: <strong>Will we hit our revenue target? How many users will we have next quarter? What should our headcount plan look like?</strong></p><p>Forecasting means understanding growth patterns:</p><ul><li><strong>Growth rates</strong>: How fast are we growing?</li><li><strong>Trend models</strong>: What‚Äôs the underlying trajectory?</li><li><strong>Seasonality</strong>: Do we have recurring patterns (Q4 spike, summer slump)?</li></ul><p>Building robust forecasts manually requires statistical knowledge, careful data handling, and combining multiple techniques. <strong>You need systematic tools for growth analysis and forecasting.</strong></p><hr /><h2>The Solution</h2><p>BusinessMath provides comprehensive growth modeling including growth rate calculations, trend fitting, and seasonality extraction.</p><h3>Growth Rates</h3><p>Calculate simple and compound growth:</p><pre><code class="language-swift">import BusinessMath

// Simple growth rate
let growth = try growthRate(from: 100_000, to: 120_000)
// Result: 0.20 (20% growth)

// Negative growth (decline)
let decline = try growthRate(from: 120_000, to: 100_000)
// Result: -0.1667 (-16.67% decline)
</code></pre><p><strong>Formula:</strong></p><pre><code>Growth Rate = (Ending / Beginning) - 1
</code></pre><hr /><h3>Compound Annual Growth Rate (CAGR)</h3><p>CAGR smooths out volatility to show steady equivalent growth:</p><pre><code class="language-swift">// Revenue: $100k ‚Üí $110k ‚Üí $125k ‚Üí $150k over 3 years
let compoundGrowth = cagr(
    beginningValue: 100_000,
    endingValue: 150_000,
    years: 3
)
// Result: ~0.1447 (14.47% per year)

// Verify: does 14.47% compound for 3 years give $150k?
let verification = 100_000 * pow((1 + compoundGrowth), 3.0)
// Result: ~150,000 ‚úì
</code></pre><p><strong>Formula:</strong></p><pre><code>CAGR = (Ending / Beginning)^(1/years) - 1
</code></pre><p><strong>The insight</strong>: Revenue was volatile year-to-year ($10k, then $15k, then $25k growth), but CAGR shows the equivalent steady rate: 14.47% annually.</p><hr /><h3>Applying Growth</h3><p>Project future values:</p><pre><code class="language-swift">// Project $100k base with 15% annual growth for 5 years
let projection = applyGrowth(
    baseValue: 100_000,
    rate: 0.15,
    periods: 5,
    compounding: .annual
)
// Result: [100k, 115k, 132.25k, 152.09k, 174.90k, 201.14k]
</code></pre><hr /><h3>Compounding Frequencies</h3><p>Different frequencies affect growth:</p><pre><code class="language-swift">let base = 100_000.0
let rate = 0.12  // 12% annual rate
let years = 5

// Annual: 12% once per year
let annual = applyGrowth(baseValue: base, rate: rate, periods: years, compounding: .annual)
print(annual.last!.number(0))
// Final: ~176,234

// Quarterly: 3% four times per year
let quarterly = applyGrowth(baseValue: base, rate: rate, periods: years * 4, compounding: .quarterly)
print(quarterly.last!.number(0))
// Final: ~180,611 (higher due to more frequent compounding)

// Monthly: 1% twelve times per year
let monthly = applyGrowth(baseValue: base, rate: rate, periods: years * 12, compounding: .monthly)
print(monthly.last!.number(0))
// Final: ~181,670

// Continuous: e^(rt)
let continuous = applyGrowth(baseValue: base, rate: rate, periods: years, compounding: .continuous)
print(continuous.last!.number(0))
// Final: ~182,212 (theoretical maximum)
</code></pre><p><strong>The insight</strong>: More frequent compounding increases final value. Continuous compounding is the mathematical limit.</p><hr /><h2>Trend Models</h2><p>Trend models fit mathematical functions to historical data for forecasting.</p><h3>Linear Trend</h3><p>Models constant absolute growth:</p><pre><code class="language-swift">// Historical revenue shows steady ~$5k/month increase
let periods_linearTrend = (1...12).map { Period.month(year: 2024, month: $0) }
let revenue_linearTrend: [Double] = [100, 105, 110, 108, 115, 120, 118, 125, 130, 128, 135, 140]

let historical_linearTrend = TimeSeries(periods: periods_linearTrend, values: revenue_linearTrend)

// Fit linear trend
var trend_linearTrend = LinearTrend<Double>()
try trend_linearTrend.fit(to: historical_linearTrend)

// Project 6 months forward
let forecast_linearTrend = try trend_linearTrend.project(periods: 6)
print(forecast_linearTrend.valuesArray.map({$0.rounded()}))
// Result: [142, 145, 148, 152, 155, 159] (approximately)
</code></pre><p><strong>Formula:</strong></p><pre><code>y = mx + b

Where:
- m = slope (rate of change)
- b = intercept (starting value)
</code></pre><p><strong>Best for</strong>:</p><ul><li>Steady absolute growth (adding same $ each period)</li><li>Short-term forecasts</li><li>Linear relationships</li></ul><hr /><h3>Exponential Trend</h3><p>Models constant percentage growth:</p><pre><code class="language-swift">// Revenue doubling every few years
let periods_exponentialTrend = (0..<10).map { Period.year(2015 + $0) }
let revenue_exponentialTrend: [Double] = [100, 115, 130, 155, 175, 200, 235, 265, 310, 350]

let historical_exponentialTrend = TimeSeries(periods: periods_exponentialTrend, values: revenue_exponentialTrend)

// Fit exponential trend
var trend_exponentialTrend = ExponentialTrend<Double>()
try trend_exponentialTrend.fit(to: historical_exponentialTrend)

// Project 5 years forward
let forecast_exponentialTrend = try trend_exponentialTrend.project(periods: 5)
// Result: [407, 468, 538, 619, 713]
</code></pre><p><strong>Formula:</strong></p><pre><code>y = a √ó e^(bx)

Where:
- a = initial value
- b = growth rate
- e = Euler's number (2.71828...)
</code></pre><p><strong>Best for</strong>:</p><ul><li>Constant percentage growth (e.g., 15% per year)</li><li>Long-term trends</li><li>Compound growth scenarios</li></ul><hr /><h3>Logistic Trend</h3><p>Models growth approaching a capacity limit (S-curve):</p><pre><code class="language-swift">// User adoption: starts slow, accelerates, then plateaus
let periods_logisticTrend = (0..<24).map { Period.month(year: 2023 + $0/12, month: ($0 % 12) + 1) }
let users_logisticTrend: [Double] = [100, 150, 250, 400, 700, 1200, 2000, 3500, 5500, 8000,
						11000, 14000, 17000, 19500, 21500, 23000, 24000, 24500,
						24800, 24900, 24950, 24970, 24985, 24990]

let historical_logisticTrend = TimeSeries(periods: periods_logisticTrend, values: users_logisticTrend)

// Fit logistic trend with capacity of 25,000 users
var trend_logisticTrend = LogisticTrend<Double>(capacity: 25_000)
try trend_logisticTrend.fit(to: historical_logisticTrend)

// Project 12 months forward
let forecast_logisticTrend = try trend_logisticTrend.project(periods: 12)
// Result: Approaches but never exceeds 25,000
</code></pre><p><strong>Formula:</strong></p><pre><code>y = L / (1 + e^(-k(x-x‚ÇÄ)))

Where:
- L = capacity (maximum value)
- k = growth rate
- x‚ÇÄ = midpoint of curve
</code></pre><p><strong>Best for</strong>:</p><ul><li>Market saturation scenarios</li><li>Product adoption curves</li><li>SaaS user growth with market limits</li><li>Biological growth (population with carrying capacity)</li></ul><hr /><h2>Seasonality</h2><p>Extract and apply recurring patterns.</p><h3>Seasonal Indices</h3><p>Calculate seasonal factors:</p><pre><code class="language-swift">// Quarterly revenue with Q4 holiday spike
let periods = (0..<12).map { Period.quarter(year: 2022 + $0/4, quarter: ($0 % 4) + 1) }
let revenue: [Double] = [100, 120, 110, 150,  // 2022
                         105, 125, 115, 160,  // 2023
                         110, 130, 120, 170]  // 2024

let ts = TimeSeries(periods: periods, values: revenue)

// Calculate seasonal indices (4 quarters per year)
let indices = try seasonalIndices(timeSeries: ts, periodsPerYear: 4)
print(indices.map({"\($0.number(2))"}).joined(separator: ", "))
// Result: [~0.85, ~1.00, ~0.91, ~1.24]
</code></pre><p><strong>Interpretation</strong>:</p><ul><li><strong>Q1: 0.85</strong> ‚Üí 15% below average (post-holiday slump)</li><li><strong>Q2: 1.00</strong> ‚Üí Average</li><li><strong>Q3: 0.91</strong> ‚Üí 9% below average (summer slowdown)</li><li><strong>Q4: 1.24</strong> ‚Üí 24% above average (holiday spike!)</li></ul><hr /><h3>Complete Forecasting Workflow</h3><p>Combine all techniques:</p><pre><code class="language-swift">// 1. Load historical data
let historical = TimeSeries(periods: historicalPeriods, values: historicalRevenue)

// 2. Extract seasonal pattern
let seasonalIndices = try seasonalIndices(timeSeries: historical, periodsPerYear: 4)

// 3. Deseasonalize to reveal underlying trend
let deseasonalized = try seasonallyAdjust(timeSeries: historical, indices: seasonalIndices)

// 4. Fit trend model to deseasonalized data
var trend = LinearTrend<Double>()
try trend.fit(to: deseasonalized)

// 5. Project trend forward
let forecastPeriods = 4  // Next 4 quarters
let trendForecast = try trend.project(periods: forecastPeriods)

// 6. Reapply seasonality to trend forecast
let seasonalForecast = try applySeasonal(timeSeries: trendForecast, indices: seasonalIndices)

// 7. Present forecast
for (period, value) in zip(seasonalForecast.periods, seasonalForecast.valuesArray) {
    print("\(period.label): \(value.currency())")
}
</code></pre><p><strong>This workflow</strong>:</p><ol><li>Extracts the recurring seasonal pattern</li><li>Removes it to see the underlying growth trend</li><li>Fits a trend model to clean data</li><li>Projects that trend forward</li><li>Reapplies the seasonal pattern to the forecast</li><li>Produces realistic forecasts that account for both trend and seasonality</li></ol><hr /><h2>Choosing the Right Approach</h2><h3>Decision Tree</h3><p><strong>Step 1: Does your data have seasonality?</strong></p><ul><li><strong>Yes</strong> ‚Üí Extract seasonal pattern first</li><li><strong>No</strong> ‚Üí Skip to trend modeling</li></ul><p><strong>Step 2: What kind of growth pattern?</strong></p><ul><li><strong>Constant $ per period</strong> ‚Üí Linear Trend</li><li><strong>Constant % per period</strong> ‚Üí Exponential Trend</li><li><strong>Growth approaching limit</strong> ‚Üí Logistic Trend</li></ul><p><strong>Step 3: How much history do you have?</strong></p><ul><li><strong>< 2 full cycles</strong> ‚Üí Use simple growth rates</li><li><strong>2-3 cycles</strong> ‚Üí Linear or exponential trend</li><li><strong>3+ cycles</strong> ‚Üí Full decomposition with seasonality</li></ul><p><strong>Step 4: What‚Äôs your forecast horizon?</strong></p><ul><li><strong>Short-term (1-3 periods)</strong> ‚Üí Any model works</li><li><strong>Medium-term (4-8 periods)</strong> ‚Üí Trend models with seasonality</li><li><strong>Long-term (9+ periods)</strong> ‚Üí Be cautious, validate assumptions</li></ul><hr /><h2>Try It Yourself</h2><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath

// Simple growth rate
let growth = try growthRate(from: 100_000, to: 120_000)
// Result: 0.20 (20% growth)

// Negative growth (decline)
let decline = try growthRate(from: 120_000, to: 100_000)
// Result: -0.1667 (-16.67% decline)


// Revenue: $100k ‚Üí $110k ‚Üí $125k ‚Üí $150k over 3 years
let compoundGrowth = cagr(
	beginningValue: 100_000,
	endingValue: 150_000,
	years: 3
)
// Result: ~0.1447 (14.47% per year)

// Verify: does 14.47% compound for 3 years give $150k?
let verification = 100_000 * pow((1 + compoundGrowth), 3.0)
// Result: ~150,000 ‚úì

	// Project $100k base with 15% annual growth for 5 years
	let projection = applyGrowth(
		baseValue: 100_000,
		rate: 0.15,
		periods: 5,
		compounding: .annual
	)
	// Result: [100k, 115k, 132.25k, 152.09k, 174.90k, 201.14k]

let base = 100_000.0
let rate = 0.12  // 12% annual rate
let years = 5

// Annual: 12% once per year
let annual = applyGrowth(baseValue: base, rate: rate, periods: years, compounding: .annual)
print(annual.last!.number(0))
// Final: ~176,234

// Quarterly: 3% four times per year
let quarterly = applyGrowth(baseValue: base, rate: rate, periods: years * 4, compounding: .quarterly)
print(quarterly.last!.number(0))
// Final: ~180,611 (higher due to more frequent compounding)

// Monthly: 1% twelve times per year
let monthly = applyGrowth(baseValue: base, rate: rate, periods: years * 12, compounding: .monthly)
print(monthly.last!.number(0))
// Final: ~181,670

// Continuous: e^(rt)
let continuous = applyGrowth(baseValue: base, rate: rate, periods: years, compounding: .continuous)
print(continuous.last!.number(0))
// Final: ~182,212 (theoretical maximum)

	// Historical revenue shows steady ~$5k/month increase
	let periods_linearTrend = (1...12).map { Period.month(year: 2024, month: $0) }
	let revenue_linearTrend: [Double] = [100, 105, 110, 108, 115, 120, 118, 125, 130, 128, 135, 140]

	let historical_linearTrend = TimeSeries(periods: periods_linearTrend, values: revenue_linearTrend)

	// Fit linear trend
	var trend_linearTrend = LinearTrend<Double>()
	try trend_linearTrend.fit(to: historical_linearTrend)

	// Project 6 months forward
	let forecast_linearTrend = try trend_linearTrend.project(periods: 6)
	print(forecast_linearTrend.valuesArray.map({$0.rounded()}))
	// Result: [142, 145, 148, 152, 155, 159] (approximately)

	// Revenue doubling every few years
	let periods_exponentialTrend = (0..<10).map { Period.year(2015 + $0) }
	let revenue_exponentialTrend: [Double] = [100, 115, 130, 155, 175, 200, 235, 265, 310, 350]

	let historical_exponentialTrend = TimeSeries(periods: periods_exponentialTrend, values: revenue_exponentialTrend)

	// Fit exponential trend
	var trend_exponentialTrend = ExponentialTrend<Double>()
	try trend_exponentialTrend.fit(to: historical_exponentialTrend)

	// Project 5 years forward
	let forecast_exponentialTrend = try trend_exponentialTrend.project(periods: 5)
	print(forecast_exponentialTrend.valuesArray.map({$0.rounded()}))
	// Result: [407, 468, 538, 619, 713]

	// User adoption: starts slow, accelerates, then plateaus
	let periods_logisticTrend = (0..<24).map { Period.month(year: 2023 + $0/12, month: ($0 % 12) + 1) }
	let users_logisticTrend: [Double] = [100, 150, 250, 400, 700, 1200, 2000, 3500, 5500, 8000,
							11000, 14000, 17000, 19500, 21500, 23000, 24000, 24500,
							24800, 24900, 24950, 24970, 24985, 24990]

	let historical_logisticTrend = TimeSeries(periods: periods_logisticTrend, values: users_logisticTrend)

	// Fit logistic trend with capacity of 25,000 users
	var trend_logisticTrend = LogisticTrend<Double>(capacity: 25_000)
	try trend_logisticTrend.fit(to: historical_logisticTrend)

	// Project 12 months forward
	let forecast_logisticTrend = try trend_logisticTrend.project(periods: 12)
	print(forecast_logisticTrend.valuesArray.map({$0.rounded()}))
	// Result: Approaches but never exceeds 25,000

	// Quarterly revenue with Q4 holiday spike
	let periods = (0..<12).map { Period.quarter(year: 2022 + $0/4, quarter: ($0 % 4) + 1) }
	let revenue: [Double] = [100, 120, 110, 150,  // 2022
							 105, 125, 115, 160,  // 2023
							 110, 130, 120, 170]  // 2024

	let ts = TimeSeries(periods: periods, values: revenue)

	// Calculate seasonal indices (4 quarters per year)
	let indices = try seasonalIndices(timeSeries: ts, periodsPerYear: 4)
	print(indices.map({"\($0.number(2))"}).joined(separator: ", "))
	// Result: [~0.85, ~1.00, ~0.91, ~1.24]

	// 1. Load historical data
	let historical = TimeSeries(periods: historicalPeriods, values: historicalRevenue)

	// 2. Extract seasonal pattern
	let seasonalIndices = try seasonalIndices(timeSeries: historical, periodsPerYear: 4)

	// 3. Deseasonalize to reveal underlying trend
	let deseasonalized = try seasonallyAdjust(timeSeries: historical, indices: seasonalIndices)

	// 4. Fit trend model to deseasonalized data
	var trend = LinearTrend<Double>()
	try trend.fit(to: deseasonalized)

	// 5. Project trend forward
	let forecastPeriods = 4  // Next 4 quarters
	let trendForecast = try trend.project(periods: forecastPeriods)

	// 6. Reapply seasonality to trend forecast
	let seasonalForecast = try applySeasonal(timeSeries: trendForecast, indices: seasonalIndices)

	// 7. Present forecast
	for (period, value) in zip(seasonalForecast.periods, seasonalForecast.valuesArray) {
		print("\(period.label): \(value.currency())")
	}
	
</code></pre></details>
<p>‚Üí Full API Reference: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/3.1-GrowthModeling.md"><strong>BusinessMath Docs ‚Äì 3.1 Growth Modeling</strong></a></p><p><strong>Modifications to try</strong>:</p><ol><li>Calculate CAGR for your company‚Äôs historical revenue</li><li>Fit different trend models and compare predictions</li><li>Extract seasonal patterns from your business data</li></ol><hr /><h2>Real-World Application</h2><p>A SaaS company tracking user growth notices:</p><ul><li><strong>Monthly data</strong>: 10-15% growth, but volatile</li><li><strong>CAGR over 2 years</strong>: 12.3% (the smoothed view)</li><li><strong>Seasonal pattern</strong>: Lower signups in July-August (summer)</li><li><strong>Trend model</strong>: Logistic with 100k user capacity (market saturation)</li></ul><p>Combining these insights produces a forecast that accounts for:</p><ul><li>Long-term growth trajectory (logistic curve)</li><li>Seasonal dips in summer</li><li>Market saturation approaching</li></ul><p><strong>This is infinitely more useful than a simple ‚Äúwe‚Äôre growing 15%/month‚Äù projection.</strong></p><hr /><p><code>‚òÖ Insight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><p><strong>Why Deseasonalize Before Trend Fitting?</strong></p><p>If you fit a trend to raw seasonal data, the model gets confused:</p><ul><li>Q4 spikes look like acceleration</li><li>Q1 dips look like deceleration</li><li>The fitted trend becomes wavy instead of smooth</li></ul><p><strong>Deseasonalizing first</strong> lets you fit a clean trend, then reapply the seasonal pattern to forecasts.</p><p>Think of it like removing noise before measuring signal.</p><p><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><hr /><h3>üìù Development Note</h3><p>The hardest decision in growth modeling was: <strong>Should we make seasonality automatic, or explicit?</strong></p><p>Some libraries auto-detect seasonal patterns. Sounds convenient! But it often gets it wrong‚Äîdetecting false patterns in noise, or missing real patterns in small datasets.</p><p>We chose <strong>explicit seasonality</strong>:</p><ul><li>You specify <code>periodsPerYear</code> (4 for quarters, 12 for months)</li><li>You inspect the indices before using them</li><li>You decide if the pattern makes business sense</li></ul><p>This requires one extra line of code, but prevents silent errors. When seasonality extraction fails, you know immediately and can investigate.</p><p><strong>The lesson</strong>: Convenience features that fail silently are worse than explicit APIs that require judgment.</p><p><strong>Related Methodology</strong>: <a href="../week-03/02-tue-master-plan.md">The Master Plan</a> (Tuesday) - Planning for API decisions</p><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: The Master Plan (Tuesday) - How to organize large projects with AI collaboration.</p><p><strong>This week</strong>: Revenue modeling (Thursday) and Capital Equipment case study (Friday).</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 3/12</li><li>Posts Published: 9/~48</li><li>Topics Covered: Foundation + Analysis + Operational Models (starting)</li><li>Playgrounds: 8 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-02/04-fri-risk-analytics</guid><title>Risk Analytics and Stress Testing</title><link>https://www.justinpurnell.com/BusinessMath/week-02/04-fri-risk-analytics</link><description><![CDATA[Part 8 of 12-Week BusinessMath Series]]></description><pubDate>Fri, 16 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[risk]]></category><category><![CDATA[var]]></category><category><![CDATA[stress-testing]]></category><category><![CDATA[portfolio]]></category><content:encoded><![CDATA[<p><strong>Part 8 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>How to perform stress testing with pre-defined and custom scenarios</li><li>Calculating Value at Risk (VaR) at different confidence levels</li><li>Computing Conditional VaR (CVaR / Expected Shortfall)</li><li>Using comprehensive risk metrics (Sharpe, Sortino, drawdown)</li><li>Aggregating risk across multiple portfolios with correlations</li></ul><hr /><h2>The Problem</h2><p>Risk management requires quantifying uncertainty. <strong>What‚Äôs the worst loss we might face? How would a recession affect our portfolio? Are we properly diversified?</strong></p><p>Traditional risk analysis involves complex calculations:</p><ul><li><strong>VaR (Value at Risk)</strong>: Maximum loss at a confidence level</li><li><strong>Stress testing</strong>: Impact of adverse scenarios</li><li><strong>Drawdown analysis</strong>: Peak-to-trough declines</li><li><strong>Risk aggregation</strong>: Combining correlated risks</li></ul><p>Implementing these correctly requires statistical knowledge, careful handling of distributions, and proper correlation modeling. <strong>You need production-ready risk analytics without reinventing the math.</strong></p><hr /><h2>The Solution</h2><p>BusinessMath provides comprehensive risk analytics including stress testing, VaR calculation, and multi-portfolio risk aggregation.</p><h3>Stress Testing</h3><p>Evaluate how portfolios perform under adverse scenarios:</p><pre><code class="language-swift">import BusinessMath

// Pre-defined stress scenarios
var allScenarios = [
    StressScenario<Double>.recession,      // Moderate economic downturn
    StressScenario<Double>.crisis,         // Severe financial crisis
    StressScenario<Double>.supplyShock     // Supply chain disruption
]

// Examine scenario parameters
for scenario in scenarios {
    print("\(scenario.name):")
    print("  Description: \(scenario.description)")
    print("  Shocks:")
    for (driver, shock) in scenario.shocks {
        let pct = shock * 100
        print("    \(driver): \(pct > 0 ? "+" : "")\(pct)%")
    }
}
</code></pre><p><strong>Output:</strong></p><pre><code>Recession:
  Description: Economic recession scenario
  Shocks:
    Revenue: -15.0%
    COGS: +5.0%
    InterestRate: +2.0%

Financial Crisis:
  Description: Severe financial crisis (2008-style)
  Shocks:
    Revenue: -30.0%
    InterestRate: +5.0%
    CustomerChurn: +20.0%
    COGS: +10.0%

Supply Chain Shock:
  Description: Major supply chain disruption
  Shocks:
    InventoryLevel: -30.0%
    DeliveryTime: +50.0%
    COGS: +25.0%
</code></pre><hr /><h3>Custom Stress Scenarios</h3><p>Create scenarios specific to your business:</p><pre><code class="language-swift">// Pandemic scenario
let pandemic = StressScenario(
    name: "Global Pandemic",
    description: "Extended lockdowns and remote work transition",
    shocks: [
        "Revenue": -0.35,           // -35% revenue
        "RemoteWorkCosts": 0.20,    // +20% IT/remote costs
        "TravelExpenses": -0.80,    // -80% travel
        "RealEstateCosts": -0.15    // -15% office costs
    ]
)

allScenarios.append(pandemic)

// Regulatory change scenario
let regulation = StressScenario(
    name: "New Regulation",
    description: "Stricter compliance requirements",
    shocks: [
        "ComplianceCosts": 0.50,    // +50% compliance
        "Revenue": -0.05,            // -5% from restrictions
        "OperatingMargin": -0.03     // -3% margin compression
    ]
)
allScenarios.append(regulation)
</code></pre><hr /><h3>Running Stress Tests</h3><p>Apply scenarios to your financial model:</p><pre><code class="language-swift">let stressTest = StressTest(scenarios: allScenarios)

struct FinancialMetrics {
    var revenue: Double
    var costs: Double
    var npv: Double
}

let baseline = FinancialMetrics(
    revenue: 10_000_000,
    costs: 7_000_000,
    npv: 5_000_000
)

for scenario in stressTest.scenarios {
    // Apply shocks
    var stressed = baseline

    if let revenueShock = scenario.shocks["Revenue"] {
        stressed.revenue *= (1 + revenueShock)
    }

    if let cogsShock = scenario.shocks["COGS"] {
        stressed.costs *= (1 + cogsShock)
    }

    let stressedNPV = stressed.revenue - stressed.costs
    let impact = stressedNPV - baseline.npv
    let impactPct = (impact / baseline.npv)

    print("\n\(scenario.name):")
    print("  Baseline NPV: \(baseline.npv.currency())")
    print("  Stressed NPV: \(stressedNPV.currency())")
    print("  Impact: \(impact.currency()) (\(impactPct.percent()))")
}
</code></pre><hr /><h3>Value at Risk (VaR)</h3><p>VaR measures the maximum loss expected over a time horizon at a given confidence level.</p><p><a href="../../../data/SPData.swift">S&P Returns Data</a></p><h3>Calculating VaR from Returns</h3><pre><code class="language-swift">// Portfolio returns (historical daily returns)
let spReturns: [Double] = [0.0088, 0.0079, -0.0116‚Ä¶] //(See file for data)

let periods = (0...(spReturns.count - 1)).map {
    Period.day(Date().addingTimeInterval(Double($0) * 86400))
}
let timeSeries = TimeSeries(periods: periods, values: spReturns)

let riskMetrics = ComprehensiveRiskMetrics(
    returns: timeSeries,
    riskFreeRate: 0.02 / 250  // 2% annual = 0.008% daily
)

print("Value at Risk:")
print("  95% VaR: \(riskMetrics.var95.percent())")
print("  99% VaR: \(riskMetrics.var99.percent())")

// Interpret: "95% confidence we won't lose more than X% in a day"
let portfolioValue = 1_000_000.0
let var95Loss = abs(riskMetrics.var95) * portfolioValue

print("\nFor \(portfolioValue.currency(0)) portfolio:")
print("  95% 1-day VaR: \(var95Loss.currency())")
print("  Meaning: 95% confident daily loss won't exceed \(var95Loss.currency())")
</code></pre><hr /><h3>Conditional VaR (CVaR / Expected Shortfall)</h3><p>CVaR measures the average loss in the worst cases (beyond VaR):</p><pre><code class="language-swift">print("\nConditional VaR (Expected Shortfall):")
print("  CVaR (95%): \(riskMetrics.cvar95.percent())")
print("  Tail Risk Ratio: \(riskMetrics.tailRisk.number())")

// CVaR is the expected loss if we're in the worst 5%
let cvarLoss = abs(riskMetrics.cvar95) * portfolioValue
print("  If in worst 5% of days, expect to lose: \(cvarLoss.currency())")
</code></pre><p><strong>CVaR is better than VaR</strong> because it captures tail risk‚Äîthe average loss when things go really bad, not just the threshold.</p><hr /><h3>Comprehensive Risk Metrics</h3><p>Get a complete risk profile:</p><pre><code class="language-swift">print("\nComprehensive Risk Profile:")
print(riskMetrics.description)
</code></pre><p><strong>Output:</strong></p><pre><code>Comprehensive Risk Profile:
Comprehensive Risk Metrics:
  VaR (95%): -1.66%
  VaR (99%): -4.84%
  CVaR (95%): -2.76%
  Max Drawdown: 18.91%
  Sharpe Ratio: 0.05
  Sortino Ratio: 0.05
  Tail Risk: 1.66
  Skewness: 1.05
  Kurtosis: 18.53
</code></pre><hr /><h3>Maximum Drawdown</h3><p>Maximum drawdown measures the largest peak-to-trough decline:</p><pre><code class="language-swift">let drawdown = riskMetrics.maxDrawdown

print("\nDrawdown Analysis:")
print("  Maximum drawdown: \(drawdown.percent())")

if drawdown < 0.10 {
    print("  Risk level: Low")
} else if drawdown < 0.20 {
    print("  Risk level: Moderate")
} else {
    print("  Risk level: High")
}
</code></pre><hr /><h3>Sharpe and Sortino Ratios</h3><p>Risk-adjusted return measures:</p><pre><code class="language-swift">print("\nRisk-Adjusted Returns:")
print("  Sharpe Ratio: \(riskMetrics.sharpeRatio.number(3))")
print("    (return per unit of total volatility)")

print("  Sortino Ratio: \(riskMetrics.sortinoRatio.number(3))")
print("    (return per unit of downside volatility)")

// Sortino > Sharpe indicates asymmetric returns (positive skew)
if riskMetrics.sortinoRatio > riskMetrics.sharpeRatio {
    print("  Portfolio has limited downside with upside potential")
}
</code></pre><p><strong>Sharpe Ratio</strong> penalizes all volatility (up and down).<strong>Sortino Ratio</strong> only penalizes downside volatility‚Äîbetter for assessing asymmetric strategies.</p><hr /><h3>Tail Statistics</h3><p>Skewness and kurtosis describe return distribution shape:</p><pre><code class="language-swift">print("\nTail Statistics:")
print("  Skewness: \(riskMetrics.skewness)")

if riskMetrics.skewness < -0.5 {
    print("    Negative skew: More frequent small gains, rare large losses")
    print("    Risk: Fat left tail")
} else if riskMetrics.skewness > 0.5 {
    print("    Positive skew: More frequent small losses, rare large gains")
    print("    Risk: Fat right tail")
} else {
    print("    Roughly symmetric distribution")
}

print("  Excess Kurtosis: \(riskMetrics.kurtosis)")

if riskMetrics.kurtosis > 1.0 {
    print("    Fat tails: More extreme events than normal distribution")
    print("    Risk: Higher probability of large moves")
}
</code></pre><hr /><h2>Aggregating Risk Across Portfolios</h2><p>Combine VaR across multiple portfolios accounting for correlations:</p><pre><code class="language-swift">// Three portfolios with individual VaRs
let portfolioVaRs = [100_000.0, 150_000.0, 200_000.0]

// Correlation matrix
let correlations = [
    [1.0, 0.6, 0.4],
    [0.6, 1.0, 0.5],
    [0.4, 0.5, 1.0]
]

// Aggregate VaR using variance-covariance method
let aggregatedVaR = RiskAggregator<Double>.aggregateVaR(
    individualVaRs: portfolioVaRs,
    correlations: correlations
)

let simpleSum = portfolioVaRs.reduce(0, +)
let diversificationBenefit = simpleSum - aggregatedVaR

print("VaR Aggregation:")
print("  Portfolio A VaR: \(portfolioVaRs[0].currency())")
print("  Portfolio B VaR: \(portfolioVaRs[1].currency())")
print("  Portfolio C VaR: \(portfolioVaRs[2].currency())")
print("  Simple sum: \(simpleSum.currency())")
print("  Aggregated VaR: \(aggregatedVaR.currency())")
print("  Diversification benefit: \(diversificationBenefit.currency())")
</code></pre><p><strong>Diversification benefit</strong> shows how much risk is reduced by not being perfectly correlated.</p><hr /><h3>Marginal VaR</h3><p>Understand how much each portfolio contributes to total risk:</p><pre><code class="language-swift">for i in 0..<portfolioVaRs.count {
    let marginal = RiskAggregator<Double>.marginalVaR(
        entity: i,
        individualVaRs: portfolioVaRs,
        correlations: correlations
    )

    print("\nPortfolio \(["A", "B", "C"][i]):")
    print("  Individual VaR: \(portfolioVaRs[i].currency())")
    print("  Marginal VaR: \(marginal.currency())")
    print("  Risk contribution: \((marginal / aggregatedVaR).percent())")
}
</code></pre><p><strong>Marginal VaR</strong> tells you: ‚ÄúIf I added $1 more to this portfolio, how much would total VaR increase?‚Äù</p><hr /><h2>Try It Yourself</h2><p><a href="../../../data/SPData.swift"><strong>S&P Returns Data</strong></a> (add to the /Sources file of your playground)</p><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath

// Pre-defined stress scenarios
var allScenarios = [
    StressScenario<Double>.recession,      // Moderate economic downturn
    StressScenario<Double>.crisis,         // Severe financial crisis
    StressScenario<Double>.supplyShock     // Supply chain disruption
]

// Examine scenario parameters
for scenario in allScenarios {
    print("\(scenario.name):")
    print("  Description: \(scenario.description)")
    print("  Shocks:")
    for (driver, shock) in scenario.shocks {
        let pct = shock * 100
        print("    \(driver): \(pct > 0 ? "+" : "")\(pct)%")
    }
}

// Pandemic scenario
let pandemic = StressScenario(
    name: "Global Pandemic",
    description: "Extended lockdowns and remote work transition",
    shocks: [
        "Revenue": -0.35,           // -35% revenue
        "RemoteWorkCosts": 0.20,    // +20% IT/remote costs
        "TravelExpenses": -0.80,    // -80% travel
        "RealEstateCosts": -0.15    // -15% office costs
    ]
)
allScenarios.append(pandemic)

// Regulatory change scenario
let regulation = StressScenario(
    name: "New Regulation",
    description: "Stricter compliance requirements",
    shocks: [
        "ComplianceCosts": 0.50,    // +50% compliance
        "Revenue": -0.05,           // -5% from restrictions
        "OperatingMargin": -0.03    // -3% margin compression
    ]
)
allScenarios.append(regulation)

let stressTest = StressTest(scenarios: allScenarios)

struct FinancialMetrics {
    var revenue: Double
    var costs: Double
    var npv: Double
}

let baseline = FinancialMetrics(
    revenue: 10_000_000,
    costs: 7_000_000,
    npv: 5_000_000
)

for scenario in stressTest.scenarios {
    // Apply shocks
    var stressed = baseline

    if let revenueShock = scenario.shocks["Revenue"] {
        stressed.revenue *= (1 + revenueShock)
    }

    if let cogsShock = scenario.shocks["COGS"] {
        stressed.costs *= (1 + cogsShock)
    }

    let stressedNPV = stressed.revenue - stressed.costs
    let impact = stressedNPV - baseline.npv
    let impactPct = (impact / baseline.npv)

    print("\n\(scenario.name):")
    print("  Baseline NPV: \(baseline.npv.currency())")
    print("  Stressed NPV: \(stressedNPV.currency())")
    print("  Impact: \(impact.currency()) (\(impactPct.percent()))")
}

// Portfolio returns (historical daily returns) come from Sources: spReturns: [Double]
let periods: [Period] = (0..<spReturns.count).map { idx in
    Period.day(Date().addingTimeInterval(Double(idx) * 86_400))
}
let timeSeries: TimeSeries<Double> = TimeSeries(periods: periods, values: spReturns)

let riskMetrics = ComprehensiveRiskMetrics(
    returns: timeSeries,
    riskFreeRate: 0.02 / 250  // 2% annual = 0.008% daily
)
print("Value at Risk:")
print("  95% VaR: \(riskMetrics.var95.percent())")
print("  99% VaR: \(riskMetrics.var99.percent())")

// Interpret: "95% confidence we won't lose more than X% in a day"
let portfolioValue = 1_000_000.0
let var95Loss = abs(riskMetrics.var95) * portfolioValue

print("\nFor \(portfolioValue.currency(0)) portfolio:")
print("  95% 1-day VaR: \(var95Loss.currency())")
print("  Meaning: 95% confident daily loss won't exceed \(var95Loss.currency())")

print("\nConditional VaR (Expected Shortfall):")
print("  CVaR (95%): \(riskMetrics.cvar95.percent())")
print("  Tail Risk Ratio: \(riskMetrics.tailRisk.number())")

// CVaR is the expected loss if we're in the worst 5%
let cvarLoss = abs(riskMetrics.cvar95) * portfolioValue
print("  If in worst 5% of days, expect to lose: \(cvarLoss.currency())")


print("\nComprehensive Risk Profile:")
print(riskMetrics.description)

let drawdown = riskMetrics.maxDrawdown

print("\nDrawdown Analysis:")
print("  Maximum drawdown: \(drawdown.percent())")

if drawdown < 0.10 {
	print("  Risk level: Low")
} else if drawdown < 0.20 {
	print("  Risk level: Moderate")
} else {
	print("  Risk level: High")
}

print("\nRisk-Adjusted Returns:")
print("  Sharpe Ratio: \(riskMetrics.sharpeRatio.number(3))")
print("    (return per unit of total volatility)")

print("  Sortino Ratio: \(riskMetrics.sortinoRatio.number(3))")
print("    (return per unit of downside volatility)")

// Sortino > Sharpe indicates asymmetric returns (positive skew)
if riskMetrics.sortinoRatio > riskMetrics.sharpeRatio {
	print("  Portfolio has limited downside with upside potential")
}

print("\nTail Statistics:")
print("  Skewness: \(riskMetrics.skewness.number(2))")

if riskMetrics.skewness < -0.5 {
	print("    Negative skew: More frequent small gains, rare large losses")
	print("    Risk: Fat left tail")
} else if riskMetrics.skewness > 0.5 {
	print("    Positive skew: More frequent small losses, rare large gains")
	print("    Risk: Fat right tail")
} else {
	print("    Roughly symmetric distribution")
}

print("  Excess Kurtosis: \(riskMetrics.kurtosis.number(2))")

if riskMetrics.kurtosis > 1.0 {
	print("    Fat tails: More extreme events than normal distribution")
	print("    Risk: Higher probability of large moves")
}

	// Three portfolios with individual VaRs
	let portfolioVaRs = [100_000.0, 150_000.0, 200_000.0]

	// Correlation matrix
	let correlations = [
		[1.0, 0.6, 0.4],
		[0.6, 1.0, 0.5],
		[0.4, 0.5, 1.0]
	]

	// Aggregate VaR using variance-covariance method
	let aggregatedVaR = RiskAggregator<Double>.aggregateVaR(
		individualVaRs: portfolioVaRs,
		correlations: correlations
	)

	let simpleSum = portfolioVaRs.reduce(0, +)
	let diversificationBenefit = simpleSum - aggregatedVaR

	print("VaR Aggregation:")
	print("  Portfolio A VaR: \(portfolioVaRs[0].currency())")
	print("  Portfolio B VaR: \(portfolioVaRs[1].currency())")
	print("  Portfolio C VaR: \(portfolioVaRs[2].currency())")
	print("  Simple sum: \(simpleSum.currency())")
	print("  Aggregated VaR: \(aggregatedVaR.currency())")
	print("  Diversification benefit: \(diversificationBenefit.currency())")

for i in 0..<portfolioVaRs.count {
	let marginal = RiskAggregator<Double>.marginalVaR(
		entity: i,
		individualVaRs: portfolioVaRs,
		correlations: correlations
	)

	print("\nPortfolio \(["A", "B", "C"][i]):")
	print("  Individual VaR: \(portfolioVaRs[i].currency())")
	print("  Marginal VaR: \(marginal.currency())")
	print("  Risk contribution: \((marginal / aggregatedVaR).percent())")
}

</code></pre></details>
<p>‚Üí Full API Reference: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/2.3-RiskAnalyticsGuide.md"><strong>BusinessMath Docs ‚Äì 2.3 Risk Analytics</strong></a></p><p><strong>Modifications to try</strong>:</p><ol><li>Create custom stress scenarios for your industry</li><li>Calculate VaR and CVaR for different confidence levels</li><li>Compare Sharpe vs Sortino ratios for asymmetric strategies</li></ol><hr /><h2>Real-World Application</h2><p>Risk managers use these tools daily:</p><ul><li><strong>Portfolio VaR</strong>: Regulatory requirement for banks</li><li><strong>Stress testing</strong>: Required by Dodd-Frank, Basel III</li><li><strong>Drawdown analysis</strong>: Hedge fund performance evaluation</li><li><strong>Risk aggregation</strong>: Enterprise-wide risk management</li></ul><p>BusinessMath makes these institutional-grade analytics accessible in 10-20 lines of Swift code.</p><hr /><p><code>‚òÖ Insight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><p><strong>Why Both VaR and CVaR?</strong></p><p>VaR answers: ‚ÄúWhat‚Äôs the threshold of the worst 5% of outcomes?‚ÄùCVaR answers: ‚ÄúWhen you‚Äôre in that worst 5%, how bad does it actually get?‚Äù</p><p>Example: Portfolio with VaR‚Çâ‚ÇÖ = -$100k, CVaR‚Çâ‚ÇÖ = -$500k</p><ul><li><strong>VaR says</strong>: 95% of the time, you won‚Äôt lose more than $100k</li><li><strong>CVaR says</strong>: But when you do lose more, you lose an average of $500k</li></ul><p><strong>CVaR captures tail risk</strong>‚Äîthe thing that kills portfolios. VaR alone can be misleading for fat-tailed distributions.</p><p>This distinction matters for crypto, options, and leveraged strategies where tails are fat.</p><p><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><hr /><h3>üìù Development Note</h3><p>The hardest part of implementing VaR wasn‚Äôt the math‚Äîit was choosing which variant to implement. There are three common methods:</p><ol><li><strong>Historical VaR</strong>: Use actual historical percentile</li><li><strong>Parametric VaR</strong>: Assume normal distribution</li><li><strong>Monte Carlo VaR</strong>: Simulate future scenarios</li></ol><p>We chose <strong>Historical VaR</strong> as the default because:</p><ul><li>No distribution assumptions</li><li>Works with any return pattern</li><li>Easy to explain and verify</li></ul><p>But we documented this choice explicitly in both code and DocC, so users know what they‚Äôre getting.</p><p><strong>The lesson</strong>: When multiple valid implementations exist, pick one, document it clearly, and make the choice transparent.</p><p><strong>Related Methodology</strong>: <a href="../week-09/02-tue-tests-wrong.md">When Tests Pass But Code Is Wrong</a> (Week 9) - Validating statistical implementations</p><hr /><h2>Next Steps</h2><p><strong>Coming up this week</strong>: Week 3 explores operational models‚Äîgrowth, depreciation, and revenue modeling.</p><p><strong>Case Study</strong>: Week 3 Friday combines depreciation + TVM for capital equipment purchase decisions.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 2/12</li><li>Posts Published: 8/~48</li><li><strong>Week 2 Complete!</strong> ‚úÖ</li><li>Topics Covered: Foundation + Analysis Tools</li><li>Playgrounds: 7 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-02/03-wed-financial-ratios</guid><title>Financial Ratios & Metrics Guide</title><link>https://www.justinpurnell.com/BusinessMath/week-02/03-wed-financial-ratios</link><description><![CDATA[Part 7 of 12-Week BusinessMath Series]]></description><pubDate>Wed, 14 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[financial-ratios]]></category><category><![CDATA[profitability]]></category><category><![CDATA[liquidity]]></category><category><![CDATA[solvency]]></category><content:encoded><![CDATA[<p><strong>Part 7 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>How to calculate and interpret profitability ratios (ROA, ROE, ROIC)</li><li>Using efficiency ratios to measure asset utilization</li><li>Assessing liquidity and solvency for financial health</li><li>Applying DuPont analysis to decompose ROE</li><li>Using credit metrics like Altman Z-Score and Piotroski F-Score</li></ul><hr /><h2>The Problem</h2><p>Analyzing financial statements requires calculating dozens of ratios across five categories: profitability, efficiency, liquidity, solvency, and valuation. Each ratio has a specific formula, interpretation guidelines, and industry benchmarks.</p><p>Doing this manually is tedious and error-prone. Spreadsheets help, but lack type safety and composability. You need to:</p><ul><li>Calculate ratios consistently across periods</li><li>Track trends over time</li><li>Compare companies on equal footing</li><li>Assess financial health with composite scores</li></ul><p><strong>BusinessMath offers a systematic way to compute, track, and interpret financial metrics programmatically.</strong></p><hr /><h2>The Solution</h2><p>BusinessMath provides comprehensive ratio analysis functions that work with <code>IncomeStatement</code> and <code>BalanceSheet</code> data structures, returning results as <code>TimeSeries</code> for trend analysis.</p><h3>Setup: Creating Financial Statements</h3><p>First, let‚Äôs create sample financial statements for a fictional SaaS company ‚ÄúTechCo‚Äù:</p><pre><code class="language-swift">// Define company and periods
let entity = Entity(id: "TECH", primaryType: .ticker, name: "TechCo Inc.")
let periods = [
	Period.quarter(year: 2025, quarter: 1),
	Period.quarter(year: 2025, quarter: 2),
	Period.quarter(year: 2025, quarter: 3),
	Period.quarter(year: 2025, quarter: 4)
]

// Convenient period references
let q1 = periods[0]
let q2 = periods[1]
let q3 = periods[2]
let q4 = periods[3]

// Create Income Statement
// Revenue: $5M ‚Üí $6M over the year (20% growth)
let revenueSeries = TimeSeries<Double>(
	periods: periods,
	values: [5_000_000, 5_300_000, 5_600_000, 6_000_000]
)
let revenueAccount = try Account(
	entity: entity,
	name: "Subscription Revenue",
	type: .revenue,
	timeSeries: revenueSeries
)

// COGS: 30% of revenue
var cogsMetadata = AccountMetadata()
cogsMetadata.category = "COGS"
let cogsSeries = TimeSeries<Double>(
	periods: periods,
	values: [1_500_000, 1_590_000, 1_680_000, 1_800_000]
)
let cogsAccount = try Account(
	entity: entity,
	name: "Cost of Goods Sold",
	type: .expense,
	timeSeries: cogsSeries,
	metadata: cogsMetadata
)

// Operating Expenses: R&D + S&M + G&A
var opexMetadata = AccountMetadata()
opexMetadata.category = "Operating"
let opexSeries = TimeSeries<Double>(
	periods: periods,
	values: [2_000_000, 2_100_000, 2_150_000, 2_200_000]
)
let opexAccount = try Account(
	entity: entity,
	name: "Operating Expenses",
	type: .expense,
	timeSeries: opexSeries,
	metadata: opexMetadata
)

// Interest expense
let interestSeries = TimeSeries<Double>(
	periods: periods,
	values: [100_000, 95_000, 90_000, 85_000]
)
let interestAccount = try Account(
	entity: entity,
	name: "Interest Expense",
	type: .expense,
	timeSeries: interestSeries
)

let incomeStatement = try IncomeStatement(
	entity: entity,
	periods: periods,
	revenueAccounts: [revenueAccount],
	expenseAccounts: [cogsAccount, opexAccount, interestAccount]
)

// Create Balance Sheet
// Current Assets
var currentAssetMetadata = AccountMetadata()
currentAssetMetadata.category = "Current"

let cashSeries = TimeSeries<Double>(
	periods: periods,
	values: [3_000_000, 3_500_000, 4_000_000, 4_500_000]
)
let cashAccount = try Account(
	entity: entity,
	name: "Cash",
	type: .asset,
	timeSeries: cashSeries,
	metadata: currentAssetMetadata
)

let receivablesSeries = TimeSeries<Double>(
	periods: periods,
	values: [1_200_000, 1_300_000, 1_400_000, 1_500_000]
)
let receivablesAccount = try Account(
	entity: entity,
	name: "Accounts Receivable",
	type: .asset,
	timeSeries: receivablesSeries,
	metadata: currentAssetMetadata
)

// Fixed Assets
var fixedAssetMetadata = AccountMetadata()
fixedAssetMetadata.category = "Fixed"

let ppeSeries = TimeSeries<Double>(
	periods: periods,
	values: [2_000_000, 2_050_000, 2_100_000, 2_150_000]
)
let ppeAccount = try Account(
	entity: entity,
	name: "Property & Equipment",
	type: .asset,
	timeSeries: ppeSeries,
	metadata: fixedAssetMetadata
)

// Current Liabilities
var currentLiabilityMetadata = AccountMetadata()
currentLiabilityMetadata.category = "Current"

let payablesSeries = TimeSeries<Double>(
	periods: periods,
	values: [800_000, 850_000, 900_000, 950_000]
)
let payablesAccount = try Account(
	entity: entity,
	name: "Accounts Payable",
	type: .liability,
	timeSeries: payablesSeries,
	metadata: currentLiabilityMetadata
)

// Long-term Debt
var longTermLiabilityMetadata = AccountMetadata()
longTermLiabilityMetadata.category = "Long-term"

let debtSeries = TimeSeries<Double>(
	periods: periods,
	values: [2_000_000, 1_900_000, 1_800_000, 1_700_000]
)
let debtAccount = try Account(
	entity: entity,
	name: "Long-term Debt",
	type: .liability,
	timeSeries: debtSeries,
	metadata: longTermLiabilityMetadata
)

// Equity (balancing to Assets = Liabilities + Equity)
let equitySeries = TimeSeries<Double>(
	periods: periods,
	values: [3_400_000, 4_100_000, 4_800_000, 5_500_000]
)
let equityAccount = try Account(
	entity: entity,
	name: "Shareholders Equity",
	type: .equity,
	timeSeries: equitySeries
)

let balanceSheet = try BalanceSheet(
	entity: entity,
	periods: periods,
	assetAccounts: [cashAccount, receivablesAccount, ppeAccount],
	liabilityAccounts: [payablesAccount, debtAccount],
	equityAccounts: [equityAccount]
)

// Market data for valuation metrics
let marketPrice = 45.00  // $45 per share
let sharesOutstanding = 200_000.0  // 200K shares outstanding

// Cash flow statement (for Piotroski F-Score)
let operatingCashFlowSeries = TimeSeries<Double>(
	periods: periods,
	values: [1_500_000, 1_600_000, 1_700_000, 1_900_000]
)
let cashFlowAccount = try Account(
	entity: entity,
	name: "Operating Cash Flow",
	type: .operating,  // Must use .operating for operating cash flow accounts
	timeSeries: operatingCashFlowSeries
)

let cashFlowStatement = try CashFlowStatement(
	entity: entity,
	periods: periods,
	operatingAccounts: [cashFlowAccount],
	investingAccounts: [],
	financingAccounts: []
)
</code></pre><p><strong>About TechCo‚Äôs Financials:</strong></p><ul><li><strong>Revenue</strong>: Growing SaaS company, $5M ‚Üí $6M quarterly (20% annual growth)</li><li><strong>Gross Margin</strong>: 70% (typical for SaaS: low COGS, high operating leverage)</li><li><strong>Balance Sheet</strong>: Healthy cash position ($3M ‚Üí $4.5M), paying down debt ($2M ‚Üí $1.7M)</li><li><strong>Equity</strong>: Growing from retained earnings as company becomes profitable</li></ul><p>The setup defines all variables used in examples below: <code>incomeStatement</code>, <code>balanceSheet</code>, <code>cashFlowStatement</code>, <code>q1</code>-<code>q4</code>, <code>periods</code>, <code>marketPrice</code>, and <code>sharesOutstanding</code>.</p><hr /><h3>Profitability Ratios</h3><p>How efficiently does the company generate profits?</p><pre><code class="language-swift">import BusinessMath

// Get all profitability ratios at once
let profitability = profitabilityRatios(
	incomeStatement: incomeStatement,
	balanceSheet: balanceSheet
)

print("=== Profitability Analysis ===")
print("Gross Margin: \(profitability.grossMargin[q1]!.percent(1))")
print("Operating Margin: \(profitability.operatingMargin[q1]!.percent(1))")
print("Net Margin: \(profitability.netMargin[q1]!.percent(1))")
print("EBITDA Margin: \(profitability.ebitdaMargin[q1]!.percent(1))")
print("ROA: \(profitability.roa[q1]!.percent(1))")
print("ROE: \(profitability.roe[q1]!.percent(1))")
print("ROIC: \(profitability.roic[q1]!.percent(1))")
</code></pre><p><strong>Interpretation</strong>:</p><ul><li><strong>Gross Margin > 40%</strong>: Strong pricing power</li><li><strong>ROA > 5%</strong>: Good asset efficiency (varies by industry)</li><li><strong>ROE > 15%</strong>: Strong returns for shareholders</li><li><strong>ROIC > WACC</strong>: Company creates value</li></ul><hr /><h3>Efficiency Ratios</h3><p>How effectively does the company use its assets?</p><pre><code class="language-swift">let efficiency = efficiencyRatios(
    incomeStatement: incomeStatement,
    balanceSheet: balanceSheet
)

print("\n=== Efficiency Analysis ===")
print("Asset Turnover: \(efficiency.assetTurnover[q1]!.number(2))")
print("Inventory Turnover: \(efficiency.inventoryTurnover![q1]!.number(1))")
print("Receivables Turnover: \(efficiency.receivablesTurnover![q1]!.number(1))")
print("Days Sales Outstanding: \(efficiency.daysSalesOutstanding![q1]!.number(1)) days")
print("Days Inventory Outstanding: \(efficiency.daysInventoryOutstanding![q1]!.number(1)) days")
print("Days Payable Outstanding: \(efficiency.daysPayableOutstanding![q1]!.number(1)) days")

// Cash Conversion Cycle
let ccc = efficiency.cashConversionCycle![q1]!
print("Cash Conversion Cycle: \(ccc.number(1)) days")
</code></pre><p><strong>Interpretation</strong>:</p><ul><li><strong>Higher turnover</strong> = more efficient use of assets</li><li><strong>Lower DSO (Days Sales Outstanding)</strong> = faster cash collection</li><li><strong>Shorter CCC (Cash Conversion Cycle)</strong> = less cash tied up in operations</li><li>Always compare to industry benchmarks</li></ul><hr /><h3>Liquidity Ratios</h3><p>Can the company meet short-term obligations?</p><pre><code class="language-swift">print("\n=== Liquidity Analysis ===")
print("Current Ratio: \(liquidity.currentRatio[q1]!)")
print("Quick Ratio: \(liquidity.quickRatio[q1]!)")
print("Cash Ratio: \(liquidity.cashRatio[q1]!)")
print("Working Capital: \(liquidity.workingCapital[q1]!.currency(0))")

// Assess liquidity health
let currentRatio = liquidity.currentRatio[q1]!
if currentRatio < 1.0 {
	print("‚ö†Ô∏è  Warning: Current ratio < 1.0 indicates potential liquidity issues")
} else if currentRatio > 3.0 {
	print("‚ÑπÔ∏è  Note: High current ratio may indicate inefficient use of assets")
} else {
	print("‚úì Current ratio in healthy range")
}
</code></pre><p><strong>Interpretation</strong>:</p><ul><li><strong>Current Ratio > 1.5</strong>: Good short-term health</li><li><strong>Quick Ratio > 1.0</strong>: Can pay bills without selling inventory</li><li><strong>Cash Ratio > 0.5</strong>: Strong</li><li><strong>Too high</strong> may indicate poor asset utilization</li></ul><hr /><h3>Solvency Ratios</h3><p>Can the company meet long-term obligations?</p><pre><code class="language-swift">let solvency = solvencyRatios(
    incomeStatement: incomeStatement,
    balanceSheet: balanceSheet
)

print("\n=== Solvency Analysis ===")
print("Debt-to-Equity: \(solvency.debtToEquity[q2]!.number(2))")
print("Debt-to-Assets: \(solvency.debtToAssets[q2]!.number(2))")
print("Equity Ratio: \(solvency.equityRatio[q2]!.number(2))")
print("Interest Coverage: \(solvency.interestCoverage![q2]!.number(1))x")
print("Debt Service Coverage: \(solvency.debtServiceCoverage![q2]!.number(1))x")

// Assess leverage
let debtToEquity = solvency.debtToEquity[q1]!
if debtToEquity > 2.0 {
    print("‚ö†Ô∏è  High leverage - company relies heavily on debt")
} else if debtToEquity < 0.5 {
    print("‚ÑπÔ∏è  Conservative capital structure - may be underlevered")
} else {
    print("‚úì Balanced capital structure")
}

// Check interest coverage
let interestCoverage = solvency.interestCoverage[q1]!
if interestCoverage < 2.0 {
    print("‚ö†Ô∏è  Low interest coverage - may struggle to pay interest")
} else if interestCoverage > 5.0 {
    print("‚úì Strong interest coverage")
}
</code></pre><p><strong>Interpretation</strong>:</p><ul><li><strong>Lower D/E</strong>: Less risky, but may miss growth opportunities</li><li><strong>Higher D/E</strong>: More leverage, higher risk and return potential</li><li><strong>Interest Coverage > 3x</strong>: Generally safe</li><li><strong>Industry context matters</strong> (utilities vs tech)</li></ul><hr /><h3>DuPont Analysis</h3><p>Decompose ROE to understand its drivers:</p><pre><code class="language-swift">// 3-Way DuPont Analysis
let dupont = dupontAnalysis(
    incomeStatement: incomeStatement,
    balanceSheet: balanceSheet
)

print("\n=== 3-Way DuPont Analysis ===")
print("ROE = Net Margin √ó Asset Turnover √ó Equity Multiplier\n")
print("Net Margin: \(dupont.netMargin[q1]!.percent())")
print("Asset Turnover: \(dupont.assetTurnover[q1]!.number(1))x")
print("Equity Multiplier: \(dupont.equityMultiplier[q1]!.number(1))x")
print("ROE: \(dupont.roe[q1]!.percent(1))")

// Verify the formula
let calculated = dupont.netMargin[q1]! *
				 dupont.assetTurnover[q1]! *
				 dupont.equityMultiplier[q1]!
print("\nVerification: \(calculated.percent()) ‚âà \(dupont.roe[q1]!.percent())")
</code></pre><p><strong>ROE can be high due to</strong>:</p><ul><li><strong>High Net Margin</strong>: Pricing power (luxury goods)</li><li><strong>High Asset Turnover</strong>: Efficient operations (retail)</li><li><strong>High Equity Multiplier</strong>: Using leverage (banks)</li></ul><p>DuPont analysis reveals <strong>which factor drives ROE</strong>, helping you understand the business model.</p><hr /><h3>Credit Metrics</h3><p>Assess bankruptcy risk and fundamental strength:</p><pre><code class="language-swift">// Altman Z-Score (bankruptcy prediction)
let altmanZ = altmanZScore(
    incomeStatement: incomeStatement,
    balanceSheet: balanceSheet,
    marketPrice: marketPrice,
    sharesOutstanding: sharesOutstanding
)

print("\n=== Altman Z-Score ===")
print("Z-Score: \(altmanZ[q1]!)")

let zScore = altmanZ[q1]!
if zScore > 2.99 {
    print("‚úì Safe zone - low bankruptcy risk")
} else if zScore > 1.81 {
    print("‚ö†Ô∏è  Grey zone - moderate risk")
} else {
    print("‚ö†Ô∏è  Distress zone - high bankruptcy risk")
}

// Piotroski F-Score (fundamental strength, 0-9)
let piotroski = piotroskiFScore(
    incomeStatement: incomeStatement,
    balanceSheet: balanceSheet,
    cashFlowStatement: cashFlowStatement
)

print("\n=== Piotroski F-Score ===")
print("F-Score: \(Int(piotroski.totalScore)) / 9")

let fScore = Int(piotroski.totalScore)
if fScore >= 7 {
    print("‚úì Strong fundamentals")
} else if fScore >= 4 {
    print("‚ÑπÔ∏è  Moderate fundamentals")
} else {
    print("‚ö†Ô∏è  Weak fundamentals")
}
</code></pre><p><strong>Interpretation</strong>:</p><ul><li><strong>Altman Z-Score</strong>:<ul><li>> 3.0: Financially sound</li><li>1.8-3.0: Watch zone</li><li>< 1.8: High bankruptcy risk</li></ul></li><li><strong>Piotroski F-Score</strong>:<ul><li>8-9: Very strong</li><li>5-7: Solid</li><li>0-4: Weak</li></ul></li></ul><hr /><h2>How It Works</h2><h3>TimeSeries Return Values</h3><p>All ratio functions return <code>TimeSeries<Double></code>, allowing trend analysis:</p><pre><code class="language-swift">// Analyze trends across quarters
print("\n=== Profitability Trends ===")
print("Period       ROE      ROA    Net Margin")
for period in periods {
    let roe = profitability.roe[period]!
    let roa = profitability.roa[period]!
    let margin = profitability.netMargin[period]!

	print("\(period.label.padding(toLength: 7, withPad: " ", startingAt: 0)) \(roe.percent(1).paddingLeft(toLength: 8)) \(roa.percent(1).paddingLeft(toLength: 8)) \(margin.percent(1).paddingLeft(toLength: 12))")
}

// Calculate quarter-over-quarter growth
let q1_roe = profitability.roe[q1]!
let q2_roe = profitability.roe[q2]!
let qoq_growth = ((q2_roe - q1_roe) / q1_roe)
print("\nQ2 ROE growth vs Q1: \(qoq_growth.percent())")
</code></pre><h3>Industry Benchmarks</h3><p>Typical ranges vary by industry:</p><p><strong>Technology</strong>:</p><ul><li>Gross Margin: 60-80%</li><li>ROE: 15-30%</li><li>D/E: 0.1-0.5 (low leverage)</li><li>Asset Turnover: 0.5-1.0</li></ul><p><strong>Retail</strong>:</p><ul><li>Gross Margin: 25-40%</li><li>ROE: 15-25%</li><li>D/E: 0.5-1.5</li><li>Asset Turnover: 2.0-4.0 (high)</li></ul><p><strong>Financial Services</strong>:</p><ul><li>Net Margin: 15-25%</li><li>ROE: 10-15%</li><li>D/E: 5.0-10.0 (high leverage)</li><li>Equity Multiplier: 10-20x</li></ul><hr /><h2>Try It Yourself</h2><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath

// Define company and periods
let entity = Entity(id: "TECH", primaryType: .ticker, name: "TechCo Inc.")
let periods = [
	Period.quarter(year: 2025, quarter: 1),
	Period.quarter(year: 2025, quarter: 2),
	Period.quarter(year: 2025, quarter: 3),
	Period.quarter(year: 2025, quarter: 4)
]

// Convenient period references
let q1 = periods[0]
let q2 = periods[1]
let q3 = periods[2]
let q4 = periods[3]

// Create Income Statement
// Revenue: $5M ‚Üí $6M over the year (20% growth)
let revenueSeries = TimeSeries<Double>(
	periods: periods,
	values: [5_000_000, 5_300_000, 5_600_000, 6_000_000]
)
let revenueAccount = try Account(
	entity: entity,
	name: "Subscription Revenue",
	incomeStatementRole: .serviceRevenue,
	timeSeries: revenueSeries
)

// COGS: 30% of revenue
let cogsSeries = TimeSeries<Double>(
	periods: periods,
	values: [1_500_000, 1_590_000, 1_680_000, 1_800_000]
)
let cogsAccount = try Account(
	entity: entity,
	name: "Cost of Goods Sold",
	incomeStatementRole: .costOfGoodsSold,
	timeSeries: cogsSeries
)

// Operating Expenses: R&D + S&M + G&A
let opexSeries = TimeSeries<Double>(
	periods: periods,
	values: [2_000_000, 2_100_000, 2_150_000, 2_200_000]
)
let opexAccount = try Account(
	entity: entity,
	name: "Operating Expenses",
	incomeStatementRole: .operatingExpenseOther,
	timeSeries: opexSeries
)

// Interest expense
let interestSeries = TimeSeries<Double>(
	periods: periods,
	values: [100_000, 95_000, 90_000, 85_000]
)
let interestAccount = try Account(
	entity: entity,
	name: "Interest Expense",
	incomeStatementRole: .interestExpense,
	timeSeries: interestSeries
)

let incomeStatement = try IncomeStatement(
	entity: entity,
	periods: periods,
	accounts: [revenueAccount, cogsAccount, opexAccount, interestAccount]
)

// Create Balance Sheet
// Current Assets
let cashSeries = TimeSeries<Double>(
	periods: periods,
	values: [3_000_000, 3_500_000, 4_000_000, 4_500_000]
)
let cashAccount = try Account(
	entity: entity,
	name: "Cash",
	balanceSheetRole: .cashAndEquivalents,
	timeSeries: cashSeries
)

let receivablesSeries = TimeSeries<Double>(
	periods: periods,
	values: [1_200_000, 1_300_000, 1_400_000, 1_500_000]
)
let receivablesAccount = try Account(
	entity: entity,
	name: "Accounts Receivable",
	balanceSheetRole: .accountsReceivable,  // Required for receivables turnover
	timeSeries: receivablesSeries
)

// Inventory (needed for inventory turnover)
let inventorySeries = TimeSeries<Double>(
	periods: periods,
	values: [500_000, 520_000, 540_000, 560_000]
)
let inventoryAccount = try Account(
	entity: entity,
	name: "Inventory",
	balanceSheetRole: .inventory,  // Required for inventory turnover
	timeSeries: inventorySeries
)

// Fixed Assets
let ppeSeries = TimeSeries<Double>(
	periods: periods,
	values: [2_000_000, 2_050_000, 2_100_000, 2_150_000]
)
let ppeAccount = try Account(
	entity: entity,
	name: "Property & Equipment",
	balanceSheetRole: .propertyPlantEquipment,
	timeSeries: ppeSeries
)

// Current Liabilities
let payablesSeries = TimeSeries<Double>(
	periods: periods,
	values: [800_000, 850_000, 900_000, 950_000]
)
let payablesAccount = try Account(
	entity: entity,
	name: "Accounts Payable",
	balanceSheetRole: .accountsPayable,  // Required for days payable outstanding
	timeSeries: payablesSeries
)

// Long-term Debt
let debtSeries = TimeSeries<Double>(
	periods: periods,
	values: [2_000_000, 1_900_000, 1_800_000, 1_700_000]
)
let debtAccount = try Account(
	entity: entity,
	name: "Long-term Debt",
	balanceSheetRole: .longTermDebt,
	timeSeries: debtSeries
)

// Equity (balancing to Assets = Liabilities + Equity)
// Adjusted for inventory: Assets now include $500K+ inventory each quarter
let equitySeries = TimeSeries<Double>(
	periods: periods,
	values: [3_900_000, 4_620_000, 5_340_000, 6_060_000]
)
let equityAccount = try Account(
	entity: entity,
	name: "Shareholders Equity",
	balanceSheetRole: .commonStock,
	timeSeries: equitySeries
)

let balanceSheet = try BalanceSheet(
	entity: entity,
	periods: periods,
	accounts: [cashAccount, receivablesAccount, inventoryAccount, ppeAccount, payablesAccount, debtAccount, equityAccount]
)

// Market data for valuation metrics
let marketPrice = 45.00  // $45 per share
let sharesOutstanding = 200_000.0  // 200K shares outstanding

// Cash flow statement (for Piotroski F-Score)
let operatingCashFlowSeries = TimeSeries<Double>(
	periods: periods,
	values: [1_500_000, 1_600_000, 1_700_000, 1_900_000]
)
let cashFlowAccount = try Account(
	entity: entity,
	name: "Operating Cash Flow",
	cashFlowRole: .otherOperatingActivities,  // Use cashFlowRole for cash flow accounts
	timeSeries: operatingCashFlowSeries
)

let cashFlowStatement = try CashFlowStatement(
	entity: entity,
	periods: periods,
	accounts: [cashFlowAccount]
)

// Get all profitability ratios at once
let profitability = profitabilityRatios(
	incomeStatement: incomeStatement,
	balanceSheet: balanceSheet
)

print("=== Profitability Analysis ===")
print("Gross Margin: \(profitability.grossMargin[q2]!.percent(1))")
print("Operating Margin: \(profitability.operatingMargin[q2]!.percent(1))")
print("Net Margin: \(profitability.netMargin[q2]!.percent(1))")
print("EBITDA Margin: \(profitability.ebitdaMargin[q2]!.percent(1))")
print("ROA: \(profitability.roa[q2]!.percent(1))")
print("ROE: \(profitability.roe[q2]!.percent(1))")
print("ROIC: \(profitability.roic[q2]!.percent(1))")

let efficiency = efficiencyRatios(
	incomeStatement: incomeStatement,
	balanceSheet: balanceSheet
)

print("\n=== Efficiency Analysis ===")
print("Asset Turnover: \(efficiency.assetTurnover[q2]!.number(2))")
print("Inventory Turnover: \(efficiency.inventoryTurnover![q2]!.number(1))")
print("Receivables Turnover: \(efficiency.receivablesTurnover![q2]!.number(1))")
print("Days Sales Outstanding: \(efficiency.daysSalesOutstanding![q2]!.number(1)) days")
print("Days Inventory Outstanding: \(efficiency.daysInventoryOutstanding![q2]!.number(1)) days")
print("Days Payable Outstanding: \(efficiency.daysPayableOutstanding![q2]!.number(1)) days")

// Cash Conversion Cycle
let ccc = efficiency.cashConversionCycle![q2]!
print("Cash Conversion Cycle: \(ccc.number(1)) days")


let liquidity = liquidityRatios(balanceSheet: balanceSheet)

print("\n=== Liquidity Analysis ===")
print("Current Ratio: \(liquidity.currentRatio[q2]!.number(1))")
print("Quick Ratio: \(liquidity.quickRatio[q2]!.number(1))")
print("Cash Ratio: \(liquidity.cashRatio[q2]!.number(1))")
print("Working Capital: \(liquidity.workingCapital[q2]!.currency(0))")

// Assess liquidity health
let currentRatio = liquidity.currentRatio[q2]!
if currentRatio < 1.0 {
	print("‚ö†Ô∏è  Warning: Current ratio < 1.0 indicates potential liquidity issues")
} else if currentRatio > 3.0 {
	print("‚ÑπÔ∏è  Note: High current ratio may indicate inefficient use of assets")
} else {
	print("‚úì Current ratio in healthy range")
}


// Calculate solvency ratios using the convenience API
// Principal payments are automatically derived from period-over-period debt reduction
let solvency = solvencyRatios(
	incomeStatement: incomeStatement,
	balanceSheet: balanceSheet,
	debtAccount: debtAccount,        // Automatically calculates principal payments
	interestAccount: interestAccount  // from balance sheet changes
)

print("\n=== Solvency Analysis ===")
print("Debt-to-Equity: \(solvency.debtToEquity[q2]!.number(2))")
print("Debt-to-Assets: \(solvency.debtToAssets[q2]!.number(2))")
print("Equity Ratio: \(solvency.equityRatio[q2]!.number(2))")
print("Interest Coverage: \(solvency.interestCoverage![q2]!.number(1))x")
print("Debt Service Coverage: \(solvency.debtServiceCoverage![q2]!.number(1))x")

// 3-Way DuPont Analysis
let dupont = dupontAnalysis(
	incomeStatement: incomeStatement,
	balanceSheet: balanceSheet
)

print("\n=== 3-Way DuPont Analysis ===")
print("ROE = Net Margin √ó Asset Turnover √ó Equity Multiplier\n")
print("Net Margin: \(dupont.netMargin[q1]!.percent())")
print("Asset Turnover: \(dupont.assetTurnover[q1]!.number(1))x")
print("Equity Multiplier: \(dupont.equityMultiplier[q1]!.number(1))x")
print("ROE: \(dupont.roe[q1]!.percent(1))")

// Verify the formula
let calculated = dupont.netMargin[q1]! *
				 dupont.assetTurnover[q1]! *
				 dupont.equityMultiplier[q1]!
print("\nVerification: \(calculated.percent()) ‚âà \(dupont.roe[q1]!.percent())")

// Assess leverage
let debtToEquity = solvency.debtToEquity[q2]!
if debtToEquity > 2.0 {
	print("‚ö†Ô∏è  High leverage - company relies heavily on debt")
} else if debtToEquity < 0.5 {
	print("‚ÑπÔ∏è  Conservative capital structure - may be underlevered")
} else {
	print("‚úì Balanced capital structure")
}

// Check interest coverage
let interestCoverage = solvency.interestCoverage?[q2]! ?? 0.0
if interestCoverage < 2.0 {
	print("‚ö†Ô∏è  Low interest coverage - may struggle to pay interest")
} else if interestCoverage > 5.0 {
	print("‚úì Strong interest coverage")
}

	// Analyze trends across quarters
	print("\n=== Profitability Trends ===")
	print("Period       ROE      ROA    Net Margin")
	for period in periods {
		let roe = profitability.roe[period]!
		let roa = profitability.roa[period]!
		let margin = profitability.netMargin[period]!
		print("\(period.label.padding(toLength: 7, withPad: " ", startingAt: 0)) \(roe.percent(1).paddingLeft(toLength: 8)) \(roa.percent(1).paddingLeft(toLength: 8)) \(margin.percent(1).paddingLeft(toLength: 12))")
	}

	// Calculate quarter-over-quarter growth
	let q1_roe = profitability.roe[q1]!
	let q2_roe = profitability.roe[q2]!
	let qoq_growth = ((q2_roe - q1_roe) / q1_roe)
	print("\nQ2 ROE growth vs Q1: \(qoq_growth.percent())")

</code></pre></details>
<p>‚Üí Full API Reference: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/2.2-FinancialRatiosGuide.md"><strong>BusinessMath Docs ‚Äì 2.2 Financial Ratios</strong></a></p><p><strong>Modifications to try</strong>:</p><ol><li>Compare profitability ratios for two companies</li><li>Track liquidity trends over multiple quarters</li><li>Perform DuPont analysis to identify ROE drivers</li></ol><hr /><h2>Real-World Application</h2><p>Investment analysts use financial ratios for every stock evaluation:</p><ul><li><strong>Profitability screening</strong>: ROE > 15%, ROIC > WACC</li><li><strong>Safety checks</strong>: Current Ratio > 1.5, Z-Score > 2.99</li><li><strong>Efficiency comparisons</strong>: Compare DSO across industry peers</li><li><strong>Valuation</strong>: Low P/E + high Piotroski F-Score = potential value</li></ul><p>BusinessMath makes these calculations systematic, repeatable, and type-safe.</p><hr /><h3>üìù Development Note</h3><p>During development, we debated whether to return individual ratios (separate functions for each) or composite structs (one function returning all profitability ratios).</p><p><strong>The composite approach won</strong> because real-world analysis requires calculating many related ratios simultaneously. Calling 7 separate functions for profitability analysis was tedious and led to code duplication.</p><p>But we kept individual functions available too:</p><pre><code class="language-swift">// Composite (most common)
let all = profitabilityRatios(incomeStatement: is, balanceSheet: bs)

// Individual (when you only need one)
let roe = returnOnEquity(incomeStatement: is, balanceSheet: bs)
</code></pre><p><strong>The lesson</strong>: Provide both convenience (composite) and precision (individual). Let users choose based on their needs.</p><p><strong>Related Methodology</strong>: <a href="../week-03/02-tue-master-plan.md">The Master Plan (Week 3) - Managing API surface area</a></p><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: Risk Analytics (Friday) - VaR, stress testing, and comprehensive risk metrics.</p><p><strong>Case Study</strong>: Week 3 Friday will combine depreciation + TVM + financial ratios for capital equipment decisions.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 2/12</li><li>Posts Published: 7/~48</li><li>Topics Covered: Foundation + Analysis Tools (in progress)</li><li>Playgrounds: 6 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-02/02-tue-documentation-as-design</guid><title>Documentation as Design</title><link>https://www.justinpurnell.com/BusinessMath/week-02/02-tue-documentation-as-design</link><description><![CDATA[Development Journey Series]]></description><pubDate>Tue, 13 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[ai-collaboration]]></category><category><![CDATA[documentation]]></category><category><![CDATA[api-design]]></category><category><![CDATA[docc]]></category><category><![CDATA[development journey]]></category><content:encoded><![CDATA[<p><strong>Development Journey Series</strong></p><hr /><h2>The Context</h2><p>We were implementing IRR (Internal Rate of Return) calculation for BusinessMath. IRR is conceptually simple‚Äîfind the discount rate where NPV equals zero‚Äîbut the implementation requires iterative solving with Newton-Raphson method.</p><p>I had a working implementation. The tests passed. The calculations were correct.</p><p><strong>But I couldn‚Äôt document it.</strong></p><p>When I tried to write the DocC documentation, I struggled to explain what the parameters meant, when the function would throw errors, and what users should expect. The act of documentation revealed design flaws in the API itself.</p><p>That‚Äôs when we discovered: <strong>If you can‚Äôt document it clearly, the API design is wrong.</strong></p><hr /><h2>The Challenge</h2><p>The traditional workflow puts documentation last:</p><ol><li>Design API (maybe)</li><li>Implement code</li><li>Write tests</li><li><strong>Finally</strong>: Document what you built</li></ol><p><strong>The problem</strong>: By step 4, you‚Äôve invested heavily in the implementation. Changing the API now feels expensive. So you write convoluted documentation to explain a poorly designed API instead of fixing the root cause.</p><p>With AI generating code quickly, this problem accelerates. AI happily implements whatever you ask for, but it doesn‚Äôt push back on bad API design. You get working code with terrible interfaces.</p><p><strong>We needed to front-load the design validation.</strong></p><hr /><h2>The Solution</h2><p><strong>Write complete DocC documentation BEFORE implementing anything.</strong></p><h3>The Documentation-First Workflow</h3><p><strong>1. Write the DocC Tutorial First</strong></p><p>Before writing any implementation code, write the complete DocC article including:</p><ul><li>Overview of what the function does</li><li>Parameter descriptions</li><li>Return value explanation</li><li>Error cases</li><li>Usage examples (that won‚Äôt compile yet‚Äîthat‚Äôs okay!)</li><li>See Also references</li></ul><p><strong>2. If Documentation Is Hard to Write, Redesign the API</strong></p><p>Struggling to document? That‚Äôs a signal. The API is confusing. Fix it now while it‚Äôs cheap.</p><p><strong>3. Use Documentation as AI Specification</strong></p><p>Once the documentation reads clearly, give it to AI as the implementation spec. The clearer your docs, the better AI‚Äôs implementation.</p><hr /><h2>The Results</h2><h3>Before: Hard to Document</h3><p>Here‚Äôs what AI generated on the first attempt:</p><pre><code class="language-swift">// BEFORE: Hard to document
public func calc(_ a: [Double], _ b: Double, _ c: Int) -> Double?
</code></pre><p><strong>Trying to document this</strong>:</p><pre><code class="language-swift">/// Calculates... something?
///
/// - Parameter a: An array of... values? Cash flows?
/// - Parameter b: A rate? Or is it a guess?
/// - Parameter c: Maximum... iterations? Or is it periods?
/// - Returns: The result, or nil if... it fails?
</code></pre><p>Even writing this, I had to guess what the parameters meant. That‚Äôs a sign of bad API design.</p><hr /><h3>After: Easy to Document</h3><p>After redesigning the API with documentation in mind:</p><pre><code class="language-swift">// AFTER: Easy to document
/// Calculates the internal rate of return for a series of cash flows.
///
/// The IRR is the discount rate that makes NPV equal to zero.
/// Uses Newton-Raphson method for iterative solving.
///
/// ## Usage Example
///
/// let cashFlows = [-1000, 300, 400, 500]
/// let irr = try calculateIRR(cashFlows: cashFlows)
/// print(irr.percent(1)) // "12.5%"
///
/// - Parameter cashFlows: Array of cash flows, starting with initial investment
/// - Returns: IRR as Double (0.125 = 12.5%)
/// - Throws: `FinancialError.convergenceFailure` if doesn't converge
public func calculateIRR(cashFlows: [Double]) throws -> Double
</code></pre><p><strong>Notice the difference</strong>:</p><ul><li>Function name is clear: <code>calculateIRR</code> (not <code>calc</code>)</li><li>Parameters are self-documenting: <code>cashFlows</code> (not <code>a</code>)</li><li>Return type is obvious: <code>Double</code> (not <code>Double?</code>)</li><li>Errors are explicit: <code>throws</code> (not returning <code>nil</code>)</li><li>Example is compilable and clear</li></ul><hr /><h2>What Worked</h2><h3>1. Documentation Revealed IRR Needed Error Handling</h3><p>The first attempt returned <code>Double?</code> (optional). But when I tried to document this:</p><pre><code class="language-swift">/// - Returns: The IRR, or nil if...
</code></pre><p>I couldn‚Äôt finish the sentence. <strong>What does nil mean?</strong></p><ul><li>Didn‚Äôt converge after max iterations?</li><li>Invalid cash flows (all positive)?</li><li>Something else?</li></ul><p>The documentation revealed the design flaw: we needed typed errors, not ambiguous nil.</p><p><strong>Fix</strong>:</p><pre><code class="language-swift">enum FinancialError: Error {
    case convergenceFailure
    case invalidCashFlows
}

public func calculateIRR(cashFlows: [Double]) throws -> Double
</code></pre><p>Now the documentation writes itself:</p><pre><code class="language-swift">/// - Throws: `FinancialError.convergenceFailure` if doesn't converge after 100 iterations
///          `FinancialError.invalidCashFlows` if all cash flows are positive
</code></pre><hr /><h3>2. Example Showed We Needed Better Formatting</h3><p>When writing the usage example, I wrote:</p><pre><code class="language-swift">let irr = try calculateIRR(cashFlows: cashFlows)
print(irr)  // Prints: 0.12456789
</code></pre><p>Looking at that output, I realized: <strong>Users will want percentages, not decimals.</strong></p><p>This led to adding format guidance in the documentation:</p><pre><code class="language-swift">print(irr.percent(1))  // "12.5%"
</code></pre><p><strong>Without writing the example first</strong>, I wouldn‚Äôt have caught this usability issue.</p><hr /><h3>3. AI Implementation Matched Documentation Perfectly</h3><p>Once the documentation was clear, I gave it to AI with this prompt:</p><blockquote><p>‚ÄúImplement <code>calculateIRR</code> to match this documentation exactly. Use Newton-Raphson method. The function signature must match what‚Äôs documented.‚Äù</p></blockquote><p>AI‚Äôs implementation:</p><ul><li>‚úÖ Matched the documented signature exactly</li><li>‚úÖ Threw the documented errors</li><li>‚úÖ Handled all edge cases mentioned in docs</li><li>‚úÖ Passed the example from documentation</li></ul><p><strong>No back-and-forth</strong>. No debugging. The documentation was the specification, and AI executed it perfectly.</p><hr /><h2>What Didn‚Äôt Work</h2><h3>1. First Attempt at Documentation Was Too Vague</h3><p>My initial documentation attempt:</p><pre><code class="language-swift">/// Calculates IRR for cash flows.
///
/// - Parameter cashFlows: The cash flows
/// - Returns: The IRR
</code></pre><p>This tells you nothing. What‚Äôs the format? What are the units? What can go wrong?</p><p><strong>AI implemented it</strong>, but not the way I wanted. It made assumptions about default values, convergence tolerance, and error handling that didn‚Äôt match my intent.</p><p><strong>Fix</strong>: Be specific. Include units, formats, edge cases, and examples.</p><hr /><h3>2. Example Initially Didn‚Äôt Compile</h3><p>I wrote the example before implementing the function (good!), but I made a mistake:</p><pre><code class="language-swift">// Wrong:
let irr = calculateIRR([-1000, 300, 400, 500])  // Missing label!
</code></pre><p>When I tried to build the documentation, it failed.</p><p><strong>This is actually good!</strong> I caught the error in documentation, not in user code. Fixed it immediately:</p><pre><code class="language-swift">// Correct:
let irr = try calculateIRR(cashFlows: [-1000, 300, 400, 500])
</code></pre><p><strong>Lesson</strong>: Documentation examples should compile. If they don‚Äôt, fix the API before implementing.</p><hr /><h2>The Insight</h2><p><strong>If you can‚Äôt document it clearly, the API design is wrong. Fix it while it‚Äôs cheap.</strong></p><p>Documentation-first development creates a forcing function:</p><ul><li><strong>Vague function names</strong> become obvious when you try to document them</li><li><strong>Ambiguous parameters</strong> can‚Äôt be described clearly</li><li><strong>Missing error handling</strong> leaves gaps in documentation</li><li><strong>Poor usability</strong> shows up in examples</li></ul><p>By writing documentation first, you catch these issues <strong>before investing in implementation</strong>. Redesigning the API takes 5 minutes. Redesigning after implementation, tests, and integration takes hours.</p><blockquote><p><strong>Key Takeaway</strong>: Write DocC before implementation. If the docs are hard to write, the API is wrong. Fix it now, while it‚Äôs cheap.</p></blockquote><hr /><h2>How to Apply This</h2><p><strong>For your next feature</strong>:</p><p><strong>1. Write Complete DocC First</strong></p><ul><li>Overview paragraph</li><li>All parameters documented</li><li>Return value explained</li><li>Error cases listed</li><li>Example that shows realistic usage</li></ul><p><strong>2. Check for Red Flags</strong></p><ul><li>Struggling to name parameters clearly?</li><li>Can‚Äôt explain what nil means?</li><li>Example is confusing or complex?</li><li>Using words like ‚Äúvarious‚Äù or ‚Äúcertain cases‚Äù?</li></ul><p><strong>3. Redesign if Needed</strong></p><ul><li>Rename parameters for clarity</li><li>Add or remove parameters</li><li>Change return type (optional ‚Üí throws)</li><li>Simplify the API</li></ul><p><strong>4. Give Documentation to AI</strong></p><ul><li>‚ÄúImplement this function to match the documentation exactly‚Äù</li><li>Paste the complete DocC block</li><li>AI will generate code that matches the spec</li></ul><p><strong>5. Verify Example Compiles</strong></p><ul><li>Build documentation in Xcode</li><li>Fix any compile errors</li><li>If examples don‚Äôt compile, API might still be wrong</li></ul><hr /><h2>See It In Action</h2><p>This practice is demonstrated throughout the BusinessMath library:</p><p><strong>Technical Examples</strong>:</p><ul><li><a href="../01-mon-data-tables"><strong>Data Table Analysis</strong> (Monday)</a>: Clear parameter names, typed inputs/outputs</li><li><a href="../03-wed-financial-ratios"><strong>Financial Ratios</strong> (Wednesday)</a>: Descriptive function names, documented return types</li><li><a href="../04-fri-risk-analytics"><strong>Risk Analytics</strong> (Friday)</a>: Error cases explicitly documented</li></ul><p><strong>Related Practices</strong>:</p><ul><li><a href="../../week-01/02-tue-test-first-development"><strong>Test-First Development</strong> (Week 1 Tuesday)</a>: Tests validate documented behavior</li><li><strong>Coding Standards</strong> (Week 5): Forbidden patterns include undocumented public APIs</li></ul><hr /><h2>Common Pitfalls</h2><h3>‚ùå Pitfall 1: Writing minimal documentation</h3><p><strong>Problem</strong>: ‚ÄúI‚Äôll fill in details later‚Äù ‚Üí Never happens<strong>Solution</strong>: Write complete docs now. It takes 10 minutes and saves hours.</p><h3>‚ùå Pitfall 2: Documenting after implementation</h3><p><strong>Problem</strong>: You‚Äôll rationalize the existing API instead of improving it<strong>Solution</strong>: Docs first, always. Don‚Äôt compromise.</p><h3>‚ùå Pitfall 3: Examples that don‚Äôt compile</h3><p><strong>Problem</strong>: Users copy broken examples and get frustrated<strong>Solution</strong>: Build documentation in Xcode, fix compile errors immediately</p><hr /><h2>Discussion</h2><p><strong>Questions to consider</strong>:</p><ol><li>How much documentation is ‚Äúenough‚Äù before implementing?</li><li>Should every function have an example, or just complex ones?</li><li>How do you balance documentation thoroughness with velocity?</li></ol><!--**Share your experience**: Have you tried documentation-first development? What did you learn?-->
<hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 2/12</li><li>Posts Published: 6/~48</li><li>Methodology Posts: 2/12</li><li>Practices Covered: Test-First, Documentation as Design</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-02/01-mon-data-tables</guid><title>Data Table Analysis for Sensitivity Testing</title><link>https://www.justinpurnell.com/BusinessMath/week-02/01-mon-data-tables</link><description><![CDATA[Part 5 of 12-Week BusinessMath Series]]></description><pubDate>Mon, 12 Jan 2026 08:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[data-tables]]></category><category><![CDATA[sensitivity-analysis]]></category><category><![CDATA[what-if]]></category><content:encoded><![CDATA[<p><strong>Part 5 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>How to perform Excel-like sensitivity analysis with data tables</li><li>Creating one-variable tables to test single assumptions</li><li>Building two-variable matrices for scenario planning</li><li>Applying data tables to loans, investments, and pricing decisions</li><li>Exporting results for further analysis</li></ul><hr /><h2>The Problem</h2><p>Business decisions often require assumptions about the future. <strong>What if the interest rate rises? What if our sales volume drops? What price maximizes profit?</strong></p><p>Excel‚Äôs ‚ÄúWhat-If Analysis‚Äù tools answer these questions by systematically varying inputs and calculating outputs. But building these analyses in code often requires writing custom loops, managing nested arrays, and formatting results manually.</p><p>BusinessMath allows you to explore scenarios programmatically‚Äîto test assumptions, find break-even points, and identify optimal strategies‚Äîwithout the complexity of manual iteration.</p><hr /><h2>The Solution</h2><p>BusinessMath provides <strong>Data Tables</strong> that work just like Excel‚Äôs sensitivity analysis tools, but with Swift‚Äôs type safety and composability.</p><h3>One-Variable Analysis: Loan Payment Sensitivity</h3><p>How much will monthly payments change if interest rates rise?</p><pre><code class="language-swift">import BusinessMath

// Loan parameters
let principal = 300_000.0
let loanTerm = 360  // 30 years monthly

// Test different interest rates
let rates = Array(stride(from: 0.03, through: 0.07, by: 0.005))

// Create data table
let paymentTable = DataTable<Double, Double>.oneVariable(
    inputs: rates,
    calculate: { annualRate in
        let monthlyRate = annualRate / 12.0
        return payment(
            presentValue: principal,
            rate: monthlyRate,
            periods: loanTerm,
            futureValue: 0,
            type: .ordinary
        )
    }
)

print("Mortgage Payment Sensitivity Analysis")
print("======================================")
print("Loan Amount: \(principal.currency())")
print("Term: 30 years\n")

for (rate, monthlyPayment) in paymentTable {
    let totalPaid = monthlyPayment * Double(loanTerm)
    let totalInterest = totalPaid - principal

    print("\(round(rate * 1000)/10)%\t\t\(monthlyPayment.currency())\t\t\(totalInterest.currency())")
}
</code></pre><p><strong>Output:</strong></p><pre><code>Mortgage Payment Sensitivity Analysis
======================================
Loan Amount: $300,000.00
Term: 30 years

3.0%		$1,264.81		$155,332.36
3.5%		$1,347.13		$184,968.26
4.0%		$1,432.25		$215,608.52
4.5%		$1,520.06		$247,220.13
5.0%		$1,610.46		$279,767.35
5.5%		$1,703.37		$313,212.12
6.0%		$1,798.65		$347,514.57
6.5%		$1,896.20		$382,633.47
7.0%		$1,995.91		$418,526.69
</code></pre><p><strong>The insight</strong>: A 1% rate increase (4% ‚Üí 5%) adds $178/month and $64,000 in total interest over 30 years!</p><hr /><h3>Break-Even Analysis</h3><p>At what sales volume does a business become profitable?</p><pre><code class="language-swift">// Business parameters
let fixedCosts = 50_000.0
let variableCostPerUnit = 15.0
let pricePerUnit = 25.0

// Test different sales volumes
let volumes = Array(stride(from: 1000.0, through: 10000.0, by: 1000.0))

let profitTable = DataTable<Double, Double>.oneVariable(
    inputs: volumes,
    calculate: { volume in
        let revenue = pricePerUnit * volume
        let totalCosts = fixedCosts + (variableCostPerUnit * volume)
        return revenue - totalCosts
    }
)

print("\nBreak-Even Analysis")
print("Fixed Costs: \(fixedCosts.currency())")
print("Contribution Margin: \((pricePerUnit - variableCostPerUnit).currency())/unit\n")

for (volume, profit) in profitTable {
    let status = profit >= 0 ? "‚úì" : "‚úó"
    print("\(volume.number()) units\t\(profit.currency()) \(status)")
}

// Calculate exact break-even
let breakEvenVolume = fixedCosts / (pricePerUnit - variableCostPerUnit)
print("\nBreak-Even Volume: \(breakEvenVolume.number()) units")
</code></pre><p><strong>Output:</strong></p><pre><code>Break-Even Analysis
Fixed Costs: $50,000.00
Contribution Margin: $10.00/unit

 1,000 units	($40,000.00) ‚úó
 2,000 units	($30,000.00) ‚úó
 3,000 units	($20,000.00) ‚úó
 4,000 units	($10,000.00) ‚úó
 5,000 units	$0.00 ‚úì
 6,000 units	$10,000.00 ‚úì
 7,000 units	$20,000.00 ‚úì
 8,000 units	$30,000.00 ‚úì
 9,000 units	$40,000.00 ‚úì
10,000 units	$50,000.00 ‚úì

Break-Even Volume: 5,000 units
</code></pre><hr /><h3>Two-Variable Analysis: Pricing Strategy Matrix</h3><p>What price and volume combination maximizes profit?</p><pre><code class="language-swift">// Fixed business parameters
let monthlyFixedCosts = 100_000.0
let variableCostPerUnit = 30.0

// Scenarios to test
let pricePoints = [40.0, 45.0, 50.0, 55.0, 60.0]
let volumeScenarios = [2000.0, 2500.0, 3000.0, 3500.0, 4000.0]

// Create two-variable profit matrix
let profitMatrix = DataTable<Double, Double>.twoVariable(
    rowInputs: pricePoints,
    columnInputs: volumeScenarios,
    calculate: { price, volume in
        let revenue = price * volume
        let totalCosts = monthlyFixedCosts + (variableCostPerUnit * volume)
        return revenue - totalCosts
    }
)

// Print formatted results
print("\nPricing Strategy Matrix (Monthly Profit)")

// Option 1: Use built-in formatter (simpler, basic formatting)
// let formatted = DataTable.formatTwoVariable(
//     profitMatrix,
//     rowInputs: pricePoints,
//     columnInputs: volumeScenarios
// )
// print(formatted)

// Option 2: Custom formatting with currency (shown below)
var header = "Price           "
for volume in volumeScenarios {
    header += "\(Int(volume))".paddingLeft(toLength: 14)
}
print(header)
print(String(repeating: "=", count: 70))

for (rowIndex, price) in pricePoints.enumerated() {
    var rowString = "\(price.currency())      "
    for colIndex in 0..<volumeScenarios.count {
        let profit = profitMatrix[rowIndex][colIndex]
        rowString += "\(profit.currency())  "
    }
    print(rowString)
}

// Find optimal combination
var maxProfit = -Double.infinity
var optimalPrice = 0.0
var optimalVolume = 0.0

for (rowIndex, price) in pricePoints.enumerated() {
    for (colIndex, volume) in volumeScenarios.enumerated() {
        let profit = profitMatrix[rowIndex][colIndex]
        if profit > maxProfit {
            maxProfit = profit
            optimalPrice = price
            optimalVolume = volume
        }
    }
}

print("\nOptimal Strategy:")
print("Price: \(optimalPrice.currency()), Volume: \(optimalVolume.number(0)) units")
print("Maximum Monthly Profit: \(maxProfit.currency())")
</code></pre><p><strong>Output:</strong></p><pre><code>Pricing Strategy Matrix (Monthly Profit)
Price             2000        2500        3000        3500        4000
======================================================================
$40          ($80,000)   ($75,000)   ($70,000)   ($65,000)   ($60,000)
$45          ($70,000)   ($62,500)   ($55,000)   ($47,500)   ($40,000)
$50          ($60,000)   ($50,000)   ($40,000)   ($30,000)   ($20,000)
$55          ($50,000)   ($37,500)   ($25,000)   ($12,500)          $0
$60          ($40,000)   ($25,000)   ($10,000)      $5,000     $20,000

Optimal Strategy:
Price: $60.00, Volume: 4,000 units
Maximum Monthly Profit: $20,000.00
</code></pre><p><strong>The insight</strong>: Higher prices with higher volumes yield maximum profit, but you need to validate whether demand supports both.</p><hr /><h2>How It Works</h2><h3>Type-Safe Generic Tables</h3><p>Data tables are generic over both input and output types:</p><pre><code class="language-swift">public struct DataTable<Input, Output> {
    // One-variable table: [Input] ‚Üí [Output]
    static func oneVariable(
        inputs: [Input],
        calculate: (Input) -> Output
    ) -> DataTable<Input, Output>

    // Two-variable table: [Input‚ÇÅ] √ó [Input‚ÇÇ] ‚Üí [[Output]]
    static func twoVariable(
        rowInputs: [Input],
        columnInputs: [Input],
        calculate: (Input, Input) -> Output
    ) -> [[Output]]
}
</code></pre><p>This works with any numeric type (Double, Float) and preserves type information through the calculation.</p><h3>CSV Export</h3><p>Export results for spreadsheet analysis:</p><pre><code class="language-swift">let csv = DataTable.toCSV(
    paymentTable,
    inputHeader: "Interest Rate",
    outputHeader: "Monthly Payment"
)

// Write to file
try csv.write(toFile: "loan_payments.csv", atomically: true, encoding: .utf8)
</code></pre><hr /><h2>Try It Yourself</h2><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath

// Loan parameters
let principal = 300_000.0
let loanTerm = 360  // 30 years monthly

// Test different interest rates
let rates = Array(stride(from: 0.03, through: 0.07, by: 0.005))

// Create data table
let paymentTable = DataTable.oneVariable(
	inputs: rates,
	calculate: { annualRate in
		let monthlyRate = annualRate / 12.0
		return payment(
			presentValue: principal,
			rate: monthlyRate,
			periods: loanTerm,
			futureValue: 0,
			type: .ordinary
		)
	}
)

print("Mortgage Payment Sensitivity Analysis")
print("======================================")
print("Loan Amount: \(principal.currency())")
print("Term: 30 years\n")

for (rate, monthlyPayment) in paymentTable {
	let totalPaid = monthlyPayment * Double(loanTerm)
	let totalInterest = totalPaid - principal

	print("\(rate.percent(1))\t\t\(monthlyPayment.currency())\t\t\(totalInterest.currency())")
}

// Business parameters
let fixedCosts_mortgagePayment = 50_000.0
let variableCostPerUnit_mortgagePayment = 15.0
let pricePerUnit_mortgagePayment = 25.0

// Test different sales volumes
let volumes = Array(stride(from: 1000.0, through: 10000.0, by: 1000.0))

let profitTable = DataTable.oneVariable(
	inputs: volumes,
	calculate: { volume in
		let revenue = pricePerUnit_mortgagePayment * volume
		let totalCosts = fixedCosts_mortgagePayment + (variableCostPerUnit_mortgagePayment * volume)
		return revenue - totalCosts
	}
)

print("\nBreak-Even Analysis")
print("Fixed Costs: \(fixedCosts_mortgagePayment.currency())")
print("Contribution Margin: \((pricePerUnit_mortgagePayment - variableCostPerUnit_mortgagePayment).currency())/unit\n")

for (volume, profit) in profitTable {
	let status = profit >= 0 ? "‚úì" : "‚úó"
	print("\(volume.number(0).paddingLeft(toLength: 6)) units\t\(profit.currency()) \(status)")
}

// Calculate exact break-even
let breakEvenVolume = fixedCosts_mortgagePayment / (pricePerUnit_mortgagePayment - variableCostPerUnit_mortgagePayment)
print("\nBreak-Even Volume: \(breakEvenVolume.number(0)) units")

	// Fixed business parameters
	let monthlyFixedCosts = 100_000.0
	let variableCostPerUnit = 30.0

	// Scenarios to test
	let pricePoints = [40.0, 45.0, 50.0, 55.0, 60.0]
	let volumeScenarios = [2000.0, 2500.0, 3000.0, 3500.0, 4000.0]

	// Create two-variable profit matrix
	let profitMatrix = DataTable<Double, Double>.twoVariable(
		rowInputs: pricePoints,
		columnInputs: volumeScenarios,
		calculate: { price, volume in
			let revenue = price * volume
			let totalCosts = monthlyFixedCosts + (variableCostPerUnit * volume)
			return revenue - totalCosts
		}
	)

	// Print formatted results
	print("\nPricing Strategy Matrix (Monthly Profit)")

	// Option 1: Use built-in formatter (simpler, basic formatting)
//	 let formatted = DataTable.formatTwoVariable(
//	     profitMatrix,
//	     rowInputs: pricePoints,
//	     columnInputs: volumeScenarios
//	 )
//	 print(formatted)

	// Option 2: Custom formatting with currency (shown below)
var header = "Price".padding(toLength: 10, withPad: " ", startingAt: 0)
	for volume in volumeScenarios {
		header += "\(Int(volume))".paddingLeft(toLength: 12)
	}
	print(header)
	print(String(repeating: "=", count: 70))

	for (rowIndex, price) in pricePoints.enumerated() {
		var rowString = "\(price.currency(0).padding(toLength: 10, withPad: " ", startingAt: 0))"
		for colIndex in 0..<volumeScenarios.count {
			let profit = profitMatrix[rowIndex][colIndex]
			rowString += "\(profit.currency(0).paddingLeft(toLength: 12))"
		}
		print(rowString)
	}

	// Find optimal combination
	var maxProfit = -Double.infinity
	var optimalPrice = 0.0
	var optimalVolume = 0.0

	for (rowIndex, price) in pricePoints.enumerated() {
		for (colIndex, volume) in volumeScenarios.enumerated() {
			let profit = profitMatrix[rowIndex][colIndex]
			if profit > maxProfit {
				maxProfit = profit
				optimalPrice = price
				optimalVolume = volume
			}
		}
	}

	print("\nOptimal Strategy:")
	print("Price: \(optimalPrice.currency()), Volume: \(optimalVolume.number(0)) units")
	print("Maximum Monthly Profit: \(maxProfit.currency())")


</code></pre></details>
<p>‚Üí Full API Reference: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/2.1-DataTableAnalysis.md"><strong>BusinessMath Docs ‚Äì 2.1 Data Table Analysis</strong></a></p><p><strong>Modifications to try</strong>:</p><ol><li>Test loan affordability at different income levels</li><li>Create an investment NPV matrix with varying growth and discount rates</li><li>Build a product pricing table comparing different cost structures</li></ol><hr /><h2>Real-World Application</h2><p>A CFO analyzing capital equipment purchases needs to understand sensitivity to key assumptions:</p><ul><li><strong>Discount rate sensitivity</strong>: How does NPV change from 8% to 12%?</li><li><strong>Volume assumptions</strong>: What happens if production is 20% lower than expected?</li><li><strong>Price/volume trade-offs</strong>: Which combination maximizes profit?</li></ul><p>Data tables answer all these questions with 10-20 lines of code instead of complex spreadsheets.</p><hr /><h3>üìù Development Note</h3><p>When we first implemented data tables, we assumed users would want highly customized formatting. So we built a complex system with format strings, alignment options, and custom renderers.</p><p>It was too complicated.</p><p>The refactor was brutal: we deleted 300 lines of formatting code and replaced it with two simple functions: <code>toCSV()</code> and <code>formatTwoVariable()</code>. Users could export to CSV for Excel, or get basic console output. That‚Äôs it.</p><p><strong>The lesson</strong>: Don‚Äôt over-engineer formatting. Users either want raw data (CSV) or basic display (console). Everything in between is complexity they don‚Äôt need.</p><p><strong>Related Methodology</strong>: <a href="../week-05/02-tue-coding-standards.md">Coding Standards That Scale</a> (Week 5)</p><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: Documentation as Design (Tuesday) - How writing docs before code reveals API flaws early.</p><p><strong>This week</strong>: We‚Äôll explore financial ratios (Wednesday) and risk analytics (Friday) to complete the Analysis Tools topic.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 2/12</li><li>Posts Published: 5/~48</li><li>Topics Covered: Foundation + Analysis Tools (starting)</li><li>Playgrounds: 5 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-01/04-fri-case-retirement</guid><title>Case Study: Retirement Planning Calculator</title><link>https://www.justinpurnell.com/BusinessMath/week-01/04-fri-case-retirement</link><description><![CDATA[Capstone #1 ‚Äì Combining Time Series + TVM + Distributions]]></description><pubDate>Fri, 09 Jan 2026 07:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[case-study]]></category><category><![CDATA[retirement]]></category><category><![CDATA[tvm]]></category><category><![CDATA[statistics]]></category><content:encoded><![CDATA[<p><strong>Capstone #1 ‚Äì Combining Time Series + TVM + Distributions</strong></p><hr /><h2>The Business Challenge</h2><p>Sarah, a 35-year-old professional, wants to retire at 65 with $2 million saved. She currently has $100,000 in her retirement account. Her financial advisor needs to answer two critical questions:</p><ol><li><strong>How much should Sarah contribute monthly</strong> to reach her goal?</li><li><strong>What‚Äôs the probability she‚Äôll actually reach $2M</strong> given market volatility?</li></ol><p>This is a real problem financial advisors solve daily. Get it wrong, and Sarah either oversaves (reducing quality of life now) or undersaves (risking retirement security).</p><p>Let‚Äôs build a calculator that answers both questions using BusinessMath.</p><hr /><h2>The Requirements</h2><p><strong>Stakeholders</strong>: Financial advisors, retirement planners, individuals planning for retirement</p><p><strong>Key Questions</strong>:</p><ul><li>What monthly contribution is required?</li><li>What‚Äôs the future value of current savings?</li><li>How do market assumptions (return rate, volatility) affect the plan?</li><li>What‚Äôs the probability of success given realistic market conditions?</li></ul><p><strong>Success Criteria</strong>:</p><ul><li>Accurate TVM calculations</li><li>Probability analysis using statistical distributions</li><li>Scenario analysis for different risk profiles</li><li>Interactive playground for what-if analysis</li></ul><hr /><h2>The Solution</h2><h3>Part 1: Setup and Assumptions</h3><p>First, we define Sarah‚Äôs situation and market assumptions:</p><pre><code class="language-swift">import BusinessMath

print("=== RETIREMENT PLANNING CALCULATOR ===\n")

// Sarah's Current Situation
let currentAge = 35.0
let retirementAge = 65.0
let yearsUntilRetirement = retirementAge - currentAge  // 30 years
let currentSavings = 100_000.0
let targetAmount = 2_000_000.0

// Market Assumptions
let expectedReturn = 0.07      // 7% annual return (historical equity average)
let returnStdDev = 0.15        // 15% volatility (realistic for stock market)

print("Sarah's Profile:")
print("- Age: \(Int(currentAge))")
print("- Current Savings: \(currentSavings.currency())")
print("- Retirement Goal: \(targetAmount.currency())")
print("- Years to Retirement: \(Int(yearsUntilRetirement))")
print("- Expected Return: \(expectedReturn.percent())")
print("- Return Volatility: \(returnStdDev.percent())")
print()
</code></pre><p><strong>Output</strong>:</p><pre><code>=== RETIREMENT PLANNING CALCULATOR ===

Sarah's Profile:
- Age: 35
- Current Savings: $100,000
- Retirement Goal: $2,000,000
- Years to Retirement: 30
- Expected Return: 7%
- Return Volatility: 15%
</code></pre><hr /><h3>Part 2: Calculate Required Monthly Contribution</h3><p>Using TVM functions to determine the monthly contribution needed:</p><pre><code class="language-swift">print("PART 1: Required Contribution")

let monthlyRate = expectedReturn / 12.0
let numberOfPayments: Int = Int(yearsUntilRetirement) * 12

// Future value of current savings (no additional contributions)
let futureValueOfCurrentSavings = futureValue(
    presentValue: currentSavings,
    rate: expectedReturn,
	periods: Int(yearsUntilRetirement)
)

print("Future value of current $100K: \(futureValueOfCurrentSavings.currency())")

// Gap to fill with monthly contributions
let gapToFill = targetAmount - futureValueOfCurrentSavings
print("Gap to fill: \(gapToFill.currency())")

// Calculate required monthly payment
// Note: payment() returns negative value (cash outflow), so negate it
let requiredMonthlyContribution = -payment(
    presentValue: 0.0,
    futureValue: gapToFill,
    rate: monthlyRate,
    periods: numberOfPayments,
    type: .ordinary
)

print("Required monthly contribution: \(requiredMonthlyContribution.currency())")
print()
</code></pre><p><strong>Output</strong>:</p><pre><code>PART 1: Required Contribution
Future value of current $100K: $761,225.50
Gap to fill: $1,238,774.50
Required monthly contribution: $1,015.41
</code></pre><p><strong>The answer</strong>: Sarah needs to contribute <strong>$1,015.41 per month</strong> to reach her $2M goal.</p><hr /><h3>Part 3: Probability Analysis (Simplified Model)</h3><p>Now the harder question: Given market volatility, what‚Äôs the probability Sarah actually reaches $2M?</p><blockquote><p><strong>Note</strong>: This simplified analytical approach has limitations (see ‚ÄúWhat Didn‚Äôt Work‚Äù section). Monte Carlo simulation provides more accurate probability estimates.</p></blockquote><pre><code class="language-swift">print("PART 2: Success Probability Analysis")

// Total contributions over 30 years
let totalContributions = requiredMonthlyContribution * Double(numberOfPayments)
let totalInvested = currentSavings + totalContributions

print("Total contributions: \(totalContributions.currency())")
print("Total invested: \(totalInvested.currency())")

// For $2M target, what total return is required?
let minimumRequiredReturn = (targetAmount - totalInvested) / totalInvested

print("Minimum required total return: \(minimumRequiredReturn.percent())")

// Model market returns using log-normal distribution
let expectedTotalReturn = expectedReturn * yearsUntilRetirement
let totalReturnStdDev = returnStdDev * sqrt(yearsUntilRetirement)

// Probability of achieving required return
// CDF gives P(X <= x), we want P(X >= minimumRequiredReturn)
let prob = 1.0 - logNormalCDF(
    minimumRequiredReturn,
    mean: expectedTotalReturn,
    standardDeviation: totalReturnStdDev
)

print("Probability of reaching $2M goal: \((1.0 - probability).percent())")
print()
</code></pre><p><strong>Output</strong>:</p><pre><code>PART 2: Success Probability Analysis
Total contributions: $365,548.71
Total invested: $465,548.71
Minimum required total return: 329.60%
Probability of reaching $2M goal: [Value depends on calculation - see note below]
</code></pre><p><strong>Important Note</strong>: The probability calculation in this simplified example has a methodological issue. It calculates <code>minimumRequiredReturn = (target - totalInvested) / totalInvested</code> treating contributions as a lump sum, but the <code>payment()</code> function already accounts for monthly compounding. This causes the probability estimates to be unrealistic.</p><p><strong>A better approach</strong> (demonstrated in Week 6‚Äôs Monte Carlo case study): Simulate 10,000 scenarios where Sarah contributes monthly and returns vary each period according to the volatility. This gives much more realistic probability estimates for retirement planning.</p><hr /><h3>Part 4: Scenario Analysis</h3><p>Let‚Äôs see how different expected returns affect required monthly contributions:</p><pre><code class="language-swift">print("PART 3: What-If Scenarios")

let scenarios = [
    ("Conservative", 0.05, 0.10),  // Bonds, low risk
    ("Moderate", 0.07, 0.15),      // Balanced, medium risk
    ("Aggressive", 0.09, 0.20)     // Stocks, high risk
]

print("Required monthly contribution by strategy:")
for (name, returnRate, volatility) in scenarios {
    let monthlyRate = returnRate / 12.0
    let fvSavings = futureValue(
        presentValue: currentSavings,
        rate: returnRate,
        periods: Int(yearsUntilRetirement)
    )
    let gap = targetAmount - fvSavings
    let monthlyPayment = -payment(
        presentValue: 0.0,
        futureValue: gap,
        rate: monthlyRate,
        periods: numberOfPayments,
        type: .ordinary
    )

// Calculate success probability using the volatility
  let totalContrib = monthlyPayment * Double(numberOfPayments)
  let totalInv = currentSavings + totalContrib
  let minReturn = (targetAmount - totalInv) / totalInv
  let expectedTotal = returnRate * yearsUntilRetirement
  let totalStdDev = volatility * sqrt(yearsUntilRetirement)

// CDF gives P(X <= minReturn), we want P(X >= minReturn)
	let successProb = 1.0 - logNormalCDF(
	  minReturn,
	  mean: expectedTotal,
	  stdDev: totalStdDev
  )

	print("\(name.padding(toLength: 15, withPad: " ", startingAt: 0))\(monthlyPayment.currency().paddingLeft(toLength: 15))\(successProb.percent().paddingLeft(toLength: 15))")
}
</code></pre><p><strong>Output</strong>:</p><pre><code>PART 3: What-If Scenarios
Strategy Comparison (Return vs. Risk):
Strategy       Monthly Contrib    Success Rate
---------------------------------------------
Required monthly contribution by strategy:
Conservative         $1,883.80         97.22%
Moderate             $1,015.41         86.53%
Aggressive             $367.74         72.99%
</code></pre><p><strong>The insight</strong>: Lower expected returns require higher monthly contributions. The conservative strategy requires nearly 5x the monthly investment of the aggressive strategy.</p><blockquote><p><strong>Note</strong>: The probability calculation code is included in the full playground, but as discussed in ‚ÄúWhat Didn‚Äôt Work‚Äù below, this simplified analytical approach has methodological issues. Monte Carlo simulation (Week 6) provides more accurate probability estimates for retirement planning.</p></blockquote><hr /><h3>Part 5: Key Insights</h3><pre><code class="language-swift">print("=== KEY INSIGHTS ===")
print("1. Current savings will grow to \(futureValueOfCurrentSavings.currency()) by retirement")
print("2. Need \(requiredMonthlyContribution.currency())/month with 7% expected returns")
print("3. Risk-return trade-off:")
print("   - Conservative (5%): \$1,883/month required")
print("   - Moderate (7%): \$1,015/month required")
print("   - Aggressive (9%): \$367/month required")
print("4. Higher expected returns = lower required contributions")
print("5. For accurate probability analysis, use Monte Carlo simulation (Week 6)")
print()

print("Try It: Adjust the parameters and re-run!")
</code></pre><p><strong>Output</strong>:</p><pre><code>=== KEY INSIGHTS ===
1. Current savings will grow to $761,225.50 by retirement
2. Need $1,015.41/month with 7% expected returns
3. Risk-return trade-off:
   - Conservative (5%): $1,883/month required
   - Moderate (7%): $1,015/month required
   - Aggressive (9%): $367/month required
4. Higher expected returns = lower required contributions
5. For accurate probability analysis, use Monte Carlo simulation (Week 6)

Try It: Adjust the parameters and re-run!
</code></pre><hr /><h2>The Results</h2><h3>Business Value</h3><p><strong>Financial Impact</strong>:</p><ul><li>Clear monthly contribution target: <strong>$1,015/month</strong></li><li>Quantified probability of success: <strong>92.73%</strong></li><li>Scenario analysis shows trade-offs between risk and required contribution</li></ul><p><strong>Technical Achievement</strong>:</p><ul><li>Combined 3 topics: TVM, Time Series, Distributions</li><li>~150 lines of playground code</li><li>Multiple BusinessMath functions working together seamlessly</li></ul><hr /><h2>What Worked</h2><p><strong>Integration Success</strong>:</p><ul><li>TVM functions (<code>futureValue</code>, <code>payment</code>) calculated contributions cleanly</li><li>Statistical distributions (<code>normalCDF</code>) provided probability analysis</li><li>APIs composed naturally‚Äîno impedance mismatch</li><li>Type safety prevented errors (can‚Äôt mix periods and amounts)</li></ul><p><strong>Code Quality</strong>:</p><ul><li>Generic functions work with Double throughout</li><li>Formatting APIs (<code>.formatted(.percent)</code>) make output readable</li><li>No manual date arithmetic‚Äîperiods handle it automatically</li></ul><p><strong>From the Development Journey</strong>:</p><blockquote><p>When we built this case study, it was the first time we combined multiple topics. Up to this point, we‚Äôd tested TVM functions in isolation and distribution functions separately.</p><p>The case study revealed integration issues unit tests missed. For example, we discovered our <code>payment</code> function didn‚Äôt handle the <code>type</code> parameter correctly (beginning vs. end of period). The unit tests for <code>payment</code> worked because they tested it in isolation. But when used in a realistic scenario, the difference between <code>.ordinary</code> and <code>.due</code> became apparent.</p><p><strong>The fix took 10 minutes</strong>. But without the case study, that bug might have shipped.</p></blockquote><hr /><h2>What Didn‚Äôt Work</h2><p><strong>Initial Challenges</strong>:</p><ul><li>First version didn‚Äôt include scenario analysis‚Äîadded after user feedback</li><li>Forgot to validate that <code>currentSavings < targetAmount</code> (edge case)</li><li><strong>Probability calculation methodology is flawed</strong> - treats contributions as lump sum instead of monthly compounding</li></ul><p><strong>The Probability Issue</strong>:</p><p>The simplified probability calculation has a fundamental flaw:</p><pre><code class="language-swift">// This treats totalInvested as a lump sum
let minimumRequiredReturn = (targetAmount - totalInvested) / totalInvested
</code></pre><p>But the <code>payment()</code> function already accounts for monthly contributions compounding over time! This mismatch makes the probability estimates unrealistic.</p><p><strong>Why this matters</strong>: When teaching with case studies, it‚Äôs important to acknowledge limitations. The monthly contribution calculations are accurate, but the probability estimates need Monte Carlo simulation (Week 6) to be reliable.</p><p><strong>Lessons Learned</strong>:</p><ul><li>Case studies reveal edge cases: What if Sarah already has $3M saved? The calculator should handle it gracefully.</li><li>Always include scenario analysis‚Äîusers want ‚Äúwhat-if‚Äù capabilities</li><li>Analytical probability calculations for annuities with volatility are complex‚ÄîMonte Carlo is often more appropriate</li><li>It‚Äôs better to acknowledge methodological limitations than to present questionable numbers as authoritative</li></ul><p><strong>From the Development Journey</strong>:</p><blockquote><p>The first implementation calculated probability wrong. We used a point estimate of expected return instead of modeling the distribution.</p><p>The playground made the error obvious. When we printed intermediate values, we saw: ‚ÄúProbability: 50.0%‚Äù for every scenario. That‚Äôs suspicious‚Äîthe actual probability should change based on assumptions!</p><p>Digging in, we realized we were essentially asking ‚ÄúWhat‚Äôs the probability of achieving the average return?‚Äù which is always ~50% for a symmetric distribution.</p><p>The correct question: ‚ÄúWhat‚Äôs the probability of achieving <em>at least</em> the minimum required return?‚Äù That requires integrating the probability distribution, which <code>normalCDF</code> does.</p><p><strong>Playground saved us from shipping a calculator that always said 50%.</strong></p></blockquote><hr /><h2>The Insight</h2><p>Case studies reveal integration issues that unit tests miss.</p><p><strong>Unit tests verify</strong>: ‚ÄúDoes <code>futureValue</code> calculate correctly?‚Äù<strong>Case studies verify</strong>: ‚ÄúDo <code>futureValue</code>, <code>payment</code>, and <code>normalCDF</code> work together to solve real problems?‚Äù</p><p>When we wrote Sarah‚Äôs retirement calculator, we discovered:</p><ul><li>The <code>payment</code> function‚Äôs <code>type</code> parameter matters in practice</li><li>Probability calculation requires distribution modeling, not point estimates</li><li>Scenario analysis is essential‚Äîusers want to explore trade-offs</li></ul><p>None of these issues appeared in unit tests. All appeared immediately in the case study.</p><blockquote><p><strong>Key Takeaway</strong>: Write case studies at topic milestones. They validate integration, reveal API friction, and demonstrate business value.</p></blockquote><hr /><h2>Try It Yourself</h2><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath
import Foundation

// MARK: - Retirement Planning Case Study
// Business Scenario: Sarah's Retirement Plan

print("=== RETIREMENT PLANNING CALCULATOR ===\n")

// Sarah's Current Situation
let currentAge = 35.0
let retirementAge = 65.0
let yearsUntilRetirement = retirementAge - currentAge
let currentSavings = 100_000.0
let targetAmount = 2_000_000.0

// Market Assumptions
let expectedReturn = 0.07	// 7% annual return (historical equity average)
let returnStdDev = 0.15		// 15% volatility (realistic for stock market)

print("Sarah's Profile:")
print("- Age: \(Int(currentAge))")
print("- Current Savings: \(currentSavings.currency())")
print("- Retirement Goal: \(targetAmount.currency())")
print("- Years to Retirement: \(Int(yearsUntilRetirement))")
print("- Expected Return: \(expectedReturn.percent())")
print("- Return Volatility: \(returnStdDev.percent())")
print()

// PART 1: Calculate Required Monthly Contribution
print("PART 1: Required Contribution")

let monthlyRate = expectedReturn / 12.0
let numberOfPayments: Int = Int(yearsUntilRetirement) * 12

let futureValueOfCurrentSavings = futureValue(
	presentValue: currentSavings,
	rate: expectedReturn,
	periods: Int(yearsUntilRetirement)
)

print("Future value of current \((currentSavings / 1000).currency(0))K: \(futureValueOfCurrentSavings.currency())")

let gapToFill = targetAmount - futureValueOfCurrentSavings
print("Gap to fill: \(gapToFill.currency())")

// Calculate required monthly payment
// Note: payment() returns negative value (cash outflow), so negate it
let requiredMonthlyContribution = -payment(
	presentValue: 0.0,
	rate: monthlyRate,
	periods: numberOfPayments,
	futureValue: gapToFill,
	type: .ordinary
)

print("Required monthly contribution: \(requiredMonthlyContribution.currency())")
print()

// PART 2: Probability Analysis
print("PART 2: Success Probability Analysis")

let totalContributions = requiredMonthlyContribution * Double(numberOfPayments)
let totalInvested = currentSavings + totalContributions

print("Total contributions: \(totalContributions.currency())")
print("Total invested: \(totalInvested.currency())")

// For $2M target, what total return is required?
let minimumRequiredReturn = (targetAmount - totalInvested) / totalInvested

print("Minimum required total return: \(minimumRequiredReturn.percent())")

// Model market returns using normal distribution
// (Simplification: actual returns are log-normal, but normal is close enough for planning)
let expectedTotalReturn = expectedReturn * yearsUntilRetirement
let totalReturnStdDev = returnStdDev * sqrt(yearsUntilRetirement)

// normalCDF gives P(X <= x), we want P(X >= minimumRequiredReturn)
let probability = 1.0 - normalCDF(
	x: minimumRequiredReturn,
	mean: expectedTotalReturn,
	stdDev: totalReturnStdDev
)

print("Probability of reaching \((targetAmount / 1000000).currency(0))M goal: \(probability.percent())")
print()

// PART 3: Scenario Analysis
print("PART 3: What-If Scenarios")

let scenarios = [
	("Conservative", 0.05, 0.10),  // Bonds, low risk
	("Moderate", 0.07, 0.15),      // Balanced, medium risk
	("Aggressive", 0.09, 0.20)     // Stocks, high risk
]

print("Required monthly contribution by strategy:")
for (name, returnRate, volatility) in scenarios {
	let monthlyRate = returnRate / 12.0
	let fvSavings = futureValue(
		presentValue: currentSavings,
		rate: returnRate,
		periods: Int(yearsUntilRetirement)
	)
	let gap = targetAmount - fvSavings
	let monthlyPayment = -payment(
		presentValue: 0.0,
		rate: monthlyRate,
		periods: numberOfPayments,
		futureValue: gap,
		type: .ordinary
	)

	print("  \(name): \(monthlyPayment.currency())/month (\(returnRate.percent()) return, \(volatility.percent()) volatility)")
}
print()

// PART 4: Key Insights
print("=== KEY INSIGHTS ===")
print("1. Current savings will grow to \(futureValueOfCurrentSavings.currency()) by retirement")
print("2. Need \(requiredMonthlyContribution.currency())/month with 7% expected returns")
print("3. Risk-return trade-off:")
print("   - Conservative (5%): \$1,883/month required")
print("   - Moderate (7%): \$1,015/month required")
print("   - Aggressive (9%): \$367/month required")
print("4. Higher expected returns = lower required contributions")
print("5. For accurate probability analysis, use Monte Carlo simulation (Week 6)")
print()

print("Try It: Adjust the parameters and re-run!")
</code></pre></details>
<h3>Modifications to Try</h3><ol><li><strong>Change Sarah‚Äôs age to 45</strong><ul><li>How does the required contribution change?</li><li>What happens to success probability?</li></ul></li><li><strong>Increase target to $3 million</strong><ul><li>Calculate new monthly contribution</li><li>How does probability change?</li></ul></li><li><strong>Add a $500/month current contribution</strong><ul><li>Modify the calculator to include ongoing contributions</li><li>How much does this reduce the required increase?</li></ul></li><li><strong>Model inflation</strong><ul><li>Adjust the target amount for 2% annual inflation</li><li>How does the ‚Äúreal‚Äù retirement goal change?</li></ul></li></ol><hr /><h2>Technical Deep Dives</h2><p>Want to understand the individual components better?</p><p><strong>DocC Tutorials Used</strong>:</p><ul><li><strong>Time Series</strong>: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/1.2-TimeSeries.md">BusinessMath Docs ‚Äì 1.2</a> - Period arithmetic and temporal data</li><li><strong>Time Value of Money</strong>: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/1.3-TimeValueOfMoney.md">BusinessMath Docs ‚Äì 1.3</a> - TVM functions (<code>futureValue</code>, <code>payment</code>)</li><li><strong>Statistical Distributions</strong>: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/2.3-RiskAnalyticsGuide.md">BusinessMath Docs ‚Äì 2.3</a> - <code>normalCDF</code> for probability</li></ul><p><strong>API References</strong>:</p><ul><li><code>futureValue(presentValue:rate:periods:)</code></li><li><code>payment(presentValue:futureValue:rate:periods:type:)</code></li><li><code>normalCDF(x:mean:standardDeviation:)</code></li></ul><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: Week 2 explores analysis tools‚Äîdata tables, financial ratios, and risk analytics.</p><p><strong>Related Case Studies</strong>:</p><ul><li><strong>Case Study #2: Capital Equipment Decision</strong> (Week 3) - Combines depreciation with TVM for capital budgeting</li><li><strong>Case Study #4: Portfolio Optimization</strong> (Week 8) - MIDPOINT integration showing all core topics working together</li></ul><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 1/12</li><li>Posts Published: 4/~48</li><li><strong>Case Studies: 1/6 Complete</strong> üéØ</li><li>Topics Combined: TVM + Time Series + Distributions</li><li>Playgrounds: 4 available (3 technical + 1 case study)</li></ul><hr />]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-01/03-wed-time-series</guid><title>Time Series Foundation</title><link>https://www.justinpurnell.com/BusinessMath/week-01/03-wed-time-series</link><description><![CDATA[Part 3 of 12-Week BusinessMath Series]]></description><pubDate>Wed, 07 Jan 2026 07:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[businessmath]]></category><category><![CDATA[swift]]></category><category><![CDATA[time-series]]></category><category><![CDATA[periods]]></category><category><![CDATA[temporal-data]]></category><content:encoded><![CDATA[<p><strong>Part 3 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>How periods provide type-safe temporal identifiers</li><li>Period arithmetic and subdivision operations</li><li>Creating and manipulating time series data</li><li>Real-world time series workflows</li></ul><hr /><h2>The Problem</h2><p>Business data is inherently temporal. Revenue happens in months, quarters, and years. Stock prices change daily. Forecasts project into future periods.</p><p>But handling temporal data correctly is tricky. What happens when you add a month to January 31st? How do you align quarterly data with monthly data? How do you ensure you‚Äôre not accidentally comparing January 2024 revenue with January 2025?</p><p>Arrays with dates are fragile‚Äîindex mistakes are silent, type mixing goes undetected, and time arithmetic is error-prone. Getting the data model right requires a thoughtful execution and a better abstraction.</p><hr /><h2>The Solution</h2><p>BusinessMath provides <strong>Periods</strong> and <strong>TimeSeries</strong> for type-safe temporal data:</p><h3>Periods: Type-Safe Time Identifiers</h3><pre><code class="language-swift">import Foundation
import BusinessMath

// Create periods at different granularities
let jan2025 = Period.month(year: 2025, month: 1)
let q1_2025 = Period.quarter(year: 2025, quarter: 1)
let fy2025 = Period.year(2025)
let today = Period.day(Date())

// Period arithmetic
let feb2025 = jan2025 + 1          // Next month
let dec2024 = jan2025 - 1          // Previous month
let yearRange = jan2025...jan2025 + 11  // 12 months

// Distance between periods
let months = try jan2025.distance(to: Period.month(year: 2025, month: 6))
print("Months: \(months)")  // Output: 5
</code></pre><h3>Period Properties and Formatting</h3><pre><code class="language-swift">let period = Period.month(year: 2025, month: 3)

// Get boundary dates
let start = period.startDate  // March 1, 2025 00:00:00
let end = period.endDate      // March 31, 2025 23:59:59

// Built-in label
let label = period.label      // "2025-03"

// Custom formatting
let formatter = DateFormatter()
formatter.dateFormat = "MMMM yyyy"
let formatted = period.formatted(using: formatter)
print(formatted)  // Output: "March 2025"
</code></pre><h3>Period Subdivision</h3><p>Larger periods subdivide into smaller ones:</p><pre><code class="language-swift">// Year to quarters
let year = Period.year(2025)
let quarters = year.quarters()
// Result: [Q1 2025, Q2 2025, Q3 2025, Q4 2025]

// Year to months
let months = year.months()
// Result: [Jan 2025, Feb 2025, ..., Dec 2025]

// Quarter to months
let q1 = Period.quarter(year: 2025, quarter: 1)
let q1Months = q1.months()
// Result: [Jan 2025, Feb 2025, Mar 2025]

// Month to days (leap year aware)
let feb2024 = Period.month(year: 2024, month: 2)
let days = feb2024.days()
// Result: [Feb 1, Feb 2, ..., Feb 29]  (2024 is a leap year)
</code></pre><h3>Creating Time Series</h3><p>Associate values with periods:</p><pre><code class="language-swift">// From parallel arrays
let periods = [
    Period.month(year: 2025, month: 1),
    Period.month(year: 2025, month: 2),
    Period.month(year: 2025, month: 3)
]
let revenue: [Double] = [100_000, 120_000, 115_000]

let ts = TimeSeries(periods: periods, values: revenue)

// From dictionary
let data: [Period: Double] = [
    Period.month(year: 2025, month: 1): 100_000,
    Period.month(year: 2025, month: 2): 120_000,
    Period.month(year: 2025, month: 3): 115_000
]
let ts2 = TimeSeries(data: data)
</code></pre><h3>Working with Time Series</h3><pre><code class="language-swift">// Access by period
if let janRevenue = ts[periods[0]] {
    print("January: $\(janRevenue.formatted(.number))")
}

// Iterate over period-value pairs
for (period, value) in zip(periods, ts) {
	print("\(period.label): \(ts[period]!.currency())")
}
// Output:
// 2025-01: $100,000
// 2025-02: $120,000
// 2025-03: $115,000

// Get all values as array
let values = ts.valuesArray  // [100000.0, 120000.0, 115000.0]

// Get all periods
let allPeriods = ts.periods  // [Jan 2025, Feb 2025, Mar 2025]
</code></pre><hr /><h2>How It Works</h2><h3>Type-First Period Ordering</h3><p>Periods use a clever ordering strategy:</p><pre><code class="language-swift">let daily = Period.day(Date())
let monthly = Period.month(year: 2025, month: 1)
let quarterly = Period.quarter(year: 2025, quarter: 1)
let annual = Period.year(2025)

// Type comes before chronology
daily < monthly      // true (day < month in hierarchy)
monthly < quarterly  // true (month < quarter in hierarchy)
quarterly < annual   // true (quarter < year in hierarchy)

// Within same type, chronological order
Period.month(year: 2025, month: 1) < Period.month(year: 2025, month: 2)  // true
</code></pre><p>This prevents accidental mixing of granularities while maintaining intuitive ordering.</p><h3>Period Arithmetic Safety</h3><p>Period arithmetic is safe and predictable:</p><pre><code class="language-swift">// Adding months handles year boundaries
let dec2024 = Period.month(year: 2024, month: 12)
let jan2025 = dec2024 + 1  // Automatically ‚Üí January 2025

// Adding months handles varying lengths correctly
let jan31 = Period.day(DateComponents(year: 2025, month: 1, day: 31)!)
// Can't add "month" to day period - compile error!
// Must work at month granularity:
let janMonth = Period.month(year: 2025, month: 1)
let febMonth = janMonth + 1  // ‚Üí February 2025
</code></pre><hr /><h2>Try It Yourself</h2><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath

// Create periods at different granularities
let jan2025 = Period.month(year: 2025, month: 1)
let q1_2025 = Period.quarter(year: 2025, quarter: 1)
let fy2025 = Period.year(2025)
let today = Period.day(Date())

// Period arithmetic
let feb2025 = jan2025 + 1          // Next month
let dec2024 = jan2025 - 1          // Previous month
let yearRange = jan2025...jan2025 + 11  // 12 months

// Distance between periods
//let months = try jan2025.distance(to: Period.month(year: 2025, month: 6))
//print("Months: \(months)")  // Output: 5

let period = Period.month(year: 2025, month: 3)

// Get boundary dates
let start = period.startDate  // March 1, 2025 00:00:00
let end = period.endDate      // March 31, 2025 23:59:59

// Built-in label
let label = period.label      // "2025-03"

// Custom formatting
let formatter = DateFormatter()
formatter.dateFormat = "MMMM yyyy"
let formatted = period.formatted(using: formatter)
print(formatted)  // Output: "March 2025"

	// Year to quarters
	let year = Period.year(2025)
	let quarters = year.quarters()
	// Result: [Q1 2025, Q2 2025, Q3 2025, Q4 2025]

	// Year to months
	let months = year.months()
	// Result: [Jan 2025, Feb 2025, ..., Dec 2025]

	// Quarter to months
	let q1 = Period.quarter(year: 2025, quarter: 1)
	let q1Months = q1.months()
	// Result: [Jan 2025, Feb 2025, Mar 2025]

	// Month to days (leap year aware)
	let feb2024 = Period.month(year: 2024, month: 2)
	let days = feb2024.days()
	// Result: [Feb 1, Feb 2, ..., Feb 29]  (2024 is a leap year)

	// From parallel arrays
	let periods = [
		Period.month(year: 2025, month: 1),
		Period.month(year: 2025, month: 2),
		Period.month(year: 2025, month: 3)
	]
	let revenue: [Double] = [100_000, 120_000, 115_000]

	let ts = TimeSeries(periods: periods, values: revenue)

	// From dictionary
	let data: [Period: Double] = [
		Period.month(year: 2025, month: 1): 100_000,
		Period.month(year: 2025, month: 2): 120_000,
		Period.month(year: 2025, month: 3): 115_000
	]
	let ts2 = TimeSeries(data: data)

	// Access by period
	if let janRevenue = ts[periods[0]] {
		print("January: $\(janRevenue.formatted(.number))")
	}


	// Iterate over period-value pairs
	for (period, value) in zip(periods, ts) {
		print("\(period.label): \(ts[period]!.currency())")
	}
	// Output:
	// 2025-01: $100,000
	// 2025-02: $120,000
	// 2025-03: $115,000

	// Get all values as array
	let values = ts.valuesArray  // [100000.0, 120000.0, 115000.0]

	// Get all periods
	let allPeriods = ts.periods  // [Jan 2025, Feb 2025, Mar 2025]

	// Monthly revenue data
	let monthlyRevenue = TimeSeries(
		periods: (1...12).map { Period.month(year: 2024, month: $0) },
		values: [100, 105, 110, 108, 115, 120, 118, 125, 130, 128, 135, 140]
	)

	// Group into quarters
	let q1Monthss = Period.quarter(year: 2024, quarter: 1).months()
	let q1Revenue = q1Monthss.compactMap { monthlyRevenue[$0] }.reduce(0, +)
	print("Q1 Revenue: \(q1Revenue.currency(0))")  // $315K

</code></pre></details>
<p>‚Üí Full API Reference: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/1.2-TimeSeries.md"><strong>BusinessMath Docs ‚Äì Time Series Analysis</strong></a></p><p><strong>Modifications to try</strong>:</p><ol><li>Create a time series for quarterly revenue and subdivide to monthly</li><li>Calculate the distance between two periods in different years</li><li>Build a time series from Q1 2024 to Q4 2025 (8 quarters)</li></ol><hr /><h2>Real-World Application</h2><p>Financial analysts work with time series constantly. Internal revenue data may come monthly, but executives want quarterly summaries. Historical analysis might span years, but forecasts may project only 3 or 6 months.</p><p>Period subdivision makes aggregation simple:</p><pre><code class="language-swift">// Monthly revenue data
let monthlyRevenue = TimeSeries(
    periods: (1...12).map { Period.month(year: 2024, month: $0) },
    values: [100, 105, 110, 108, 115, 120, 118, 125, 130, 128, 135, 140]
)

// Group into quarters
let q1Months = Period.quarter(year: 2024, quarter: 1).months()
let q1Revenue = q1Months.compactMap { monthlyRevenue[$0] }.reduce(0, +)
print("Q1 Revenue: \(q1Revenue.currency(0))")  // $315K
</code></pre><hr /><h3>üìù Development Note</h3><p>During development of the time series functionality, we discovered that multiple statistical formulas have different variants. For example, there are at least three common definitions of ‚Äúexponential moving average.‚Äù</p><p>Without explicit documentation of <em>which</em> variant we chose, tests would pass but results wouldn‚Äôt match external tools like Excel, which is the defacto standard for the financial community. This led to a practice: when implementing any algorithm with multiple valid interpretations, we document the exact formula in both the code and DocC.</p><p>‚ÄúAI will confidently implement <em>a</em> version of the algorithm. Your job is to ensure it‚Äôs the <em>right</em> version for your use case.‚Äù</p><p>The fix: Include the formula in the test itself:</p><pre><code class="language-swift">@Test("EMA uses alpha = 2/(window+1) formula")
func testEMAFormula() {
    let prices = [10.0, 11.0, 12.0, 11.5, 13.0]
    let ema = calculateEMA(values: prices, window: 3)

    // Explicitly verify formula: EMA(t) = Œ±√óP(t) + (1-Œ±)√óEMA(t-1)
    // where Œ± = 2 / (3 + 1) = 0.5
    let expected = 12.25  // Calculated manually with this formula
    #expect(abs(ema.last! - expected) < 0.01)
}
</code></pre><p>This test not only verifies correctness but documents which variant we‚Äôre using.</p><p><strong>Related Methodology</strong>: <a href="../../week-02/02-tue-documentation-as-design">Documentation as Design</a> (Week 2)</p><hr /><h2>Next Steps</h2><p><strong>Coming up next</strong>: Friday‚Äôs case study combines Time Series with Time Value of Money to build a retirement planning calculator.</p><p><strong>Case Study #1</strong>: <a href="../04-fri-case-retirement">Retirement Planning Calculator (Friday)</a> - See time series and TVM working together to answer real business questions.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 1/12</li><li>Posts Published: 3/~48</li><li>Case Studies: 0/6</li><li>Topics Covered: Getting Started, Test-First Development, Time Series</li><li>Playgrounds: 2 available</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://www.justinpurnell.com/BusinessMath/week-01/02-tue-test-first-development</guid><title>Test-First Development with AI</title><link>https://www.justinpurnell.com/BusinessMath/week-01/02-tue-test-first-development</link><description><![CDATA[Development Journey Series]]></description><pubDate>Tue, 06 Jan 2026 07:00:00 -0500</pubDate><dc:creator><![CDATA[Justin Purnell]]></dc:creator><category><![CDATA[ai-collaboration]]></category><category><![CDATA[tdd]]></category><category><![CDATA[testing]]></category><category><![CDATA[red-green-refactor]]></category><category><![CDATA[development journey]]></category><content:encoded><![CDATA[<p><strong>Development Journey Series</strong></p><hr /><h2>The Context</h2><p>When we began implementing BusinessMath‚Äôs TVM (Time Value of Money) functions, we faced a fundamental question: How do we ensure AI-generated code is correct?</p><p>When you set out to build a financial library, errors can cost real money. A bug in present value calculation could lead to bad retirement planning. An error in IRR could result in misallocated capital.</p><p>We needed a way to specify exactly what we wanted and verify that we got it.</p><hr /><h2>The Challenge</h2><p>We‚Äôre all coming around to the idea that AI is incredibly powerful at generating code, but we‚Äôve all also heard of it‚Äôs dangerous tendency to ‚Äúhallucinate.‚Äù Code can <em>look</em> reasonable but may be subtly wrong.</p><p><strong>The symptoms we encountered</strong>:</p><ul><li>AI might confidently implement simple interest when we needed compound interest</li><li>Generic type constraints would be almost correct but not quite right</li><li>Edge cases (zero rate, negative periods) would be silently mishandled</li></ul><p>A traditional approach‚Äîwrite code, then write tests‚Äîsimply doesn‚Äôt make sense for AI collaboration. If we did it that way, by the time we got around to writing tests, we‚Äôd already be invested in understanding and debugging the AI‚Äôs output. We needed a better way.</p><hr /><h2>The Solution</h2><p>Instead, we adopted a strict <strong>test-first development</strong> with a specific workflow designed for AI collaboration:</p><h3>The RED-GREEN-REFACTOR Cycle</h3><p><strong>1. RED - Write a Failing Test</strong></p><p>Before asking AI for any implementation, we wrote tests that specified exactly what wanted:</p><pre><code class="language-swift">@Test("Future value compounds correctly")
func testFutureValue() throws {
    let fv = calculateFutureValue(
        presentValue: 100.0,
        rate: 0.05,
        periods: 10.0
    )
    // Expected: 100 * (1.05)^10 = 162.89
    #expect(abs(fv - 162.89) < 0.01)
}
</code></pre><p>This test will fail‚Äîthe function doesn‚Äôt exist yet. <strong>That‚Äôs the point.</strong></p><p><strong>2. GREEN - AI Implements from Specification</strong></p><p>Now you give AI a clear specification:</p><blockquote><p>‚ÄúImplement <code>calculateFutureValue</code> that makes this test pass. Use compound interest formula: FV = PV √ó (1 + r)^n. Make it generic over types conforming to <code>Real</code> protocol from swift-numerics.‚Äù</p></blockquote><p>AI generates:</p><pre><code class="language-swift">public func calculateFutureValue<T: Real>(
    presentValue: T,
    rate: T,
    periods: T
) -> T {
    return presentValue * T.pow((1 + rate), periods)
}
</code></pre><p>Run the test. <strong>It passes.</strong> Green!</p><p><strong>3. REFACTOR - Improve with Safety Net</strong></p><p>Now that tests pass, you can refactor fearlessly:</p><pre><code class="language-swift">// Extract reusable compound interest calculation
private func compoundFactor<T: Real>(rate: T, periods: T) -> T {
    return T.pow((1 + rate), periods)
}

public func calculateFutureValue<T: Real>(
    presentValue: T,
    rate: T,
    periods: T
) -> T {
    return presentValue * compoundFactor(rate: rate, periods: periods)
}
</code></pre><p>Tests still pass. Refactor succeeded.</p><hr /><h2>The Results</h2><p>After implementing BusinessMath using strict test-first development:</p><p><strong>Metrics that improved</strong>:</p><ul><li><strong>0 regression bugs</strong> across 247 tests after major refactorings</li><li><strong>180+ bugs caught</strong> before they reached ‚Äúimplementation‚Äù status</li><li><strong>3 API redesigns</strong> caught during test writing (before any code existed)</li></ul><p><strong>Time investment</strong>:</p><ul><li>Initial setup: ~2 hours (learning Swift Testing framework)</li><li>Per-function overhead: ~5-10 minutes (writing tests first)</li><li>ROI: <strong>Massive</strong>‚Äîdebugging time dropped from hours to minutes</li></ul><hr /><h2>What Worked</h2><p><strong>1. Failing Tests as Specifications</strong></p><p>AI works best when given concrete, executable specifications. A failing test is the clearest possible spec.</p><p><strong>Example</strong>: We wanted NPV calculation. Instead of saying ‚Äúimplement net present value,‚Äù we wrote:</p><pre><code class="language-swift">@Test("NPV calculation matches known value")
func testNPV() throws {
    let cashFlows = [-100.0, 50.0, 50.0, 50.0]
    let npv = calculateNPV(rate: 0.10, cashFlows: cashFlows)
    // Manual calculation: -100 + 50/1.1 + 50/1.1^2 + 50/1.1^3 = 24.34
    #expect(abs(npv - 24.34) < 0.01)
}
</code></pre><p>AI immediately understood: discount each cash flow, sum them. Perfect implementation on first try.</p><p><strong>2. Tests Caught AI Errors Immediately</strong></p><p>First AI attempt at <code>calculateFutureValue</code> used <strong>simple interest</strong>: <code>FV = PV * (1 + rate * periods)</code>.</p><p>Test failed. We saw the error instantly. Corrected the prompt. Next attempt used compound interest correctly.</p><p><strong>Total debugging time</strong>: 30 seconds.</p><p><strong>3. Generic Implementations Validated</strong></p><p>We used the Swift Numerics as our only real dependency, but it allowed us to work generically over and ‚ÄúReal‚Äù number. Writing tests for multiple types ensured generics worked:</p><pre><code class="language-swift">@Test("Future value works with Double")
func testFVDouble() {
    let fv: Double = calculateFutureValue(presentValue: 100.0, rate: 0.05, periods: 10.0)
    #expect(abs(fv - 162.89) < 0.01)
}

@Test("Future value works with Float")
func testFVFloat() {
    let fv: Float = calculateFutureValue(presentValue: 100.0, rate: 0.05, periods: 10.0)
    #expect(abs(fv - 162.89) < 0.1)  // Looser tolerance for Float
}
</code></pre><p>Both passed. Generic implementation validated.</p><hr /><h2>What Didn‚Äôt Work</h2><p><strong>1. Vague Tests</strong></p><p>A test has to be specific to be useful. A test-driven approach therefore works best when you have domain expertise and can give concrete guidance:</p><pre><code class="language-swift">@Test("Present value works")
func testPV() {
    let pv = presentValue(futureValue: 1000.0, rate: 0.05, periods: 10.0)
    #expect(pv > 0)  // Too vague!
}
</code></pre><p>AI would generate code here that passes, but wouldn‚Äôt necessarily be write. Just specifying that the value be positive won‚Äôt ensure that it is the <em>correct</em> value.</p><p><strong>Fix</strong>: Always test against known, calculated values.</p><p><strong>2. Missing Edge Cases</strong></p><p>Just getting the right value is great, but you also have to think through and test against edge cases:</p><ul><li>What if rate is zero?</li><li>What if periods is negative?</li><li>What if present value is negative?</li></ul><p>AI would happily implement code that crashed or returned nonsense for these inputs.</p><p><strong>Fix</strong>: Enumerate edge cases explicitly. Write tests for them all.</p><pre><code class="language-swift">@Test("Future value with zero rate")
func testFVZeroRate() {
    let fv = calculateFutureValue(presentValue: 100.0, rate: 0.0, periods: 10.0)
    #expect(fv == 100.0)  // No growth
}

@Test("Future value with negative periods throws")
func testFVNegativePeriods() {
    #expect(throws: FinancialError.self) {
        try calculateFutureValue(presentValue: 100.0, rate: 0.05, periods: -5.0)
    }
}
</code></pre><hr /><h2>Key Takeaway</h2><p>We‚Äôre not in a place to just trust AI to do what you‚Äôre thinking. But by specifying test-first development, you can use AI not as a code generator, but instead into a <strong>specification executor</strong>.</p><p><strong>Without tests first</strong>: ‚ÄúImplement present value calculation‚Äù ‚Üí AI guesses what you mean ‚Üí You debug AI‚Äôs interpretation</p><p><strong>With tests first</strong>: <em>Failing test shows exactly what you want</em> ‚Üí AI implements to spec ‚Üí Tests verify correctness</p><blockquote><p><strong>Key Takeaway</strong>: AI works best when given failing tests as specifications. Vague requests produce vague code. Concrete, executable specs produce correct code.</p></blockquote><hr /><h2>How to Apply This</h2><p><strong>For your next project</strong>:</p><p><strong>1. Write the Test First (RED)</strong></p><ul><li>Before asking AI for implementation, write the failing test</li><li>Include expected values calculated manually or from reference</li><li>Cover edge cases explicitly</li></ul><p><strong>2. Give AI the Test as Specification (GREEN)</strong></p><ul><li>Paste the test into your AI prompt</li><li>Say: ‚ÄúImplement this function to make the test pass‚Äù</li><li>Run the test to verify</li></ul><p><strong>3. Refactor with Confidence (REFACTOR)</strong></p><ul><li>Extract patterns, improve names, optimize</li><li>Tests protect against regressions</li><li>If tests still pass, refactor succeeded</li></ul><p><strong>Starting template</strong>:</p><pre><code># For each new function:

1. Write failing test with expected value
2. Prompt AI: "Implement [function name] to make this test pass: [paste test]"
3. Run test, verify it passes
4. Add edge case tests
5. Refactor if needed
</code></pre><hr /><h2>See It In Action</h2><p>This practice is demonstrated in the following technical posts:</p><p><strong>Technical Examples</strong>:</p><ul><li><a href="../01-mon-getting-started"><strong>Getting Started</strong> (Monday)</a>: Shows <code>presentValue</code> implemented test-first</li><li><strong>Time Series Foundation</strong> (Wednesday): Period arithmetic validated with tests</li><li><strong>Time Value of Money</strong> (Week 1 Friday case study): Multiple TVM functions integrated</li></ul><p><strong>Related Practices</strong>:</p><ul><li><strong>Documentation as Design</strong> (Week 2): Write docs before implementation</li><li><strong>Coding Standards</strong> (Week 5): Forbidden patterns caught by tests</li></ul><hr /><h2>Common Pitfalls</h2><h3>‚ùå Pitfall 1: Writing tests after implementation</h3><p><strong>Problem</strong>: You‚Äôve already invested in understanding AI‚Äôs code. Tests feel like busy work.<strong>Solution</strong>: Discipline. Tests first, always. No exceptions.</p><h3>‚ùå Pitfall 2: Tests that just check ‚Äúdoesn‚Äôt crash‚Äù</h3><p><strong>Problem</strong>: <code>#expect(result != nil)</code> passes for wrong implementations.<strong>Solution</strong>: Test against known, correct values. Do the math yourself first.</p><h3>‚ùå Pitfall 3: Skipping edge cases</h3><p><strong>Problem</strong>: AI handles normal cases fine, but crashes on zero/negative/nil.<strong>Solution</strong>: Explicitly enumerate edge cases. Write tests for all of them.</p><hr /><h2>Further Reading</h2><p><strong>Technical foundation</strong>:</p><ul><li>Swift Testing framework documentation</li><li><code>#expect</code> vs <code>XCTAssert</code> differences</li></ul><p><strong>Tools mentioned</strong>:</p><ul><li><a href="https://developer.apple.com/xcode/swift-testing/">Swift Testing</a>: Modern testing framework for Swift</li><li><a href="https://www.swift.org/blog/numerics/">Swift Numerics</a>: Generic numeric protocols (<code>Real</code>, <code>ElementaryFunctions</code>)</li></ul><hr /><h2>Discussion</h2><p><strong>Questions to consider</strong>:</p><ol><li>How does test-first development change when AI is writing the implementation?</li><li>What level of test coverage is ‚Äúenough‚Äù for financial calculations?</li><li>How do you balance test-first discipline with exploration/prototyping?</li></ol><p><strong>Share your experience</strong>: Have you tried test-first development with AI? What worked? What didn‚Äôt?</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 1/12</li><li>Posts Published: 2/~48</li><li>Methodology Posts: 1/12</li><li>Practices Covered: Test-First Development</li></ul>]]></content:encoded></item></channel></rss>