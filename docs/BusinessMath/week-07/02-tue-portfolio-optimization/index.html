<!doctype html><html lang="en" data-bs-theme="light"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Part 23 of 12-Week BusinessMath Series"><meta name="author" content="Justin Purnell"><meta name="generator" content="Ignite v0.2.1"><title>Portfolio Optimization: Building Optimal Investment Portfolios</title><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/prism-default-dark.css" rel="stylesheet"><link href="/css/bootstrap-icons.min.css" rel="stylesheet"><link href="https://www.justinpurnell.com/BusinessMath/week-07/02-tue-portfolio-optimization" rel="canonical"><link href="/feed.rss" rel="alternate" type="application/rss+xml" title="Justin Purnell"><meta property="og:site_name" content="Justin Purnell"><meta property="og:title" content="Portfolio Optimization: Building Optimal Investment Portfolios"><meta property="twitter:title" content="Portfolio Optimization: Building Optimal Investment Portfolios"><meta property="og:description" content="Portfolio Optimization: Building Optimal Investment Portfolios"><meta name="twitter:description" content="Portfolio Optimization: Building Optimal Investment Portfolios"><meta property="og:url" content="https://www.justinpurnell.com/BusinessMath/week-07/02-tue-portfolio-optimization"><meta name="twitter:domain" content="justinpurnell.com"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:dnt" content="on"><meta name="description" content="**Entrepreneurial Strategist & Builder:** Justin Purnell is the Founder of **Ledge Partners**, dedicated to acquiring and leading profitable businesses. His foundation is built on seven years at **Goldman Sachs** as a high yield credit analyst, where he published over **400 research reports** and advised C-level executives.
**Product Innovation and Scale:** He led the complete **re-platforming of technology supporting over 70 e-commerce sites** globally as Head of Product at **Hotels at Home**. He actively builds technical solutions, including pioneering **AI-powered software** to automate product data generation and designing a Swift middleware prototype that cut vendor onboarding time from **four months to two weeks**.
**Driving Financial and Organizational Results:** At **NBCUniversal's Seeso**, he directed product operations and retention initiatives that resulted in a **40% increase in customer Lifetime Value**. He is adept at mobilizing cross-functional teams, having successfully stepped in to **referee a dispute** between NBC and a third-party vendor to foster consensus and launch the Content Commerce platform.
**Creative and Governance Leadership:** Justin combines corporate rigor with creative experience, having directed the Webby-awarded web series **Smart Girls at the Party** and serving as a founding producer for **UCBcomedy.com**. He maintains significant governance roles, including serving as **President of the Princeton University Class of 2000** (1,143 alumni) and managing its annual giving campaigns."><meta name="fediverse:creator" content="@jpurnell@mastodon.social"><meta name="tags" content="Product Manager, Strategy, Product Leader, Goldman Sachs, NBCUniversal, Hotels at Home, AI, LLM, Digital Transformation, e-commerce, Swift, Consensus Leadership, Leadership, Agile, DevOps, Continuous Integration, Continuous Deployment, Cloud, Data Science, Machine Learning, Python, JavaScript, Front-end, Back-end, Full-stack, Responsive Design, Accessibility, SEO, Content Strategy, User Experience, User Interface, Design, Agile, Product Strategy, Technical Strategy"><script>	(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
	new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
	j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
	'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
	})(window,document,'script','dataLayer','GTM-K3TZS8J');</script><link href="/css/main.css" rel="stylesheet"></head><body><div class="col-sm-10 mx-auto"><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K3TZS8J"
	height="0" width="0" style="display:none;visibility:hidden"></iframe>
<header><nav class="noPrint navbar navbar-expand-md" style="border-bottom: 0.01em solid #d5d5d5;"><div class="container-fluid col"><button type="button" class="navbar-toggler btn" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div id="navbarCollapse" class="collapse navbar-collapse"><ul class="navbar-nav mb-2 mb-md-0 col"><li class="nav-item"><a href="/" class="nav-link">Home</a></li><li class="nav-item"><a href="/about" class="nav-link">About</a></li><li class="nav-item"><a href="/cv" class="nav-link">CV</a></li><li class="nav-item"><a href="/business-math" class="nav-link">BusinessMath</a></li><li class="nav-item"><a href="/next" class="nav-link">NeXT</a></li></ul></div></div></nav></header><div class="row"><div class="col"><h1 class="mainTitle">"Portfolio Optimization: Building Optimal Investment Portfolios"</h1><div style="margin-bottom: 2em"><p class="blogDateTime" style="margin-left: 1em">BusinessMath Quarterly Series</p><p class="blogDateTime" style="margin-left: 1em">12 min read</p></div><p class="mx-auto blurb" style="width: 70%; max-width: 800px"><p><strong>Part 23 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>Building maximum Sharpe ratio portfolios (best risk-adjusted return)</li><li>Finding minimum variance portfolios (lowest risk)</li><li>Generating efficient frontiers (all optimal portfolios)</li><li>Implementing risk parity strategies (equal risk contribution)</li><li>Applying real-world constraints (long-only, leverage limits, position sizing)</li><li>Understanding the math behind Modern Portfolio Theory</li></ul><hr /><h2>The Problem</h2><p>Investment portfolio construction requires balancing multiple competing objectives:</p><ul><li><strong>Risk vs. Return</strong>: Higher returns usually mean higher risk, but by how much?</li><li><strong>Diversification</strong>: How do you optimally combine assets that move differently?</li><li><strong>Constraints</strong>: No short-selling, position limits, target returns, leverage restrictions</li><li><strong>Multiple Solutions</strong>: There are infinite ways to allocate capital‚Äîwhich is optimal?</li></ul><p><strong>Manual portfolio construction (guessing weights in a spreadsheet) doesn‚Äôt find mathematically optimal solutions.</strong></p><hr /><h2>The Solution</h2><p>Modern Portfolio Theory (MPT), developed by Harry Markowitz, provides a mathematical framework for optimal portfolio construction. BusinessMath implements MPT as part of Phase 3 multivariate optimization.</p><h3>Maximum Sharpe Ratio Portfolio</h3><p>Find the portfolio with the best risk-adjusted return:</p><pre><code class="language-swift">import BusinessMath

// 4 assets: stocks (small, large), bonds, real estate
let optimizer = PortfolioOptimizer()

let expectedReturns = VectorN([0.12, 0.15, 0.18, 0.05])

// Construct covariance from correlation matrix to ensure validity
// High correlation between Asset 1 (12% return) and Asset 3 (18% return)
// makes Asset 1 a candidate for shorting in 130/30 strategy
let volatilities = [0.20, 0.30, 0.40, 0.10]  // 20%, 30%, 40%, 10%
let correlations = [
	[1.00, 0.30, 0.70, 0.10],  // Asset 1: high corr with Asset 3
	[0.30, 1.00, 0.50, 0.15],  // Asset 2: moderate corr with Asset 3
	[0.70, 0.50, 1.00, 0.05],  // Asset 3: highest return
	[0.10, 0.15, 0.05, 1.00]   // Asset 4: bonds (low correlation)
]

// Convert correlation to covariance: cov[i][j] = corr[i][j] * vol[i] * vol[j]
var covariance = [[Double]](repeating: [Double](repeating: 0, count: 4), count: 4)
for i in 0..<4 {
	for j in 0..<4 {
		covariance[i][j] = correlations[i][j] * volatilities[i] * volatilities[j]
	}
}

// Maximum Sharpe ratio (optimal risk-adjusted return)
let maxSharpe = try optimizer.maximumSharpePortfolio(
	expectedReturns: expectedReturns,
	covariance: covariance,
	riskFreeRate: 0.02,
	constraintSet: .longOnly
)

print("Maximum Sharpe Portfolio:")
print("  Sharpe Ratio: \(maxSharpe.sharpeRatio.number(2))")
print("  Expected Return: \(maxSharpe.expectedReturn.percent(1))")
print("  Volatility: \(maxSharpe.volatility.percent(1))")
print("  Weights: \(maxSharpe.weights.toArray().map { $0.percent(1) })")
</code></pre><p><strong>Output:</strong></p><pre><code>Maximum Sharpe Portfolio:
  Sharpe Ratio: 0.62
  Expected Return: 9.6%
  Volatility: 12.2%
  Weights: ["38.6%", "18.5%", "0.0%", "42.9%"]
</code></pre><p><strong>The result</strong>: Despite bonds having the lowest return (5%), they get the highest allocation (43%) because they reduce portfolio risk while maintaining strong Sharpe ratio.</p><hr /><h3>Minimum Variance Portfolio</h3><p>Find the portfolio with the lowest possible risk:</p><pre><code class="language-swift">let minVar = try optimizer.minimumVariancePortfolio(
	expectedReturns: expectedReturns,
	covariance: covariance,
	allowShortSelling: false
)

print("Minimum Variance Portfolio:")
print("  Expected Return: \(minVar.expectedReturn.percent(1))")
print("  Volatility: \(minVar.volatility.percent(1))")
print("  Weights: \(minVar.weights.toArray().map { $0.percent(1) })")
</code></pre><p><strong>Output:</strong></p><pre><code>Minimum Variance Portfolio:
  Expected Return: 6.4%
  Volatility: 9.3%
  Weights: ["16.4%", "2.2%", "0.0%", "81.4%"]
</code></pre><p><strong>The trade-off</strong>: Lowest risk (9.3% volatility) but also lowest return (6.4%). The optimizer heavily weights bonds and eliminates the high-volatility asset entirely.</p><hr /><h3>Efficient Frontier</h3><p>The efficient frontier shows all optimal portfolios‚Äîthose with maximum return for each level of risk:</p><pre><code class="language-swift">// Generate 20 points along the efficient frontier
let frontier = try optimizer.efficientFrontier(
	expectedReturns: expectedReturns,
	covariance: covariance,
	riskFreeRate: 0.02,
	numberOfPoints: 20
)

print("Efficient Frontier:")
print("Volatility | Return   | Sharpe")
print("-----------|----------|-------")

for portfolio in frontier.portfolios {
	print("\(portfolio.volatility.percent(1).paddingLeft(toLength: 10)) | " +
		  "\(portfolio.expectedReturn.percent(2).paddingLeft(toLength: 8)) | " +
		  "\(portfolio.sharpeRatio.number(2))")
}

// Find portfolio closest to 12% target return
let targetReturn = 0.12
let targetPortfolio = frontier.portfolios.min(by: { p1, p2 in
	abs(p1.expectedReturn - targetReturn) < abs(p2.expectedReturn - targetReturn)
})!

print("\nTarget \(targetReturn.percent(0)) Return Portfolio:")
print("  Volatility: \(targetPortfolio.volatility.percent(1))")
print("  Weights: \(targetPortfolio.weights.toArray().map { $0.percent(1) })")
</code></pre><p><strong>Output:</strong></p><pre><code>Efficient Frontier:
Volatility | Return   | Sharpe
-----------|----------|-------
      9.7% |    5.00% | 0.31
      9.3% |    5.68% | 0.40
      9.2% |    6.37% | 0.48
      9.3% |    7.05% | 0.54
      9.8% |    7.74% | 0.59
     10.5% |    8.42% | 0.61
     11.5% |    9.11% | 0.62
     12.5% |    9.79% | 0.62
     13.8% |   10.47% | 0.62
     15.1% |   11.16% | 0.61
     16.4% |   11.84% | 0.60
     17.9% |   12.53% | 0.59
     19.3% |   13.21% | 0.58
     20.9% |   13.89% | 0.57
     22.4% |   14.58% | 0.56
     23.9% |   15.26% | 0.55
     25.5% |   15.95% | 0.55
     27.1% |   16.63% | 0.54
     28.7% |   17.32% | 0.53
     30.3% |   18.00% | 0.53

Target 12% Return Portfolio:
  Volatility: 16.4%
  Weights: ["56.7%", "31.0%", "-1.7%", "14.1%"]
</code></pre><p><strong>The insight</strong>: The efficient frontier curves‚Äîthere‚Äôs no linear relationship between risk and return. The maximum Sharpe portfolio is where the line from the risk-free rate is tangent to the frontier.</p><hr /><h3>Risk Parity</h3><p>Risk parity allocates capital so each asset contributes equally to total portfolio risk:</p><pre><code class="language-swift">// Each asset contributes equally to total risk
let riskParity = try optimizer.riskParityPortfolio(
	expectedReturns: expectedReturns,
	covariance: covariance,
	constraintSet: .longOnly
)

print("Risk Parity Portfolio:")
for (i, weight) in riskParity.weights.toArray().enumerated() {
	print("  Asset \(i + 1): \(weight.percent(1))")
}
print("Expected Return: \(riskParity.expectedReturn.percent(1))")
print("Volatility: \(riskParity.volatility.percent(1))")
print("Sharpe Ratio: \(riskParity.sharpeRatio.number(2))")
</code></pre><p><strong>Output:</strong></p><pre><code>Risk Parity Portfolio:
  Asset 1: 20.9%
  Asset 2: 14.6%
  Asset 3: 9.9%
  Asset 4: 54.7%
Expected Return: 9.2%
Volatility: 12.1%
Sharpe Ratio: 0.76
</code></pre><p><strong>The philosophy</strong>: Risk parity doesn‚Äôt maximize Sharpe ratio‚Äîit equalizes risk contribution. Use it when you‚Äôre skeptical of return forecasts but confident in risk estimates.</p><hr /><h3>Constrained Portfolios</h3><p>Real-world portfolios have constraints beyond full investment:</p><pre><code class="language-swift">// Long-Short with leverage limit (130/30 strategy)
let longShort = try optimizer.maximumSharpePortfolio(
	expectedReturns: expectedReturns,
	covariance: covariance,
	riskFreeRate: 0.02,
	constraintSet: .longShort(maxLeverage: 1.3)
)

print("130/30 Portfolio:")
print("  Sharpe: \(longShort.sharpeRatio.number(2))")
print("  Weights: \(longShort.weights.toArray().map { $0.percent(1) })")

// Box constraints (min/max per position)
let boxConstrained = try optimizer.maximumSharpePortfolio(
	expectedReturns: expectedReturns,
	covariance: covariance,
	riskFreeRate: 0.02,
	constraintSet: .boxConstrained(min: 0.05, max: 0.40)
)

print("Box Constrained Portfolio (5%-40% per position):")
print("  Sharpe: \(boxConstrained.sharpeRatio.number(2))")
print("  Weights: \(boxConstrained.weights.toArray().map { $0.percent(1) })")
</code></pre><p><strong>Output:</strong></p><pre><code>130/30 Portfolio:
  Sharpe: 0.62
  Weights: ["42.0%", "19.7%", "-3.2%", "41.5%"]

Box Constrained Portfolio (5%-40% per position):
  Sharpe: 0.61
  Weights: ["36.5%", "18.5%", "5.0%", "40.0%"]
</code></pre><p><strong>The trade-off</strong>: Constraints reduce the Sharpe ratio (1.18 vs. 1.35 unconstrained) but reflect real-world restrictions.</p><hr /><h2>Real-World Example: $1M Multi-Asset Portfolio</h2><pre><code class="language-swift">let assets_rwe = ["US Large Cap", "US Small Cap", "International", "Bonds", "Real Estate"]
let expectedReturns_rwe = VectorN([0.10, 0.12, 0.11, 0.0375, 0.09])

// More realistic covariance structure (constructed from correlations)
let volatilities_rwe = [0.15, 0.18, 0.165, 0.075, 0.14]  // 15%, 18%, 17%, 7%, 14%
let correlations_rwe = [
	[1.00, 0.75, 0.65, 0.25, 0.50],  // US Large Cap
	[0.75, 1.00, 0.70, 0.10, 0.55],  // US Small Cap (high corr with US stocks)
	[0.65, 0.70, 1.00, 0.20, 0.45],  // International (corr with other stocks)
	[0.25, 0.10, 0.20, 1.00, 0.15],  // Bonds (moderate diversifier)
	[0.50, 0.55, 0.45, 0.15, 1.00]   // Real Estate (hybrid characteristics)
]

// Convert to covariance matrix
var covariance_rwe = [[Double]](repeating: [Double](repeating: 0, count: 5), count: 5)
for i in 0..<5 {
	for j in 0..<5 {
		covariance_rwe[i][j] = correlations_rwe[i][j] * volatilities_rwe[i] * volatilities_rwe[j]
	}
}

let optimizer_rwe = PortfolioOptimizer()

// Conservative investor
let conservative_rwe = try optimizer_rwe.minimumVariancePortfolio(
	expectedReturns: expectedReturns_rwe,
	covariance: covariance_rwe,
	allowShortSelling: false
)

print("Conservative Portfolio ($1M):")
for (i, asset) in assets_rwe.enumerated() {
	let weight = conservative_rwe.weights.toArray()[i]
	if weight > 0.01 {
		let allocation = 1_000_000 * weight
		print("  \(asset): \(allocation.currency(0)) (\(weight.percent(1)))")
	}
}
print("Expected Return: \(conservative_rwe.expectedReturn.percent(1))")
print("Volatility: \(conservative_rwe.volatility.percent(1))")
</code></pre><p><strong>Output:</strong></p><pre><code>Conservative Portfolio ($1M):
  US Small Cap: $44,228 (4.4%)
  International: $16,441 (1.6%)
  Bonds: $797,952 (79.8%)
  Real Estate: $141,379 (14.1%)
Expected Return: 5.0%
Volatility: 6.9%
</code></pre><hr /><h2>Try It Yourself</h2><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath

//do {
// 4 assets: stocks (small, large), bonds, real estate
let optimizer = PortfolioOptimizer()

let expectedReturns = VectorN([0.12, 0.15, 0.18, 0.05])

// Construct covariance from correlation matrix to ensure validity
// High correlation between Asset 1 (12% return) and Asset 3 (18% return)
// makes Asset 1 a candidate for shorting in 130/30 strategy
let volatilities = [0.20, 0.30, 0.40, 0.10]  // 20%, 30%, 40%, 10%
let correlations = [
	[1.00, 0.30, 0.70, 0.10],  // Asset 1: high corr with Asset 3
	[0.30, 1.00, 0.50, 0.15],  // Asset 2: moderate corr with Asset 3
	[0.70, 0.50, 1.00, 0.05],  // Asset 3: highest return
	[0.10, 0.15, 0.05, 1.00]   // Asset 4: bonds (low correlation)
]

// Convert correlation to covariance: cov[i][j] = corr[i][j] * vol[i] * vol[j]
var covariance = [[Double]](repeating: [Double](repeating: 0, count: 4), count: 4)
for i in 0..<4 {
	for j in 0..<4 {
		covariance[i][j] = correlations[i][j] * volatilities[i] * volatilities[j]
	}
}

// MARK: - Maximum Sharpe Portfolio

print("Running Maximum Sharpe Portfolio...")
let maxSharpe = try optimizer.maximumSharpePortfolio(
	expectedReturns: expectedReturns,
	covariance: covariance,
	riskFreeRate: 0.02,
	constraintSet: .longOnly
)

print("Maximum Sharpe Portfolio:")
print("  Sharpe Ratio: \(maxSharpe.sharpeRatio.number(2))")
print("  Expected Return: \(maxSharpe.expectedReturn.percent(1))")
print("  Volatility: \(maxSharpe.volatility.percent(1))")
print("  Weights: \(maxSharpe.weights.toArray().map { $0.percent(1) })")
print()

// MARK: - Minimum Variance Portfolio

print("Running Minimum Variance Portfolio...")
let minVar = try optimizer.minimumVariancePortfolio(
	expectedReturns: expectedReturns,
	covariance: covariance,
	allowShortSelling: false
)

print("Minimum Variance Portfolio:")
print("  Expected Return: \(minVar.expectedReturn.percent(1))")
print("  Volatility: \(minVar.volatility.percent(1))")
print("  Weights: \(minVar.weights.toArray().map { $0.percent(1) })")
print()

// MARK: - Efficient Frontier

print("Running Efficient Frontier...")
let frontier = try optimizer.efficientFrontier(
	expectedReturns: expectedReturns,
	covariance: covariance,
	riskFreeRate: 0.02,
	numberOfPoints: 20
)

print("Efficient Frontier:")
print("Volatility | Return   | Sharpe")
print("-----------|----------|-------")

for portfolio in frontier.portfolios {
	print("\(portfolio.volatility.percent(1).paddingLeft(toLength: 10)) | " +
		  "\(portfolio.expectedReturn.percent(2).paddingLeft(toLength: 8)) | " +
		  "\(portfolio.sharpeRatio.number(2))")
}

// Find portfolio closest to 12% target return
let targetReturn = 0.12
let targetPortfolio = frontier.portfolios.min(by: { p1, p2 in
	abs(p1.expectedReturn - targetReturn) < abs(p2.expectedReturn - targetReturn)
})!

print("\nTarget \(targetReturn.percent(0)) Return Portfolio:")
print("  Volatility: \(targetPortfolio.volatility.percent(1))")
print("  Weights: \(targetPortfolio.weights.toArray().map { $0.percent(1) })")
print()

// MARK: - Risk Parity

print("Running Risk Parity Portfolio...")
let riskParity = try optimizer.riskParityPortfolio(
	expectedReturns: expectedReturns,
	covariance: covariance,
	constraintSet: .longOnly
)

print("Risk Parity Portfolio:")
for (i, weight) in riskParity.weights.toArray().enumerated() {
	print("  Asset \(i + 1): \(weight.percent(1))")
}
print("Expected Return: \(riskParity.expectedReturn.percent(1))")
print("Volatility: \(riskParity.volatility.percent(1))")
print("Sharpe Ratio: \(riskParity.sharpeRatio.number(2))")
print()

// MARK: - Constrained Portfolios

print("Running 130/30 Portfolio...")
let longShort = try optimizer.maximumSharpePortfolio(
	expectedReturns: expectedReturns,
	covariance: covariance,
	riskFreeRate: 0.02,
	constraintSet: .longShort(maxLeverage: 1.3)
)

print("130/30 Portfolio:")
print("  Sharpe: \(longShort.sharpeRatio.number(2))")
print("  Weights: \(longShort.weights.toArray().map { $0.percent(1) })")
print()

print("Running Box Constrained Portfolio...")
let boxConstrained = try optimizer.maximumSharpePortfolio(
	expectedReturns: expectedReturns,
	covariance: covariance,
	riskFreeRate: 0.02,
	constraintSet: .boxConstrained(min: 0.05, max: 0.40)
)

print("Box Constrained Portfolio (5%-40% per position):")
print("  Sharpe: \(boxConstrained.sharpeRatio.number(2))")
print("  Weights: \(boxConstrained.weights.toArray().map { $0.percent(1) })")
//
//} catch {
//	print("‚ùå Portfolio optimization failed: \(error)")
//	print("   Error type: \(type(of: error))")
//	if let localizedError = error as? BusinessMathError {
//		print("   Description: \(localizedError.errorDescription ?? "No description")")
//	}
//}
//

// MARK: - Real-World Example: $1mm Asset Portfolio

let assets_rwe = ["US Large Cap", "US Small Cap", "International", "Bonds", "Real Estate"]
let expectedReturns_rwe = VectorN([0.10, 0.12, 0.11, 0.0375, 0.09])

// More realistic covariance structure (constructed from correlations)
let volatilities_rwe = [0.15, 0.18, 0.165, 0.075, 0.14]  // 15%, 18%, 17%, 7%, 14%
let correlations_rwe = [
	[1.00, 0.75, 0.65, 0.25, 0.50],  // US Large Cap
	[0.75, 1.00, 0.70, 0.10, 0.55],  // US Small Cap (high corr with US stocks)
	[0.65, 0.70, 1.00, 0.20, 0.45],  // International (corr with other stocks)
	[0.25, 0.10, 0.20, 1.00, 0.15],  // Bonds (moderate diversifier)
	[0.50, 0.55, 0.45, 0.15, 1.00]   // Real Estate (hybrid characteristics)
]

// Convert to covariance matrix
var covariance_rwe = [[Double]](repeating: [Double](repeating: 0, count: 5), count: 5)
for i in 0..<5 {
	for j in 0..<5 {
		covariance_rwe[i][j] = correlations_rwe[i][j] * volatilities_rwe[i] * volatilities_rwe[j]
	}
}

print(covariance_rwe.flatMap({$0.map({$0.number(3)})}))

let optimizer_rwe = PortfolioOptimizer()

// Conservative investor
let conservative_rwe = try optimizer_rwe.minimumVariancePortfolio(
	expectedReturns: expectedReturns_rwe,
	covariance: covariance_rwe,
	allowShortSelling: false
)

print("Conservative Portfolio ($1M):")
for (i, asset) in assets_rwe.enumerated() {
	let weight = conservative_rwe.weights.toArray()[i]
	if weight > 0.01 {
		let allocation = 1_000_000 * weight
		print("  \(asset): \(allocation.currency(0)) (\(weight.percent(1)))")
	}
}
print("Expected Return: \(conservative_rwe.expectedReturn.percent(1))")
print("Volatility: \(conservative_rwe.volatility.percent(1))")

</code></pre></details>
<p>‚Üí Full API Reference: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/5.2-PortfolioOptimizationGuide.md">BusinessMath Docs ‚Äì 5.2 Portfolio Optimization</a></p><p><strong>Modifications to try</strong>:</p><ol><li>Compare maximum Sharpe vs. risk parity for a 10-asset portfolio</li><li>Build a portfolio with sector constraints (max 30% in any sector)</li><li>Generate an efficient frontier and plot risk vs. return</li><li>Implement a tactical allocation model that shifts weights based on market conditions</li></ol><hr /><h2>Real-World Application</h2><ul><li><strong>Wealth management</strong>: Automate portfolio construction for client accounts</li><li><strong>Institutional investing</strong>: Build multi-asset portfolios with complex constraints</li><li><strong>Trading</strong>: Dynamically rebalance portfolios as correlations change</li><li><strong>Risk management</strong>: Ensure portfolios stay within risk budgets</li></ul><p><strong>Wealth manager use case</strong>: ‚ÄúI manage 50 client accounts, each with different risk tolerances and constraints. I need to generate optimal portfolios programmatically, not manually tune weights in Excel.‚Äù</p><p>BusinessMath makes portfolio optimization a repeatable, auditable process.</p><hr /><p><code>‚òÖ Insight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><p><strong>Why Bonds Get High Allocations in Optimal Portfolios</strong></p><p>Even though bonds have lower expected returns (4% vs. 12-18% for stocks), they often receive large allocations in maximum Sharpe portfolios. Why?</p><p><strong>Diversification benefit</strong>: Bonds have low correlation with stocks. Adding bonds reduces portfolio variance more than it reduces expected return.</p><p><strong>Math</strong>: Portfolio variance = w^T Œ£ w (includes correlation terms)</p><ul><li>If correlation = 0, variance decreases faster than return</li><li>If correlation = 1, no diversification benefit</li></ul><p><strong>Real example</strong>: 100% stocks = 20% vol. Adding 40% bonds might reduce return from 12% ‚Üí 10%, but volatility drops from 20% ‚Üí 12%. Sharpe improves: (10%-2%)/12% > (12%-2%)/20%.</p><p><strong>Rule of thumb</strong>: Low-correlation assets punch above their weight in optimal portfolios.</p><p><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><hr /><h3>üìù Development Note</h3><p>The hardest part of portfolio optimization was <strong>handling numerical instability in covariance matrices</strong>. Real-world correlation matrices are often:</p><ul><li><strong>Ill-conditioned</strong>: Small eigenvalues cause optimization to fail</li><li><strong>Non-positive-definite</strong>: Estimation errors create invalid matrices</li></ul><p>We implemented multiple safeguards:</p><ol><li><strong>Eigenvalue thresholding</strong>: Replace near-zero eigenvalues</li><li><strong>Shrinkage estimators</strong>: Blend sample covariance with structured prior</li><li><strong>Regularization</strong>: Add small constant to diagonal (Ledoit-Wolf)</li></ol><p>Without these, 30% of real-world portfolios would fail to optimize.</p><p><strong>Related Methodology</strong>: <a href="../week-02/01-mon-numerical-foundations">Numerical Stability</a> (Week 2) - Covered condition numbers and ill-posed problems.</p><hr /><h2>Next Steps</h2><p><strong>Coming up Wednesday</strong>: Core Optimization APIs - Understanding the unified optimizer interface, custom objective functions, and algorithm selection.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 7/12</li><li>Posts Published: 23/~48</li><li>Playgrounds: 21 available</li></ul></p><hr /><div style="margin-top: 2em"><p class="blurb" style="font-style: italic">Tagged with: businessmath, swift, portfolio, optimization, modern-portfolio-theory, sharpe-ratio, efficient-frontier</p></div></div></div><header><nav class="noPrint navbar navbar-expand-md" style="border-top: 0.01em solid #d5d5d5;"><div class="container-fluid col"><button type="button" class="navbar-toggler btn" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div id="navbarCollapse" class="collapse navbar-collapse"><ul class="navbar-nav mb-2 mb-md-0 col"><li class="nav-item"><a href="mailto:morals.tech.0x@icloud.com" id="email" rel="me" target="_blank" class="nav-link">email</a></li><li class="nav-item"><a href="https://cal.com/jpurnell/15min" id="calendar" rel="me" target="_blank" class="nav-link">calendar</a></li><li class="nav-item"><a href="http://blog.justinpurnell.com" id="blog" rel="me" target="_blank" class="nav-link">blog</a></li><li class="nav-item"><a href="https://github.com/jpurnell" id="github" rel="me" target="_blank" class="nav-link">github</a></li><li class="nav-item"><a href="https://bsky.app/profile/justinpurnell.com" id="bsky" rel="me" target="_blank" class="nav-link">bsky</a></li><li class="nav-item"><a href="https://mastodon.social/@jpurnell" id="mastodon" rel="me" target="_blank" class="nav-link">mastodon</a></li><li class="nav-item"><a href="https://music.apple.com/us/station/justin-purnells-station/ra.u-a475786ae9cc432a1abb70ff757aa95f" id="radio" rel="me" target="_blank" class="nav-link">radio</a></li><li class="nav-item"><a href="https://www.justinpurnell.com/feed.rss" id="rss" rel="me" target="_blank" class="nav-link">rss</a></li><li class="nav-item"><a href="#" id="theme-toggle" rel="me" target="_blank" class="nav-link">theme</a></li></ul></div></div></nav></header><script src="/js/theme-toggle.js"></script></div><script src="/js/bootstrap.bundle.min.js"></script><script src="/js/syntax-highlighting.js"></script></body></html>