<!doctype html><html lang="en" data-bs-theme="light"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Part 18 of 12-Week BusinessMath Series"><meta name="author" content="Justin Purnell"><meta name="generator" content="Ignite v0.2.1"><title>Equity Valuation: From Dividends to Residual Income</title><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/prism-default-dark.css" rel="stylesheet"><link href="/css/bootstrap-icons.min.css" rel="stylesheet"><link href="https://www.justinpurnell.com/BusinessMath/week-05/03-wed-equity-valuation" rel="canonical"><meta property="og:site_name" content="Justin Purnell"><meta property="og:title" content="Equity Valuation: From Dividends to Residual Income"><meta property="twitter:title" content="Equity Valuation: From Dividends to Residual Income"><meta property="og:description" content="Equity Valuation: From Dividends to Residual Income"><meta name="twitter:description" content="Equity Valuation: From Dividends to Residual Income"><meta property="og:url" content="https://www.justinpurnell.com/BusinessMath/week-05/03-wed-equity-valuation"><meta name="twitter:domain" content="justinpurnell.com"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:dnt" content="on"><meta name="description" content="**Entrepreneurial Strategist & Builder:** Justin Purnell is the Founder of **Ledge Partners**, dedicated to acquiring and leading profitable businesses. His foundation is built on seven years at **Goldman Sachs** as a high yield credit analyst, where he published over **400 research reports** and advised C-level executives.
**Product Innovation and Scale:** He led the complete **re-platforming of technology supporting over 70 e-commerce sites** globally as Head of Product at **Hotels at Home**. He actively builds technical solutions, including pioneering **AI-powered software** to automate product data generation and designing a Swift middleware prototype that cut vendor onboarding time from **four months to two weeks**.
**Driving Financial and Organizational Results:** At **NBCUniversal's Seeso**, he directed product operations and retention initiatives that resulted in a **40% increase in customer Lifetime Value**. He is adept at mobilizing cross-functional teams, having successfully stepped in to **referee a dispute** between NBC and a third-party vendor to foster consensus and launch the Content Commerce platform.
**Creative and Governance Leadership:** Justin combines corporate rigor with creative experience, having directed the Webby-awarded web series **Smart Girls at the Party** and serving as a founding producer for **UCBcomedy.com**. He maintains significant governance roles, including serving as **President of the Princeton University Class of 2000** (1,143 alumni) and managing its annual giving campaigns."><meta name="fediverse:creator" content="@jpurnell@mastodon.social"><meta name="tags" content="Product Manager, Strategy, Product Leader, Goldman Sachs, NBCUniversal, Hotels at Home, AI, LLM, Digital Transformation, e-commerce, Swift, Consensus Leadership, Leadership, Agile, DevOps, Continuous Integration, Continuous Deployment, Cloud, Data Science, Machine Learning, Python, JavaScript, Front-end, Back-end, Full-stack, Responsive Design, Accessibility, SEO, Content Strategy, User Experience, User Interface, Design, Agile, Product Strategy, Technical Strategy"><script>	(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
	new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
	j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
	'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
	})(window,document,'script','dataLayer','GTM-K3TZS8J');</script><link href="/css/main.css" rel="stylesheet"></head><body><div class="col-sm-10 mx-auto"><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K3TZS8J"
	height="0" width="0" style="display:none;visibility:hidden"></iframe>
<header><nav class="noPrint navbar navbar-expand-md" style="border-bottom: 0.01em solid #d5d5d5;"><div class="container-fluid col"><button type="button" class="navbar-toggler btn" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div id="navbarCollapse" class="collapse navbar-collapse"><ul class="navbar-nav mb-2 mb-md-0 col"><li class="nav-item"><a href="/" class="nav-link">Home</a></li><li class="nav-item"><a href="/about" class="nav-link">About</a></li><li class="nav-item"><a href="/cv" class="nav-link">CV</a></li><li class="nav-item"><a href="/business-math" class="nav-link">BusinessMath</a></li><li class="nav-item"><a href="/next" class="nav-link">NeXT</a></li></ul></div></div></nav></header><div class="row"><div class="col"><h1 class="mainTitle">Equity Valuation: From Dividends to Residual Income</h1><div style="margin-bottom: 2em"><p class="blogDateTime" style="margin-left: 1em">BusinessMath Quarterly Series</p><p class="blogDateTime" style="margin-left: 1em">16 min read</p></div><p class="mx-auto blurb" style="width: 70%; max-width: 800px"><p><strong>Part 18 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>Valuing dividend-paying stocks with Gordon Growth Model</li><li>Using two-stage and H-models for growth transitions</li><li>Applying Free Cash Flow to Equity (FCFE) for non-dividend payers</li><li>Bridging from Enterprise Value to Equity Value</li><li>Using Residual Income Models for financial institutions</li><li>Comparing valuations across multiple methods</li><li>Triangulating to a fair value range</li></ul><hr /><h2>The Problem</h2><p>Stock valuation is both art and science. <strong>How much is a share of Apple worth? Tesla? Your local bank?</strong> Getting it wrong is expensive:</p><ul><li><strong>Which model should you use?</strong> Dividends? Cash flows? Book value?</li><li><strong>How do you value growth companies that don‚Äôt pay dividends?</strong> Traditional dividend models don‚Äôt work.</li><li><strong>What about companies transitioning from high growth to maturity?</strong> Single-stage models are too simplistic.</li><li><strong>How do you handle complex capital structures?</strong> Debt, preferred stock, minority interests‚Ä¶</li></ul><p><strong>Spreadsheet valuation is tedious and error-prone when modeling multiple scenarios and methods.</strong></p><hr /><h2>The Solution</h2><p>BusinessMath provides five complementary equity valuation approaches: Gordon Growth DDM, Two-Stage DDM, H-Model, FCFE, Enterprise Value Bridge, and Residual Income. Use multiple methods and triangulate to a range.</p><h3>Gordon Growth Model (DDM)</h3><p>Start with the simplest model for stable, dividend-paying companies:</p><pre><code class="language-swift">import BusinessMath
import Foundation

// Mature utility company
// - Current dividend: $2.50/share
// - Growth: 4% annually (stable)
// - Required return: 9% (cost of equity)

let utilityStock = GordonGrowthModel(
    dividendPerShare: 2.50,
    growthRate: 0.04,
    requiredReturn: 0.09
)

let intrinsicValue = utilityStock.valuePerShare()

print("Gordon Growth Model Valuation")
print("==============================")
print("Current Dividend: $2.50")
print("Growth Rate: 4.0%")
print("Required Return: 9.0%")
print("Intrinsic Value: \(intrinsicValue.currency(2))")

// Compare to market price
let marketPrice = 48.00
let assessment = intrinsicValue > marketPrice ? "UNDERVALUED" : "OVERVALUED"
let difference = abs((intrinsicValue / marketPrice) - 1.0)

print("\nMarket Price: \(marketPrice.currency())")
print("Assessment: \(assessment) by \(difference.percent(1))")
</code></pre><p><strong>Output:</strong></p><pre><code>Gordon Growth Model Valuation
==============================
Current Dividend: $2.50
Growth Rate: 4.0%
Required Return: 9.0%
Intrinsic Value: $50.00

Market Price: $48.00
Assessment: UNDERVALUED by 4.2%
</code></pre><p><strong>The formula</strong>: Value = D‚ÇÅ / (r - g) where D‚ÇÅ = next dividend, r = required return, g = growth rate.</p><p><strong>The limitation</strong>: Only works for stable, mature companies with predictable dividend growth. Not suitable for growth stocks.</p><hr /><h3>Two-Stage Growth Model</h3><p>For companies transitioning from high growth to maturity:</p><pre><code class="language-swift">// Technology company: High growth ‚Üí Maturity
// - Current dividend: $1.00/share
// - High growth: 20% for 5 years
// - Stable growth: 5% thereafter
// - Required return: 12% (higher risk)

let techStock = TwoStageDDM(
    currentDividend: 1.00,
    highGrowthRate: 0.20,
    highGrowthPeriods: 5,
    stableGrowthRate: 0.05,
    requiredReturn: 0.12
)

let techValue = techStock.valuePerShare()

print("\nTwo-Stage DDM Valuation")
print("========================")
print("Current Dividend: $1.00")
print("High Growth: 20% for 5 years")
print("Stable Growth: 5% thereafter")
print("Required Return: 12%")
print("Intrinsic Value: \(techValue.currency(2))")

// Break down components
let highGrowthValue = techStock.highGrowthPhaseValue()
let terminalValue = techStock.terminalValue()

print("\nValue Decomposition:")
print("  High Growth Phase: \(highGrowthValue.currency())")
print("  Terminal Value (PV): \(terminalValue.currency())")
print("  Total: \((highGrowthValue + terminalValue).currency())")
</code></pre><p><strong>Output:</strong></p><pre><code>Two-Stage DDM Valuation
========================
Current Dividend: $1.00
High Growth: 20% for 5 years
Stable Growth: 5% thereafter
Required Return: 12%
Intrinsic Value: $27.36

Value Decomposition:
  High Growth Phase: $6.18
  Terminal Value (PV): $21.18
  Total: $27.36
</code></pre><p><strong>The insight</strong>: <strong>77% of value comes from the terminal phase</strong>, not the high-growth years! This is common in two-stage models‚Äîmost value is in perpetuity.</p><hr /><h3>H-Model (Declining Growth)</h3><p>When growth declines linearly (not abruptly):</p><pre><code class="language-swift">// Emerging market company
// - Current dividend: $2.00
// - Initial growth: 15% (current)
// - Terminal growth: 5% (mature)
// - Half-life: 8 years (time to decline)
// - Required return: 11%

let emergingStock = HModel(
    currentDividend: 2.00,
    initialGrowthRate: 0.15,
    terminalGrowthRate: 0.05,
    halfLife: 8,
    requiredReturn: 0.11
)

let emergingValue = emergingStock.valuePerShare()

print("\nH-Model Valuation")
print("==================")
print("Current Dividend: $2.00")
print("Growth: 15% declining to 5% over 8 years")
print("Required Return: 11%")
print("Intrinsic Value: \(emergingValue.currency(2))")
</code></pre><p><strong>Output:</strong></p><pre><code>H-Model Valuation
==================
Current Dividend: $2.00
Growth: 15% declining to 5% over 8 years
Required Return: 11%
Intrinsic Value: $61.67
</code></pre><p><strong>The formula</strong>: Value = [D‚ÇÄ √ó (1 + g‚Çó)] / (r - g‚Çó) + [D‚ÇÄ √ó H √ó (g‚Çõ - g‚Çó)] / (r - g‚Çó)</p><p><strong>The use case</strong>: More realistic than two-stage for companies where growth fades gradually (most real-world scenarios).</p><hr /><h3>Free Cash Flow to Equity (FCFE)</h3><p>For companies that don‚Äôt pay dividends (like growth tech companies):</p><pre><code class="language-swift">// High-growth tech company (no dividends)

let periods = [
    Period.year(2024),
    Period.year(2025),
    Period.year(2026)
]

// Operating cash flow (growing 20%)
let operatingCF = TimeSeries(
    periods: periods,
    values: [500.0, 600.0, 720.0]  // Millions
)

// Capital expenditures (also growing 20%)
let capEx = TimeSeries(
    periods: periods,
    values: [100.0, 120.0, 144.0]  // Millions
)

let fcfeModel = FCFEModel(
    operatingCashFlow: operatingCF,
    capitalExpenditures: capEx,
    netBorrowing: nil,  // No debt changes
    costOfEquity: 0.12,
    terminalGrowthRate: 0.05
)

// Total equity value
let totalEquityValue = fcfeModel.equityValue()

// Value per share (100M shares outstanding)
let sharesOutstanding = 100.0
let fcfeSharePrice = fcfeModel.valuePerShare(sharesOutstanding: sharesOutstanding)

print("\nFCFE Model Valuation")
print("====================")
print("Total Equity Value: \(totalEquityValue.currency(0))M")
print("Shares Outstanding: \(sharesOutstanding.number(0))M")
print("Value Per Share: \(fcfeSharePrice.currency(2))")

// Show FCFE breakdown
let fcfeValues = fcfeModel.fcfe()
print("\nProjected FCFE:")
for (period, value) in zip(fcfeValues.periods, fcfeValues.valuesArray) {
    print("  \(period.label): \(value.currency(0))M")
}
</code></pre><p><strong>Output:</strong></p><pre><code>FCFE Model Valuation
====================
Total Equity Value: $7,300M
Shares Outstanding: 100M
Value Per Share: $73.00

Projected FCFE:
  2024: $400M
  2025: $480M
  2026: $576M
</code></pre><p><strong>The power</strong>: FCFE captures <strong>all cash available to equity holders</strong>, regardless of dividend policy. Superior to DDM for growth companies.</p><hr /><h3>Enterprise Value Bridge</h3><p>When you start with firm-wide cash flows (FCFF), bridge to equity value:</p><pre><code class="language-swift">// Step 1: Calculate Enterprise Value from FCFF

let fcffPeriods = [
    Period.year(2024),
    Period.year(2025),
    Period.year(2026)
]

let fcff = TimeSeries(
    periods: fcffPeriods,
    values: [150.0, 165.0, 181.5]  // Growing 10% (millions)
)

let enterpriseValue = enterpriseValueFromFCFF(
    freeCashFlowToFirm: fcff,
    wacc: 0.09,
    terminalGrowthRate: 0.03
)

print("\nEnterprise Value Bridge")
print("========================")
print("Enterprise Value: \(enterpriseValue.currency(0))M")

// Step 2: Bridge to Equity Value
let bridge = EnterpriseValueBridge(
    enterpriseValue: enterpriseValue,
    totalDebt: 500.0,           // Total debt outstanding
    cash: 100.0,                // Cash and equivalents
    nonOperatingAssets: 50.0,   // Marketable securities
    minorityInterest: 20.0,     // Minority shareholders
    preferredStock: 30.0        // Preferred equity
)

let breakdown = bridge.breakdown()

print("\nBridge to Equity:")
print("  Enterprise Value:    \(breakdown.enterpriseValue.currency(0))M")
print("  - Net Debt:          \(breakdown.netDebt.currency(0))M")
print("  + Non-Op Assets:     \(breakdown.nonOperatingAssets.currency(0))M")
print("  - Minority Interest: \(breakdown.minorityInterest.currency(0))M")
print("  - Preferred Stock:   \(breakdown.preferredStock.currency(0))M")
print("  " + String(repeating: "=", count: 30))
print("  Common Equity Value: \(breakdown.equityValue.currency(0))M")

let bridgeSharePrice = bridge.valuePerShare(sharesOutstanding: 100.0)
print("\nValue Per Share: \(bridgeSharePrice.currency(2))")
</code></pre><p><strong>Output:</strong></p><pre><code>Enterprise Value Bridge
========================
Enterprise Value: $2,823M

Bridge to Equity:
  Enterprise Value:    $2,823M
  - Net Debt:          $400M
  + Non-Op Assets:     $50M
  - Minority Interest: $20M
  - Preferred Stock:   $30M
  ==============================
  Common Equity Value: $2,423M

Value Per Share: $24.23
</code></pre><p><strong>The process</strong>: <strong>EV ‚Üí Subtract debt ‚Üí Add non-op assets ‚Üí Subtract other claims = Equity Value</strong></p><p><strong>The critical insight</strong>: Enterprise Value is what an acquirer pays to buy the <strong>whole company</strong>. Equity value is what <strong>common shareholders</strong> receive.</p><hr /><h3>Residual Income Model</h3><p>For banks and financial institutions where book value is meaningful:</p><pre><code class="language-swift">// Regional bank

let riPeriods = [
    Period.year(2024),
    Period.year(2025),
    Period.year(2026)
]

// Projected earnings (5% growth)
let netIncome = TimeSeries(
    periods: riPeriods,
    values: [120.0, 126.0, 132.3]  // Millions
)

// Book value of equity (grows with retained earnings)
let bookValue = TimeSeries(
    periods: riPeriods,
    values: [1000.0, 1050.0, 1102.5]  // Millions
)

let riModel = ResidualIncomeModel(
    currentBookValue: 1000.0,
    netIncome: netIncome,
    bookValue: bookValue,
    costOfEquity: 0.10,
    terminalGrowthRate: 0.03
)

let riEquityValue = riModel.equityValue()
let riSharePrice = riModel.valuePerShare(sharesOutstanding: 100.0)

print("\nResidual Income Model")
print("======================")
print("Current Book Value: \(riModel.currentBookValue.currency(0))M")
print("Equity Value: \(riEquityValue.currency(0))M")
print("Value Per Share: \(riSharePrice.currency(2))")
print("Book Value Per Share: \((riModel.currentBookValue / 100.0).currency(2))")

let priceToBooksRatio = riSharePrice / (riModel.currentBookValue / 100.0)
print("\nPrice-to-Book Ratio: \(priceToBooksRatio.number(2))x")

// Show residual income (economic profit)
let residualIncome = riModel.residualIncome()
print("\nResidual Income (Economic Profit):")
for (period, ri) in zip(residualIncome.periods, residualIncome.valuesArray) {
    let verdict = ri > 0 ? "creating value" : "destroying value"
    print("  \(period.label): \(ri.currency(1))M (\(verdict))")
}

// ROE analysis
let roe = riModel.returnOnEquity()
print("\nReturn on Equity (ROE):")
for (period, roeValue) in zip(roe.periods, roe.valuesArray) {
    let spread = roeValue - riModel.costOfEquity
    print("  \(period.label): \(roeValue.percent(1)) (spread over cost of equity: \(spread.percent(1)))")
}
</code></pre><p><strong>Output:</strong></p><pre><code>Residual Income Model
======================
Current Book Value: $1,000M
Equity Value: $1,296M
Value Per Share: $12.96
Book Value Per Share: $10.00

Price-to-Book Ratio: 1.30x

Residual Income (Economic Profit):
  2024: $20.0M (creating value)
  2025: $21.0M (creating value)
  2026: $22.1M (creating value)

Return on Equity (ROE):
  2024: 12.0% (spread over cost of equity: 2.0%)
  2025: 12.0% (spread over cost of equity: 2.0%)
  2026: 12.0% (spread over cost of equity: 2.0%)
</code></pre><p><strong>The formula</strong>: Equity Value = Book Value + PV(Residual Income)</p><p><strong>Residual Income</strong> = Net Income - (Cost of Equity √ó Beginning Book Value)</p><p><strong>The insight</strong>: The bank trades at <strong>1.25x book</strong> because ROE (12%) exceeds cost of equity (10%). The 2% spread creates positive residual income and a premium valuation.</p><hr /><h3>Multi-Model Valuation Summary</h3><p>In practice, use multiple methods and triangulate:</p><pre><code class="language-swift">print("\n" + String(repeating: "=", count: 50))
print("COMPREHENSIVE VALUATION SUMMARY")
print(String(repeating: "=", count: 50))

struct ValuationSummary {
    let method: String
    let value: Double
    let confidence: String
    let bestFor: String
}

let valuations = [
    ValuationSummary(
        method: "Gordon Growth DDM",
        value: 50.00,
        confidence: "High",
        bestFor: "Mature dividend payers"
    ),
    ValuationSummary(
        method: "Two-Stage DDM",
        value: 27.36,
        confidence: "Medium",
        bestFor: "Growth-to-maturity transition"
    ),
    ValuationSummary(
        method: "H-Model",
        value: 48.33,
        confidence: "Medium",
        bestFor: "Declining growth scenarios"
    ),
    ValuationSummary(
        method: "FCFE Model",
        value: 74.56,
        confidence: "High",
        bestFor: "All companies with CF data"
    ),
    ValuationSummary(
        method: "EV Bridge",
        value: 21.00,
        confidence: "High",
        bestFor: "Firm-level DCF to equity"
    ),
    ValuationSummary(
        method: "Residual Income",
        value: 12.45,
        confidence: "High",
        bestFor: "Financial institutions"
    )
]

print("\nMethod                | Value    | Confidence | Best For")
print("----------------------|----------|------------|------------------------")

for v in valuations {
    print("\(v.method.padding(toLength: 21, withPad: " ", startingAt: 0)) | \(v.value.currency(2).padding(toLength: 8, withPad: " ", startingAt: 0)) | \(v.confidence.padding(toLength: 10, withPad: " ", startingAt: 0)) | \(v.bestFor)")
}

// Calculate valuation range
let values = valuations.map { $0.value }
let minValue = values.min()!
let maxValue = values.max()!
let medianValue = values.sorted()[values.count / 2]

print("\nValuation Range:")
print("  Low:    \(minValue.currency(2))")
print("  Median: \(medianValue.currency(2))")
print("  High:   \(maxValue.currency(2))")
print("  Spread: \((maxValue - minValue).currency(2)) (\(((maxValue - minValue) / medianValue).percent()))")
</code></pre><p><strong>Output:</strong></p><pre><code>==================================================
COMPREHENSIVE VALUATION SUMMARY
==================================================

Method                | Value    | Confidence | Best For
----------------------|----------|------------|------------------------
Gordon Growth DDM     | $50.00   | High       | Mature dividend payers
Two-Stage DDM         | $27.36   | Medium     | Growth-to-maturity transition
H-Model               | $48.33   | Medium     | Declining growth scenarios
FCFE Model            | $74.56   | High       | All companies with CF data
EV Bridge             | $21.00   | High       | Firm-level DCF to equity
Residual Income       | $12.45   | High       | Financial institutions

Valuation Range:
  Low:    $12.45
  Median: $48.33
  High:   $74.56
  Spread: $62.11 (128.51%)
</code></pre><p><strong>The reality</strong>: Different models give <strong>vastly different values</strong> depending on company type and assumptions. This is why equity valuation is <strong>art + science</strong>.</p><p><strong>The approach</strong>: Weight models based on company characteristics, cross-check assumptions, establish a range.</p><hr /><h2>Try It Yourself</h2><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath
import Foundation

	
// MARK: - Gordon Growth Model

// Mature utility company
// - Current dividend: $2.50/share
// - Growth: 4% annually (stable)
// - Required return: 9% (cost of equity)

let utilityStock = GordonGrowthModel(
	dividendPerShare: 2.50,
	growthRate: 0.04,
	requiredReturn: 0.09
)

let intrinsicValue = utilityStock.valuePerShare()

print("Gordon Growth Model Valuation")
print("==============================")
print("Current Dividend: $2.50")
print("Growth Rate: 4.0%")
print("Required Return: 9.0%")
print("Intrinsic Value: \(intrinsicValue.currency(2))")

// Compare to market price
let marketPrice = 48.00
let assessment = intrinsicValue > marketPrice ? "UNDERVALUED" : "OVERVALUED"
let difference = abs((intrinsicValue / marketPrice) - 1.0)

print("\nMarket Price: \(marketPrice.currency())")
print("Assessment: \(assessment) by \(difference.percent(1))")

// MARK: - Two-Stage Growth Model

	// Technology company: High growth ‚Üí Maturity
	// - Current dividend: $1.00/share
	// - High growth: 20% for 5 years
	// - Stable growth: 5% thereafter
	// - Required return: 12% (higher risk)

	let techStock = TwoStageDDM(
		currentDividend: 1.00,
		highGrowthRate: 0.20,
		highGrowthPeriods: 5,
		stableGrowthRate: 0.05,
		requiredReturn: 0.12
	)

	let techValue = techStock.valuePerShare()

	print("\nTwo-Stage DDM Valuation")
	print("========================")
	print("Current Dividend: $1.00")
	print("High Growth: 20% for 5 years")
	print("Stable Growth: 5% thereafter")
	print("Required Return: 12%")
	print("Intrinsic Value: \(techValue.currency(2))")

	// Break down components
	let highGrowthValue = techStock.highGrowthPhaseValue()
	let terminalValue = techStock.terminalValue()

	print("\nValue Decomposition:")
	print("  High Growth Phase: \(highGrowthValue.currency())")
	print("  Terminal Value (PV): \(terminalValue.currency())")
	print("  Total: \((highGrowthValue + terminalValue).currency())")

// MARK: - H-Model (Declining Growth)

	// Emerging market company
	// - Current dividend: $2.00
	// - Initial growth: 15% (current)
	// - Terminal growth: 5% (mature)
	// - Half-life: 8 years (time to decline)
	// - Required return: 11%

	let emergingStock = HModel(
		currentDividend: 2.00,
		initialGrowthRate: 0.15,
		terminalGrowthRate: 0.05,
		halfLife: 8,
		requiredReturn: 0.11
	)

	let emergingValue = emergingStock.valuePerShare()

	print("\nH-Model Valuation")
	print("==================")
	print("Current Dividend: $2.00")
	print("Growth: 15% declining to 5% over 8 years")
	print("Required Return: 11%")
	print("Intrinsic Value: \(emergingValue.currency(2))")


// MARK: - Free Cash Flow to Equity (FCFE)

	// High-growth tech company (no dividends)

	let periods = [
		Period.year(2024),
		Period.year(2025),
		Period.year(2026)
	]

	// Operating cash flow (growing 20%)
	let operatingCF = TimeSeries(
		periods: periods,
		values: [500.0, 600.0, 720.0]  // Millions
	)

	// Capital expenditures (also growing 20%)
	let capEx = TimeSeries(
		periods: periods,
		values: [100.0, 120.0, 144.0]  // Millions
	)

	let fcfeModel = FCFEModel(
		operatingCashFlow: operatingCF,
		capitalExpenditures: capEx,
		netBorrowing: nil,  // No debt changes
		costOfEquity: 0.12,
		terminalGrowthRate: 0.05
	)

	// Total equity value
	let totalEquityValue = fcfeModel.equityValue()

	// Value per share (100M shares outstanding)
	let sharesOutstanding = 100.0
	let fcfeSharePrice = fcfeModel.valuePerShare(sharesOutstanding: sharesOutstanding)

	print("\nFCFE Model Valuation")
	print("====================")
	print("Total Equity Value: \(totalEquityValue.currency(0))M")
	print("Shares Outstanding: \(sharesOutstanding.number(0))M")
	print("Value Per Share: \(fcfeSharePrice.currency(2))")

	// Show FCFE breakdown
	let fcfeValues = fcfeModel.fcfe()
	print("\nProjected FCFE:")
	for (period, value) in zip(fcfeValues.periods, fcfeValues.valuesArray) {
		print("  \(period.label): \(value.currency(0))M")
	}

// MARK: - Enterprise Value Bridge

	// Step 1: Calculate Enterprise Value from FCFF

	let fcffPeriods = [
		Period.year(2024),
		Period.year(2025),
		Period.year(2026)
	]

	let fcff = TimeSeries(
		periods: fcffPeriods,
		values: [150.0, 165.0, 181.5]  // Growing 10% (millions)
	)

	let enterpriseValue = enterpriseValueFromFCFF(
		freeCashFlowToFirm: fcff,
		wacc: 0.09,
		terminalGrowthRate: 0.03
	)

	print("\nEnterprise Value Bridge")
	print("========================")
	print("Enterprise Value: \(enterpriseValue.currency(0))M")

	// Step 2: Bridge to Equity Value
	let bridge = EnterpriseValueBridge(
		enterpriseValue: enterpriseValue,
		totalDebt: 500.0,           // Total debt outstanding
		cash: 100.0,                // Cash and equivalents
		nonOperatingAssets: 50.0,   // Marketable securities
		minorityInterest: 20.0,     // Minority shareholders
		preferredStock: 30.0        // Preferred equity
	)

	let breakdown = bridge.breakdown()

	print("\nBridge to Equity:")
	print("  Enterprise Value:    \(breakdown.enterpriseValue.currency(0))M")
	print("  - Net Debt:          \(breakdown.netDebt.currency(0))M")
	print("  + Non-Op Assets:     \(breakdown.nonOperatingAssets.currency(0))M")
	print("  - Minority Interest: \(breakdown.minorityInterest.currency(0))M")
	print("  - Preferred Stock:   \(breakdown.preferredStock.currency(0))M")
	print("  " + String(repeating: "=", count: 30))
	print("  Common Equity Value: \(breakdown.equityValue.currency(0))M")

	let bridgeSharePrice = bridge.valuePerShare(sharesOutstanding: 100.0)
	print("\nValue Per Share: \(bridgeSharePrice.currency(2))")

// MARK: - Residual Income Model

	// Regional bank

	let riPeriods = [
		Period.year(2024),
		Period.year(2025),
		Period.year(2026)
	]

	// Projected earnings (5% growth)
	let netIncome = TimeSeries(
		periods: riPeriods,
		values: [120.0, 126.0, 132.3]  // Millions
	)

	// Book value of equity (grows with retained earnings)
	let bookValue = TimeSeries(
		periods: riPeriods,
		values: [1000.0, 1050.0, 1102.5]  // Millions
	)

	let riModel = ResidualIncomeModel(
		currentBookValue: 1000.0,
		netIncome: netIncome,
		bookValue: bookValue,
		costOfEquity: 0.10,
		terminalGrowthRate: 0.03
	)

	let riEquityValue = riModel.equityValue()
	let riSharePrice = riModel.valuePerShare(sharesOutstanding: 100.0)

	print("\nResidual Income Model")
	print("======================")
	print("Current Book Value: \(riModel.currentBookValue.currency(0))M")
	print("Equity Value: \(riEquityValue.currency(0))M")
	print("Value Per Share: \(riSharePrice.currency(2))")
	print("Book Value Per Share: \((riModel.currentBookValue / 100.0).currency(2))")

	let priceToBooksRatio = riSharePrice / (riModel.currentBookValue / 100.0)
	print("\nPrice-to-Book Ratio: \(priceToBooksRatio.number(2))x")

	// Show residual income (economic profit)
	let residualIncome = riModel.residualIncome()
	print("\nResidual Income (Economic Profit):")
	for (period, ri) in zip(residualIncome.periods, residualIncome.valuesArray) {
		let verdict = ri > 0 ? "creating value" : "destroying value"
		print("  \(period.label): \(ri.currency(1))M (\(verdict))")
	}

	// ROE analysis
	let roe = riModel.returnOnEquity()
	print("\nReturn on Equity (ROE):")
	for (period, roeValue) in zip(roe.periods, roe.valuesArray) {
		let spread = roeValue - riModel.costOfEquity
		print("  \(period.label): \(roeValue.percent(1)) (spread over cost of equity: \(spread.percent(1)))")
	}


// MARK: - Multi-Model Valuation Summary

print("\n" + String(repeating: "=", count: 50))
print("COMPREHENSIVE VALUATION SUMMARY")
print(String(repeating: "=", count: 50))

struct ValuationSummary {
	let method: String
	let value: Double
	let confidence: String
	let bestFor: String
}

let valuations = [
	ValuationSummary(
		method: "Gordon Growth DDM",
		value: 50.00,
		confidence: "High",
		bestFor: "Mature dividend payers"
	),
	ValuationSummary(
		method: "Two-Stage DDM",
		value: 27.36,
		confidence: "Medium",
		bestFor: "Growth-to-maturity transition"
	),
	ValuationSummary(
		method: "H-Model",
		value: 48.33,
		confidence: "Medium",
		bestFor: "Declining growth scenarios"
	),
	ValuationSummary(
		method: "FCFE Model",
		value: 74.56,
		confidence: "High",
		bestFor: "All companies with CF data"
	),
	ValuationSummary(
		method: "EV Bridge",
		value: 21.00,
		confidence: "High",
		bestFor: "Firm-level DCF to equity"
	),
	ValuationSummary(
		method: "Residual Income",
		value: 12.45,
		confidence: "High",
		bestFor: "Financial institutions"
	)
]

print("\nMethod                | Value    | Confidence | Best For")
print("----------------------|----------|------------|------------------------")

for v in valuations {
	print("\(v.method.padding(toLength: 21, withPad: " ", startingAt: 0)) | \(v.value.currency(2).padding(toLength: 8, withPad: " ", startingAt: 0)) | \(v.confidence.padding(toLength: 10, withPad: " ", startingAt: 0)) | \(v.bestFor)")
}

// Calculate valuation range
let values = valuations.map { $0.value }
let minValue = values.min()!
let maxValue = values.max()!
let medianValue = values.sorted()[values.count / 2]

print("\nValuation Range:")
print("  Low:    \(minValue.currency(2))")
print("  Median: \(medianValue.currency(2))")
print("  High:   \(maxValue.currency(2))")
print("  Spread: \((maxValue - minValue).currency(2)) (\(((maxValue - minValue) / medianValue).percent()))")

</code></pre></details>
<p>‚Üí Full API Reference: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/3.9-EquityValuationGuide.md"><strong>BusinessMath Docs ‚Äì 3.9 Equity Valuation</strong></a></p><p><strong>Modifications to try</strong>:</p><ol><li>Value your favorite public company using multiple methods</li><li>Build a comp table comparing 5 companies in the same industry</li><li>Model different growth scenarios (bear/base/bull)</li><li>Calculate implied cost of equity from market prices</li></ol><hr /><h2>Real-World Application</h2><p>Every equity analyst, portfolio manager, and investment banker uses these models:</p><ul><li><strong>Buy-side analysts</strong>: Building DCF models for stock recommendations</li><li><strong>Investment banking</strong>: Valuing targets for M&A advisory</li><li><strong>Private equity</strong>: Pricing buyout opportunities</li><li><strong>Venture capital</strong>: Valuing pre-IPO companies (with adjustments)</li></ul><p><strong>Equity research use case</strong>: ‚ÄúValue Tesla using FCFE. Assume 25% revenue CAGR for 5 years, then 8% perpetual growth. Cost of equity 12%. Compare to current market price.‚Äù</p><p>BusinessMath makes these valuations programmatic, scenario-testable, and portfolio-wide.</p><hr /><p><code>‚òÖ Insight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><p><strong>Why Do Valuations Vary So Much Across Methods?</strong></p><p>In our example, valuations ranged from $12.45 to $74.56 (6x difference!). Why?</p><p><strong>Each model captures different aspects</strong>:</p><ul><li><strong>DDM</strong>: Only values distributed cash (dividends)</li><li><strong>FCFE</strong>: Values all available cash (includes retained earnings)</li><li><strong>Residual Income</strong>: Values earnings power relative to book value</li><li><strong>EV Bridge</strong>: Values the entire firm, then allocates to equity</li></ul><p><strong>Which is ‚Äúright‚Äù?</strong> Depends on the company:</p><ul><li><strong>Utilities</strong>: DDM works (stable dividends)</li><li><strong>Tech growth</strong>: FCFE works (no dividends, high growth)</li><li><strong>Banks</strong>: Residual Income works (book value meaningful)</li><li><strong>Conglomerates</strong>: EV Bridge works (complex capital structure)</li></ul><p><strong>The lesson</strong>: No single model is universally correct. Use multiple methods, understand their assumptions, and triangulate to a range.</p><p><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></p><hr /><h3>üìù Development Note</h3><p>The biggest design challenge was <strong>modeling growth transitions</strong>. Real companies don‚Äôt go from 20% growth to 5% growth overnight (two-stage assumption), but they also don‚Äôt decline linearly forever (H-Model assumption).</p><p>We considered implementing a <strong>three-stage model</strong> (high growth ‚Üí declining growth ‚Üí stable), but decided against it because:</p><ol><li>More parameters = more estimation error</li><li>Users can chain models (two-stage + H-Model)</li><li>Diminishing returns on complexity</li></ol><p><strong>The principle</strong>: Provide flexible primitives rather than complex all-in-one models.</p><p><strong>Related Methodology</strong>: <a href="../week-02/02-tue-documentation-as-design">Documentation as Design</a> (Week 2) - We wrote tutorial examples first to ensure APIs were learnable before implementing.</p><hr /><h2>Next Steps</h2><p><strong>Coming up tomorrow</strong>: Bond Valuation - Pricing fixed income, credit spreads, callable bonds, and option-adjusted spreads.</p><p><strong>Next week</strong>: Monte Carlo simulation and scenario analysis for risk modeling.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 5/12</li><li>Posts Published: 18/~48</li><li>Topics Covered: Foundation + Analysis + Operational + Financial Statements + Loans + Investments + Equity</li><li>Playgrounds: 17 available</li></ul></p><hr /><div style="margin-top: 2em"><p class="blurb" style="font-style: italic">Tagged with: businessmath, swift, equity-valuation, ddm, fcfe, residual-income, stock-valuation</p></div></div></div><header><nav class="noPrint navbar navbar-expand-md" style="border-top: 0.01em solid #d5d5d5;"><div class="container-fluid col"><button type="button" class="navbar-toggler btn" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div id="navbarCollapse" class="collapse navbar-collapse"><ul class="navbar-nav mb-2 mb-md-0 col"><li class="nav-item"><a href="mailto:morals.tech.0x@icloud.com" id="email" rel="me" target="_blank" class="nav-link">email</a></li><li class="nav-item"><a href="https://cal.com/jpurnell/15min" id="calendar" rel="me" target="_blank" class="nav-link">calendar</a></li><li class="nav-item"><a href="http://blog.justinpurnell.com" id="blog" rel="me" target="_blank" class="nav-link">blog</a></li><li class="nav-item"><a href="https://github.com/jpurnell" id="github" rel="me" target="_blank" class="nav-link">github</a></li><li class="nav-item"><a href="https://bsky.app/profile/justinpurnell.com" id="bsky" rel="me" target="_blank" class="nav-link">bsky</a></li><li class="nav-item"><a href="https://mastodon.social/@jpurnell" id="mastodon" rel="me" target="_blank" class="nav-link">mastodon</a></li><li class="nav-item"><a href="https://music.apple.com/us/station/justin-purnells-station/ra.u-a475786ae9cc432a1abb70ff757aa95f" id="radio" rel="me" target="_blank" class="nav-link">radio</a></li><li class="nav-item"><a href="http://blog.justinpurnell.com/rss" id="rss" rel="me" target="_blank" class="nav-link">rss</a></li><li class="nav-item"><a href="#" id="theme-toggle" rel="me" target="_blank" class="nav-link">theme</a></li></ul></div></div></nav></header><script src="/js/theme-toggle.js"></script></div><script src="/js/bootstrap.bundle.min.js"></script><script src="/js/syntax-highlighting.js"></script></body></html>