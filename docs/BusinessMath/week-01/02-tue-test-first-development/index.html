<!doctype html><html lang="en" data-bs-theme="light"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Development Journey Series"><meta name="author" content="Justin Purnell"><meta name="generator" content="Ignite v0.2.1"><title>Test-First Development with AI</title><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/prism-default-dark.css" rel="stylesheet"><link href="/css/bootstrap-icons.min.css" rel="stylesheet"><link href="https://www.justinpurnell.com/BusinessMath/week-01/02-tue-test-first-development" rel="canonical"><link href="/feed.rss" rel="alternate" type="application/rss+xml" title="Justin Purnell"><link href="/feed.rss" rel="alternate" type="application/rss+xml" title="Justin Purnell"><meta property="og:site_name" content="Justin Purnell"><meta property="og:title" content="Test-First Development with AI"><meta property="twitter:title" content="Test-First Development with AI"><meta property="og:description" content="Test-First Development with AI"><meta name="twitter:description" content="Test-First Development with AI"><meta property="og:url" content="https://www.justinpurnell.com/BusinessMath/week-01/02-tue-test-first-development"><meta name="twitter:domain" content="justinpurnell.com"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:dnt" content="on"><meta name="description" content="**Entrepreneurial Strategist & Builder:** Justin Purnell is the Founder of **Ledge Partners**, dedicated to acquiring and leading profitable businesses. His foundation is built on seven years at **Goldman Sachs** as a high yield credit analyst, where he published over **400 research reports** and advised C-level executives.
**Product Innovation and Scale:** He led the complete **re-platforming of technology supporting over 70 e-commerce sites** globally as Head of Product at **Hotels at Home**. He actively builds technical solutions, including pioneering **AI-powered software** to automate product data generation and designing a Swift middleware prototype that cut vendor onboarding time from **four months to two weeks**.
**Driving Financial and Organizational Results:** At **NBCUniversal's Seeso**, he directed product operations and retention initiatives that resulted in a **40% increase in customer Lifetime Value**. He is adept at mobilizing cross-functional teams, having successfully stepped in to **referee a dispute** between NBC and a third-party vendor to foster consensus and launch the Content Commerce platform.
**Creative and Governance Leadership:** Justin combines corporate rigor with creative experience, having directed the Webby-awarded web series **Smart Girls at the Party** and serving as a founding producer for **UCBcomedy.com**. He maintains significant governance roles, including serving as **President of the Princeton University Class of 2000** (1,143 alumni) and managing its annual giving campaigns."><meta name="fediverse:creator" content="@jpurnell@mastodon.social"><meta name="tags" content="Product Manager, Strategy, Product Leader, Goldman Sachs, NBCUniversal, Hotels at Home, AI, LLM, Digital Transformation, e-commerce, Swift, Consensus Leadership, Leadership, Agile, DevOps, Continuous Integration, Continuous Deployment, Cloud, Data Science, Machine Learning, Python, JavaScript, Front-end, Back-end, Full-stack, Responsive Design, Accessibility, SEO, Content Strategy, User Experience, User Interface, Design, Agile, Product Strategy, Technical Strategy"><script>	(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
	new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
	j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
	'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
	})(window,document,'script','dataLayer','GTM-K3TZS8J');</script><link href="/css/main.css" rel="stylesheet"></head><body><div class="col-sm-10 mx-auto"><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K3TZS8J"
	height="0" width="0" style="display:none;visibility:hidden"></iframe>
<header><nav class="noPrint navbar navbar-expand-md" style="border-bottom: 0.01em solid #d5d5d5;"><div class="container-fluid col"><button type="button" class="navbar-toggler btn" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div id="navbarCollapse" class="collapse navbar-collapse"><ul class="navbar-nav mb-2 mb-md-0 col"><li class="nav-item"><a href="/" class="nav-link">Home</a></li><li class="nav-item"><a href="/about" class="nav-link">About</a></li><li class="nav-item"><a href="/cv" class="nav-link">CV</a></li><li class="nav-item"><a href="/business-math" class="nav-link">BusinessMath</a></li><li class="nav-item"><a href="/next" class="nav-link">NeXT</a></li></ul></div></div></nav></header><div class="row"><div class="col"><h1 class="mainTitle">Test-First Development with AI</h1><div style="margin-bottom: 2em"><p class="blogDateTime" style="margin-left: 1em">BusinessMath Development Journey</p><p class="blogDateTime" style="margin-left: 1em">8 min read</p></div><p class="mx-auto blurb" style="width: 70%; max-width: 800px"><p><strong>Development Journey Series</strong></p><hr /><h2>The Context</h2><p>When we began implementing BusinessMath’s TVM (Time Value of Money) functions, we faced a fundamental question: How do we ensure AI-generated code is correct?</p><p>When you set out to build a financial library, errors can cost real money. A bug in present value calculation could lead to bad retirement planning. An error in IRR could result in misallocated capital.</p><p>We needed a way to specify exactly what we wanted and verify that we got it.</p><hr /><h2>The Challenge</h2><p>We’re all coming around to the idea that AI is incredibly powerful at generating code, but we’ve all also heard of it’s dangerous tendency to “hallucinate.” Code can <em>look</em> reasonable but may be subtly wrong.</p><p><strong>The symptoms we encountered</strong>:</p><ul><li>AI might confidently implement simple interest when we needed compound interest</li><li>Generic type constraints would be almost correct but not quite right</li><li>Edge cases (zero rate, negative periods) would be silently mishandled</li></ul><p>A traditional approach—write code, then write tests—simply doesn’t make sense for AI collaboration. If we did it that way, by the time we got around to writing tests, we’d already be invested in understanding and debugging the AI’s output. We needed a better way.</p><hr /><h2>The Solution</h2><p>Instead, we adopted a strict <strong>test-first development</strong> with a specific workflow designed for AI collaboration:</p><h3>The RED-GREEN-REFACTOR Cycle</h3><p><strong>1. RED - Write a Failing Test</strong></p><p>Before asking AI for any implementation, we wrote tests that specified exactly what wanted:</p><pre><code class="language-swift">@Test("Future value compounds correctly")
func testFutureValue() throws {
    let fv = calculateFutureValue(
        presentValue: 100.0,
        rate: 0.05,
        periods: 10.0
    )
    // Expected: 100 * (1.05)^10 = 162.89
    #expect(abs(fv - 162.89) < 0.01)
}
</code></pre><p>This test will fail—the function doesn’t exist yet. <strong>That’s the point.</strong></p><p><strong>2. GREEN - AI Implements from Specification</strong></p><p>Now you give AI a clear specification:</p><blockquote><p>“Implement <code>calculateFutureValue</code> that makes this test pass. Use compound interest formula: FV = PV × (1 + r)^n. Make it generic over types conforming to <code>Real</code> protocol from swift-numerics.”</p></blockquote><p>AI generates:</p><pre><code class="language-swift">public func calculateFutureValue<T: Real>(
    presentValue: T,
    rate: T,
    periods: T
) -> T {
    return presentValue * T.pow((1 + rate), periods)
}
</code></pre><p>Run the test. <strong>It passes.</strong> Green!</p><p><strong>3. REFACTOR - Improve with Safety Net</strong></p><p>Now that tests pass, you can refactor fearlessly:</p><pre><code class="language-swift">// Extract reusable compound interest calculation
private func compoundFactor<T: Real>(rate: T, periods: T) -> T {
    return T.pow((1 + rate), periods)
}

public func calculateFutureValue<T: Real>(
    presentValue: T,
    rate: T,
    periods: T
) -> T {
    return presentValue * compoundFactor(rate: rate, periods: periods)
}
</code></pre><p>Tests still pass. Refactor succeeded.</p><hr /><h2>The Results</h2><p>After implementing BusinessMath using strict test-first development:</p><p><strong>Metrics that improved</strong>:</p><ul><li><strong>0 regression bugs</strong> across 247 tests after major refactorings</li><li><strong>180+ bugs caught</strong> before they reached “implementation” status</li><li><strong>3 API redesigns</strong> caught during test writing (before any code existed)</li></ul><p><strong>Time investment</strong>:</p><ul><li>Initial setup: ~2 hours (learning Swift Testing framework)</li><li>Per-function overhead: ~5-10 minutes (writing tests first)</li><li>ROI: <strong>Massive</strong>—debugging time dropped from hours to minutes</li></ul><hr /><h2>What Worked</h2><p><strong>1. Failing Tests as Specifications</strong></p><p>AI works best when given concrete, executable specifications. A failing test is the clearest possible spec.</p><p><strong>Example</strong>: We wanted NPV calculation. Instead of saying “implement net present value,” we wrote:</p><pre><code class="language-swift">@Test("NPV calculation matches known value")
func testNPV() throws {
    let cashFlows = [-100.0, 50.0, 50.0, 50.0]
    let npv = calculateNPV(rate: 0.10, cashFlows: cashFlows)
    // Manual calculation: -100 + 50/1.1 + 50/1.1^2 + 50/1.1^3 = 24.34
    #expect(abs(npv - 24.34) < 0.01)
}
</code></pre><p>AI immediately understood: discount each cash flow, sum them. Perfect implementation on first try.</p><p><strong>2. Tests Caught AI Errors Immediately</strong></p><p>First AI attempt at <code>calculateFutureValue</code> used <strong>simple interest</strong>: <code>FV = PV * (1 + rate * periods)</code>.</p><p>Test failed. We saw the error instantly. Corrected the prompt. Next attempt used compound interest correctly.</p><p><strong>Total debugging time</strong>: 30 seconds.</p><p><strong>3. Generic Implementations Validated</strong></p><p>We used the Swift Numerics as our only real dependency, but it allowed us to work generically over and “Real” number. Writing tests for multiple types ensured generics worked:</p><pre><code class="language-swift">@Test("Future value works with Double")
func testFVDouble() {
    let fv: Double = calculateFutureValue(presentValue: 100.0, rate: 0.05, periods: 10.0)
    #expect(abs(fv - 162.89) < 0.01)
}

@Test("Future value works with Float")
func testFVFloat() {
    let fv: Float = calculateFutureValue(presentValue: 100.0, rate: 0.05, periods: 10.0)
    #expect(abs(fv - 162.89) < 0.1)  // Looser tolerance for Float
}
</code></pre><p>Both passed. Generic implementation validated.</p><hr /><h2>What Didn’t Work</h2><p><strong>1. Vague Tests</strong></p><p>A test has to be specific to be useful. A test-driven approach therefore works best when you have domain expertise and can give concrete guidance:</p><pre><code class="language-swift">@Test("Present value works")
func testPV() {
    let pv = presentValue(futureValue: 1000.0, rate: 0.05, periods: 10.0)
    #expect(pv > 0)  // Too vague!
}
</code></pre><p>AI would generate code here that passes, but wouldn’t necessarily be write. Just specifying that the value be positive won’t ensure that it is the <em>correct</em> value.</p><p><strong>Fix</strong>: Always test against known, calculated values.</p><p><strong>2. Missing Edge Cases</strong></p><p>Just getting the right value is great, but you also have to think through and test against edge cases:</p><ul><li>What if rate is zero?</li><li>What if periods is negative?</li><li>What if present value is negative?</li></ul><p>AI would happily implement code that crashed or returned nonsense for these inputs.</p><p><strong>Fix</strong>: Enumerate edge cases explicitly. Write tests for them all.</p><pre><code class="language-swift">@Test("Future value with zero rate")
func testFVZeroRate() {
    let fv = calculateFutureValue(presentValue: 100.0, rate: 0.0, periods: 10.0)
    #expect(fv == 100.0)  // No growth
}

@Test("Future value with negative periods throws")
func testFVNegativePeriods() {
    #expect(throws: FinancialError.self) {
        try calculateFutureValue(presentValue: 100.0, rate: 0.05, periods: -5.0)
    }
}
</code></pre><hr /><h2>Key Takeaway</h2><p>We’re not in a place to just trust AI to do what you’re thinking. But by specifying test-first development, you can use AI not as a code generator, but instead into a <strong>specification executor</strong>.</p><p><strong>Without tests first</strong>: “Implement present value calculation” → AI guesses what you mean → You debug AI’s interpretation</p><p><strong>With tests first</strong>: <em>Failing test shows exactly what you want</em> → AI implements to spec → Tests verify correctness</p><blockquote><p><strong>Key Takeaway</strong>: AI works best when given failing tests as specifications. Vague requests produce vague code. Concrete, executable specs produce correct code.</p></blockquote><hr /><h2>How to Apply This</h2><p><strong>For your next project</strong>:</p><p><strong>1. Write the Test First (RED)</strong></p><ul><li>Before asking AI for implementation, write the failing test</li><li>Include expected values calculated manually or from reference</li><li>Cover edge cases explicitly</li></ul><p><strong>2. Give AI the Test as Specification (GREEN)</strong></p><ul><li>Paste the test into your AI prompt</li><li>Say: “Implement this function to make the test pass”</li><li>Run the test to verify</li></ul><p><strong>3. Refactor with Confidence (REFACTOR)</strong></p><ul><li>Extract patterns, improve names, optimize</li><li>Tests protect against regressions</li><li>If tests still pass, refactor succeeded</li></ul><p><strong>Starting template</strong>:</p><pre><code># For each new function:

1. Write failing test with expected value
2. Prompt AI: "Implement [function name] to make this test pass: [paste test]"
3. Run test, verify it passes
4. Add edge case tests
5. Refactor if needed
</code></pre><hr /><h2>See It In Action</h2><p>This practice is demonstrated in the following technical posts:</p><p><strong>Technical Examples</strong>:</p><ul><li><a href="../01-mon-getting-started"><strong>Getting Started</strong> (Monday)</a>: Shows <code>presentValue</code> implemented test-first</li><li><strong>Time Series Foundation</strong> (Wednesday): Period arithmetic validated with tests</li><li><strong>Time Value of Money</strong> (Week 1 Friday case study): Multiple TVM functions integrated</li></ul><p><strong>Related Practices</strong>:</p><ul><li><strong>Documentation as Design</strong> (Week 2): Write docs before implementation</li><li><strong>Coding Standards</strong> (Week 5): Forbidden patterns caught by tests</li></ul><hr /><h2>Common Pitfalls</h2><h3>❌ Pitfall 1: Writing tests after implementation</h3><p><strong>Problem</strong>: You’ve already invested in understanding AI’s code. Tests feel like busy work.<strong>Solution</strong>: Discipline. Tests first, always. No exceptions.</p><h3>❌ Pitfall 2: Tests that just check “doesn’t crash”</h3><p><strong>Problem</strong>: <code>#expect(result != nil)</code> passes for wrong implementations.<strong>Solution</strong>: Test against known, correct values. Do the math yourself first.</p><h3>❌ Pitfall 3: Skipping edge cases</h3><p><strong>Problem</strong>: AI handles normal cases fine, but crashes on zero/negative/nil.<strong>Solution</strong>: Explicitly enumerate edge cases. Write tests for all of them.</p><hr /><h2>Further Reading</h2><p><strong>Technical foundation</strong>:</p><ul><li>Swift Testing framework documentation</li><li><code>#expect</code> vs <code>XCTAssert</code> differences</li></ul><p><strong>Tools mentioned</strong>:</p><ul><li><a href="https://developer.apple.com/xcode/swift-testing/">Swift Testing</a>: Modern testing framework for Swift</li><li><a href="https://www.swift.org/blog/numerics/">Swift Numerics</a>: Generic numeric protocols (<code>Real</code>, <code>ElementaryFunctions</code>)</li></ul><hr /><h2>Discussion</h2><p><strong>Questions to consider</strong>:</p><ol><li>How does test-first development change when AI is writing the implementation?</li><li>What level of test coverage is “enough” for financial calculations?</li><li>How do you balance test-first discipline with exploration/prototyping?</li></ol><p><strong>Share your experience</strong>: Have you tried test-first development with AI? What worked? What didn’t?</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 1/12</li><li>Posts Published: 2/~48</li><li>Methodology Posts: 1/12</li><li>Practices Covered: Test-First Development</li></ul></p><hr /><div style="margin-top: 2em"><p class="blurb" style="font-style: italic">Tagged with: ai-collaboration, tdd, testing, red-green-refactor, development journey</p></div></div></div><header><nav class="noPrint navbar navbar-expand-md" style="border-top: 0.01em solid #d5d5d5;"><div class="container-fluid col"><button type="button" class="navbar-toggler btn" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div id="navbarCollapse" class="collapse navbar-collapse"><ul class="navbar-nav mb-2 mb-md-0 col"><li class="nav-item"><a href="mailto:morals.tech.0x@icloud.com" id="email" rel="me" target="_blank" class="nav-link">email</a></li><li class="nav-item"><a href="https://cal.com/jpurnell/15min" id="calendar" rel="me" target="_blank" class="nav-link">calendar</a></li><li class="nav-item"><a href="http://blog.justinpurnell.com" id="blog" rel="me" target="_blank" class="nav-link">blog</a></li><li class="nav-item"><a href="https://github.com/jpurnell" id="github" rel="me" target="_blank" class="nav-link">github</a></li><li class="nav-item"><a href="https://bsky.app/profile/justinpurnell.com" id="bsky" rel="me" target="_blank" class="nav-link">bsky</a></li><li class="nav-item"><a href="https://mastodon.social/@jpurnell" id="mastodon" rel="me" target="_blank" class="nav-link">mastodon</a></li><li class="nav-item"><a href="https://music.apple.com/us/station/justin-purnells-station/ra.u-a475786ae9cc432a1abb70ff757aa95f" id="radio" rel="me" target="_blank" class="nav-link">radio</a></li><li class="nav-item"><a href="https://www.justinpurnell.com/feed.rss" id="rss" rel="me" target="_blank" class="nav-link">rss</a></li><li class="nav-item"><a href="#" id="theme-toggle" rel="me" target="_blank" class="nav-link">theme</a></li></ul></div></div></nav></header><script src="/js/theme-toggle.js"></script></div><script src="/js/bootstrap.bundle.min.js"></script><script src="/js/syntax-highlighting.js"></script></body></html>