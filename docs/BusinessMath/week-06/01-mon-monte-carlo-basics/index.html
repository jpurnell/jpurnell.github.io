<!doctype html><html lang="en" data-bs-theme="light"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Part 20 of 12-Week BusinessMath Series"><meta name="author" content="Justin Purnell"><meta name="generator" content="Ignite v0.2.1"><title>Monte Carlo Simulation for Financial Forecasting</title><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/prism-default-dark.css" rel="stylesheet"><link href="/css/bootstrap-icons.min.css" rel="stylesheet"><link href="https://www.justinpurnell.com/BusinessMath/week-06/01-mon-monte-carlo-basics" rel="canonical"><link href="/feed.rss" rel="alternate" type="application/rss+xml" title="Justin Purnell"><link href="/feed.rss" rel="alternate" type="application/rss+xml" title="Justin Purnell"><meta property="og:site_name" content="Justin Purnell"><meta property="og:title" content="Monte Carlo Simulation for Financial Forecasting"><meta property="twitter:title" content="Monte Carlo Simulation for Financial Forecasting"><meta property="og:description" content="Monte Carlo Simulation for Financial Forecasting"><meta name="twitter:description" content="Monte Carlo Simulation for Financial Forecasting"><meta property="og:url" content="https://www.justinpurnell.com/BusinessMath/week-06/01-mon-monte-carlo-basics"><meta name="twitter:domain" content="justinpurnell.com"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:dnt" content="on"><meta name="description" content="**Entrepreneurial Strategist & Builder:** Justin Purnell is the Founder of **Ledge Partners**, dedicated to acquiring and leading profitable businesses. His foundation is built on seven years at **Goldman Sachs** as a high yield credit analyst, where he published over **400 research reports** and advised C-level executives.
**Product Innovation and Scale:** He led the complete **re-platforming of technology supporting over 70 e-commerce sites** globally as Head of Product at **Hotels at Home**. He actively builds technical solutions, including pioneering **AI-powered software** to automate product data generation and designing a Swift middleware prototype that cut vendor onboarding time from **four months to two weeks**.
**Driving Financial and Organizational Results:** At **NBCUniversal's Seeso**, he directed product operations and retention initiatives that resulted in a **40% increase in customer Lifetime Value**. He is adept at mobilizing cross-functional teams, having successfully stepped in to **referee a dispute** between NBC and a third-party vendor to foster consensus and launch the Content Commerce platform.
**Creative and Governance Leadership:** Justin combines corporate rigor with creative experience, having directed the Webby-awarded web series **Smart Girls at the Party** and serving as a founding producer for **UCBcomedy.com**. He maintains significant governance roles, including serving as **President of the Princeton University Class of 2000** (1,143 alumni) and managing its annual giving campaigns."><meta name="fediverse:creator" content="@jpurnell@mastodon.social"><meta name="tags" content="Product Manager, Strategy, Product Leader, Goldman Sachs, NBCUniversal, Hotels at Home, AI, LLM, Digital Transformation, e-commerce, Swift, Consensus Leadership, Leadership, Agile, DevOps, Continuous Integration, Continuous Deployment, Cloud, Data Science, Machine Learning, Python, JavaScript, Front-end, Back-end, Full-stack, Responsive Design, Accessibility, SEO, Content Strategy, User Experience, User Interface, Design, Agile, Product Strategy, Technical Strategy"><script>	(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
	new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
	j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
	'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
	})(window,document,'script','dataLayer','GTM-K3TZS8J');</script><link href="/css/main.css" rel="stylesheet"></head><body><div class="col-sm-10 mx-auto"><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K3TZS8J"
	height="0" width="0" style="display:none;visibility:hidden"></iframe>
<header><nav class="noPrint navbar navbar-expand-md" style="border-bottom: 0.01em solid #d5d5d5;"><div class="container-fluid col"><button type="button" class="navbar-toggler btn" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div id="navbarCollapse" class="collapse navbar-collapse"><ul class="navbar-nav mb-2 mb-md-0 col"><li class="nav-item"><a href="/" class="nav-link">Home</a></li><li class="nav-item"><a href="/about" class="nav-link">About</a></li><li class="nav-item"><a href="/cv" class="nav-link">CV</a></li><li class="nav-item"><a href="/business-math" class="nav-link">BusinessMath</a></li><li class="nav-item"><a href="/next" class="nav-link">NeXT</a></li></ul></div></div></nav></header><div class="row"><div class="col"><h1 class="mainTitle">Monte Carlo Simulation for Financial Forecasting</h1><div style="margin-bottom: 2em"><p class="blogDateTime" style="margin-left: 1em">BusinessMath Quarterly Series</p><p class="blogDateTime" style="margin-left: 1em">20 min read</p></div><p class="mx-auto blurb" style="width: 70%; max-width: 800px"><p><strong>Part 20 of 12-Week BusinessMath Series</strong></p><hr /><h2>What Youâ€™ll Learn</h2><ul><li>Building probabilistic forecasts with uncertainty quantification</li><li>Projecting revenue with compounding growth and randomness</li><li>Creating complete income statement forecasts with multiple uncertain drivers</li><li>Calculating confidence intervals (90%, 95%) for projections</li><li>Extracting mean, median, and percentile scenarios</li><li>Optimizing Monte Carlo simulations for performance</li></ul><hr /><h2>The Problem</h2><p>Traditional financial forecasts give you a single number: â€œRevenue next quarter: $1M.â€ But reality is uncertain:</p><ul><li><strong>What if growth varies?</strong> Expected 10% growth might be anywhere from 5%-15%.</li><li><strong>How likely is profitability?</strong> Is there a 50% chance or 95% chance weâ€™re profitable?</li><li><strong>Whatâ€™s the downside risk?</strong> In the worst 5% of scenarios, how bad does it get?</li><li><strong>How do uncertainties combine?</strong> When both revenue AND costs are uncertain, whatâ€™s the total impact?</li></ul><p><strong>Single-point forecasts can be misleading</strong>â€”Any forecast is just a data point in actual decision making, but the false certainty of a single point can obscure the broader range of possibilties that can inform a good decision.</p><hr /><h2>The Solution</h2><p>Monte Carlo simulation runs thousands of scenarios, each with different random values from probability distributions (like a roulette wheel, hence the name). Instead of â€œRevenue = $1Mâ€, you get â€œRevenue: Mean $1M, but with a 90% Confidence Interval ranging from $850K to $1.15Mâ€.</p><p>BusinessMath provides probabilistic drivers, simulation infrastructure, and statistical analysis to enable you to build more robust forecasts based off a range of values.</p><h3>Single Metric with Growth Uncertainty</h3><p>Start simple: project revenue with uncertain quarterly growth:</p><pre><code class="language-swift">import BusinessMath

// Historical revenue
let baseRevenue = 1_000_000.0  // $1M

// Growth rate uncertainty: mean 10%, std dev 5%
let growthDriver = ProbabilisticDriver<Double>.normal(
    name: "Quarterly Growth",
    mean: 0.10,      // Expected 10% per quarter
    stdDev: 0.05     // Â±5% uncertainty
)

// Project 4 quarters
let q1 = Period.quarter(year: 2025, quarter: 1)
let quarters = [q1, q1 + 1, q1 + 2, q1 + 3]

// Run Monte Carlo simulation (10,000 paths)
let iterations = 10_000

// Pre-allocate for performance
var allValues: [[Double]] = Array(repeating: [], count: quarters.count)
for i in 0...(quarters.count - 1) {
    allValues[i].reserveCapacity(iterations)
}

// Generate revenue paths with compounding
for _ in 0...(iterations - 1) {
    var currentRevenue = baseRevenue

    for (periodIndex, period) in quarters.enumerated() {
        let growth = growthDriver.sample(for: period)
        currentRevenue = currentRevenue * (1.0 + growth)  // Compound!
        allValues[periodIndex].append(currentRevenue)
    }
}

// Calculate statistics for each period
var statistics: [Period: SimulationStatistics] = [:]
var percentiles: [Period: Percentiles] = [:]

for (periodIndex, period) in quarters.enumerated() {
    let results = SimulationResults(values: allValues[periodIndex])
    statistics[period] = results.statistics
    percentiles[period] = results.percentiles
}

// Display results
print("Revenue Forecast with Compounding Growth")
print("=========================================")
print("Base Revenue: \(baseRevenue.currency(0))")
print("Quarterly Growth: 10% Â± 5% (compounding)")
print()
print("Quarter  Mean        Median      90% CI                        Growth")
print("-------  ----------  ----------  ----------------------------  -------")

for quarter in quarters {
    let stats = statistics[quarter]!
    let pctiles = percentiles[quarter]!
    let growth = (stats.mean - baseRevenue) / baseRevenue

    print("\(quarter.label)  \(stats.mean.currency(0))  \(pctiles.p50.currency(0))  [\(pctiles.p5.currency(0)), \(pctiles.p95.currency(0))]  \(growth.percent(1))")
}
</code></pre><p><strong>Output:</strong></p><pre><code>Revenue Forecast with Compounding Growth
=========================================
Base Revenue: $1,000,000
Quarterly Growth: 10% Â± 5% (compounding)

Quarter  Mean        Median      90% CI                    Growth
-------  ----------  ----------  ------------------------  -------
2025-Q1  $1,098,850  $1,098,794  [$1,017,019, $1,180,785]  9.9%
2025-Q2  $1,208,699  $1,207,346  [$1,084,379, $1,337,429]  20.9%
2025-Q3  $1,328,825  $1,325,827  [$1,162,620, $1,506,463]  32.9%
2025-Q4  $1,462,127  $1,454,999  [$1,250,988, $1,692,565]  46.2%
</code></pre><p><strong>The insights</strong>:</p><ul><li><strong>Compounding accelerates</strong>: 46.4% total growth (not 40% = 4 Ã— 10%)</li><li><strong>Uncertainty widens</strong>: Q1 CI width = $165K, Q4 = $442K (2.7Ã— wider)</li><li><strong>Assymetric distribution</strong>: Mean slightly > Median (right-skewed from compounding)</li></ul><hr /><p>###Critical Implementation Detail: Compounding</p><p>The key to proper compounding is generating <strong>complete paths</strong> in each iteration:</p><pre><code class="language-swift">// âœ“ CORRECT: Complete path per iteration
for iteration in 1...10_000 {
    var revenue = baseRevenue
    for period in periods {
        revenue *= (1 + sampleGrowth())  // Compounds across periods
        recordValue(period, revenue)
    }
}

// âœ— WRONG: Each period sampled independently
for period in periods {
    for iteration in 1...10_000 {
        let revenue = baseRevenue * (1 + sampleGrowth())  // No compounding!
        recordValue(period, revenue)
    }
}
</code></pre><p><strong>Why this matters</strong>: In the correct approach, Q2 revenue is based on Q1â€™s realized revenue, not the original base. This creates path-dependency and realistic compounding.</p><hr /><h3>Extract Scenario Time Series</h3><p>Convert simulation results to concrete scenarios:</p><pre><code class="language-swift">// Build time series at different confidence levels
let expectedValues = quarters.map { statistics[$0]!.mean }
let medianValues = quarters.map { percentiles[$0]!.p50 }
let p5Values = quarters.map { percentiles[$0]!.p5 }
let p95Values = quarters.map { percentiles[$0]!.p95 }

let expectedRevenue = TimeSeries(periods: quarters, values: expectedValues)
let medianRevenue = TimeSeries(periods: quarters, values: medianValues)
let conservativeRevenue = TimeSeries(periods: quarters, values: p5Values)
let optimisticRevenue = TimeSeries(periods: quarters, values: p95Values)

print("\nScenario Projections:")
print("Conservative (P5):  \(conservativeRevenue.valuesArray.map { $0.currency(0) })")
print("Median (P50):       \(medianRevenue.valuesArray.map { $0.currency(0) })")
print("Expected (mean):    \(expectedRevenue.valuesArray.map { $0.currency(0) })")
print("Optimistic (P95):   \(optimisticRevenue.valuesArray.map { $0.currency(0) })")
</code></pre><p><strong>Output:</strong></p><pre><code>Scenario Projections:
Conservative (P5):  ["$1,018,650", "$1,085,428", "$1,163,683", "$1,252,460"]
Median (P50):       ["$1,099,356", "$1,208,034", "$1,327,870", "$1,457,335"]
Expected (mean):    ["$1,099,955", "$1,209,512", "$1,330,944", "$1,463,487"]
Optimistic (P95):   ["$1,181,847", "$1,339,856", "$1,510,784", "$1,693,091"]
</code></pre><p><strong>Usage</strong>: These time series can feed into budget planning, NPV calculations, or dashboard visualization.</p><hr /><h3>Complete Income Statement Forecast</h3><p>Now build a full P&L with multiple uncertain drivers:</p><pre><code class="language-swift">// Define probabilistic drivers
struct IncomeStatementDrivers {
    let unitsSold: ProbabilisticDriver<Double>
    let averagePrice: ProbabilisticDriver<Double>
    let cogs: ProbabilisticDriver<Double>  // % of revenue
    let opex: ProbabilisticDriver<Double>

    init() {
        // Units: Normal distribution (mean 10K, std 1K)
        self.unitsSold = .normal(
            name: "Units Sold",
            mean: 10_000.0,
            stdDev: 1_000.0
        )

        // Price: Triangular distribution (most likely $100, range $95-$110)
        self.averagePrice = .triangular(
            name: "Average Price",
            low: 95.0,
            high: 110.0,
            base: 100.0
        )

        // COGS as % of revenue: Normal (mean 60%, std 3%)
        self.cogs = .normal(
            name: "COGS %",
            mean: 0.60,
            stdDev: 0.03
        )

        // OpEx: Normal (mean $200K, std $20K)
        self.opex = .normal(
            name: "Operating Expenses",
            mean: 200_000.0,
            stdDev: 20_000.0
        )
    }
}

let drivers = IncomeStatementDrivers()
let periods = Period.year(2025).quarters()

// Run simulation manually for full control
var revenueValues: [[Double]] = Array(repeating: [], count: periods.count)
var grossProfitValues: [[Double]] = Array(repeating: [], count: periods.count)
var opIncomeValues: [[Double]] = Array(repeating: [], count: periods.count)

for i in 0...(periods.count - 1) {
    revenueValues[i].reserveCapacity(iterations)
    grossProfitValues[i].reserveCapacity(iterations)
    opIncomeValues[i].reserveCapacity(iterations)
}

for _ in 0...(iterations - 1) {
    for (periodIndex, period) in periods.enumerated() {
        // Sample all drivers
        let units = drivers.unitsSold.sample(for: period)
        let price = drivers.averagePrice.sample(for: period)
        let cogsPercent = drivers.cogs.sample(for: period)
        let opexAmount = drivers.opex.sample(for: period)

        // Calculate P&L
        let revenue = units * price
        let grossProfit = revenue * (1.0 - cogsPercent)
        let operatingIncome = grossProfit - opexAmount

        // Record
        revenueValues[periodIndex].append(revenue)
        grossProfitValues[periodIndex].append(grossProfit)
        opIncomeValues[periodIndex].append(operatingIncome)
    }
}

// Calculate statistics
var revenueStats: [Period: SimulationStatistics] = [:]
var revenuePctiles: [Period: Percentiles] = [:]
var gpStats: [Period: SimulationStatistics] = [:]
var gpPctiles: [Period: Percentiles] = [:]
var opStats: [Period: SimulationStatistics] = [:]
var opPctiles: [Period: Percentiles] = [:]

for (periodIndex, period) in periods.enumerated() {
    let revResults = SimulationResults(values: revenueValues[periodIndex])
    revenueStats[period] = revResults.statistics
    revenuePctiles[period] = revResults.percentiles

    let gpResults = SimulationResults(values: grossProfitValues[periodIndex])
    gpStats[period] = gpResults.statistics
    gpPctiles[period] = gpResults.percentiles

    let opResults = SimulationResults(values: opIncomeValues[periodIndex])
    opStats[period] = opResults.statistics
    opPctiles[period] = opResults.percentiles
}

// Display comprehensive forecast
print("\nIncome Statement Forecast - 2025")
print("==================================")

for quarter in periods {
    print("\n\(quarter.label)")
    print(String(repeating: "-", count: 60))

    // Revenue
    let revS = revenueStats[quarter]!
    let revP = revenuePctiles[quarter]!
    print("Revenue")
    print("  Expected: \(revS.mean.currency(0))")
    print("  Std Dev:  \(revS.stdDev.currency(0)) (CoV: \((revS.stdDev / revS.mean).percent(1)))")
    print("  90% CI:   [\(revP.p5.currency(0)), \(revP.p95.currency(0))]")

    // Gross Profit
    let gpS = gpStats[quarter]!
    let gpP = gpPctiles[quarter]!
    let gpMargin = gpS.mean / revS.mean
    print("\nGross Profit")
    print("  Expected: \(gpS.mean.currency(0)) (\(gpMargin.percent(1)) margin)")
    print("  90% CI:   [\(gpP.p5.currency(0)), \(gpP.p95.currency(0))]")

    // Operating Income
    let opS = opStats[quarter]!
    let opP = opPctiles[quarter]!
    let opMargin = opS.mean / revS.mean
    print("\nOperating Income")
    print("  Expected: \(opS.mean.currency(0)) (\(opMargin.percent(1)) margin)")
    print("  90% CI:   [\(opP.p5.currency(0)), \(opP.p95.currency(0))]")

    // Risk assessment
    let profitProb = opP.p5 > 0 ? 100 : (opP.p25 > 0 ? 75 : (opP.p50 > 0 ? 50 : 25))
    print("\nRisk: Probability of profit ~\(profitProb)%")
}
</code></pre><p><strong>Output (Q1 sample):</strong></p><pre><code>Income Statement Forecast - 2025
==================================

2025-Q1
------------------------------------------------------------
Revenue
  Expected: $1,016,299
  Std Dev:  $107,047 (CoV: 10.5%)
  90% CI:   [$847,015, $1,196,331]

Gross Profit
  Expected: $406,751 (40.0% margin)
  90% CI:   [$323,310, $497,667]

Operating Income
  Expected: $206,721 (20.3% margin)
  90% CI:   [$116,827, $302,834]

Risk: Probability of profit ~100%

2025-Q2
------------------------------------------------------------
Revenue
  Expected: $1,015,920
  Std Dev:  $105,407 (CoV: 10.4%)
  90% CI:   [$844,988, $1,190,621]

Gross Profit
  Expected: $406,658 (40.0% margin)
  90% CI:   [$322,571, $496,529]

Operating Income
  Expected: $206,519 (20.3% margin)
  90% CI:   [$118,335, $300,982]

Risk: Probability of profit ~100%

2025-Q3
------------------------------------------------------------
Revenue
  Expected: $1,015,300
  Std Dev:  $106,692 (CoV: 10.5%)
  90% CI:   [$842,995, $1,192,164]

Gross Profit
  Expected: $406,423 (40.0% margin)
  90% CI:   [$323,562, $496,073]

Operating Income
  Expected: $206,643 (20.4% margin)
  90% CI:   [$116,430, $301,980]

Risk: Probability of profit ~100%

2025-Q4
------------------------------------------------------------
Revenue
  Expected: $1,016,188
  Std Dev:  $106,038 (CoV: 10.4%)
  90% CI:   [$841,278, $1,188,276]

Gross Profit
  Expected: $406,515 (40.0% margin)
  90% CI:   [$323,719, $495,371]

Operating Income
  Expected: $206,563 (20.3% margin)
  90% CI:   [$117,112, $302,171]

Risk: Probability of profit ~100%
</code></pre><p><strong>The power</strong>: You now have a complete probabilistic P&L showing expected values, confidence intervals, and risk metrics for every line item. But note, this doesnâ€™t just have to be done for financial models. Anything that you want to model with uncertainty can be simulated this way</p><hr /><h3>Performance Optimization</h3><p>For basic monte carlo simulation runs, optimizations may not be worth the lift, but for large simulations (50K+ iterations), we have some recommendations to really maximize performance:</p><pre><code class="language-swift">// 1. Pre-allocate arrays
var values: [Double] = []
values.reserveCapacity(iterations)  // Avoids repeated reallocation

// 2. Store by period, not by path
// Good: allValues[periodIndex][iterationIndex]
// Bad:  allPaths[iterationIndex][periodIndex] (poor cache locality)

// 3. Inline calculations instead of function calls
// The function call overhead matters at 10M+ samples

// 4. Use SimulationResults for statistics
// It sorts once and calculates all percentiles efficiently
let results = SimulationResults(values: values)
let p5 = results.percentiles.p5    // âœ“ Fast (already sorted)
let mean = results.statistics.mean  // âœ“ Fast (already computed)
</code></pre><p><strong>Performance benchmark</strong>: 10,000 iterations Ã— 20 periods = 200K samples runs in < 1 second on modern hardware with these optimizations.</p><hr /><h3>GPU-Accelerated Expression Models for Single-Period Calculations</h3><p>For single-period calculations with high iteration counts, BusinessMath provides <code>MonteCarloExpressionModel</code> - a GPU-accelerated approach that delivers 10-100Ã— speedup with minimal memory usage. Weâ€™ve got <a href="../week-06/02-mon-gpu-acceleration">a deeper dive on GPU acceleration here</a>.</p><p><strong>When to use expression models:</strong></p><ul><li>âœ… Single-period calculations (no compounding across time)</li><li>âœ… High iteration counts (50,000+)</li><li>âœ… Compute-intensive formulas</li><li>âœ… Memory-constrained environments</li></ul><p><strong>When to use traditional loops:</strong></p><ul><li>âœ… Multi-period compounding (like the revenue growth example above)</li><li>âœ… Complex state management across periods</li><li>âœ… Path-dependent calculations</li></ul><p>Letâ€™s revisit the income statement forecast using GPU-accelerated expression models:</p><pre><code class="language-swift">import BusinessMath

// Pre-compute any constants
let taxRate = 0.21

// Define the P&L model using expression builder
let incomeStatementModel = MonteCarloExpressionModel { builder in
    // Inputs: units, price, cogsPercent, opex
    let units = builder[0]
    let price = builder[1]
    let cogsPercent = builder[2]
    let opex = builder[3]

    // Calculate revenue and costs
    let revenue = units * price
    let cogs = revenue * cogsPercent
    let grossProfit = revenue - cogs
    let ebitda = grossProfit - opex

    // Conditional tax (only pay tax if profitable)
    let isProfitable = ebitda.greaterThan(0.0)
    let tax = isProfitable.ifElse(
        then: ebitda * taxRate,
        else: 0.0
    )

    let netIncome = ebitda - tax

    return netIncome  // Return what we're simulating
}

// Set up high-performance simulation
var simulation = MonteCarloSimulation(
    iterations: 100_000,  // 10Ã— more iterations than before
    enableGPU: true,
    expressionModel: incomeStatementModel
)

// Add input distributions (order matches builder[0], builder[1], etc.)
simulation.addInput(SimulationInput(
    name: "Units Sold",
    distribution: DistributionNormal(mean: 10_000, stdDev: 1_000)
))

simulation.addInput(SimulationInput(
    name: "Average Price",
    distribution: DistributionTriangular(low: 95, high: 110, mode: 100)
))

simulation.addInput(SimulationInput(
    name: "COGS Percentage",
    distribution: DistributionNormal(mean: 0.60, stdDev: 0.03)
))

simulation.addInput(SimulationInput(
    name: "Operating Expenses",
    distribution: DistributionNormal(mean: 200_000, stdDev: 20_000)
))

// Run simulation
let results = try simulation.run()

// Display results
print("GPU-Accelerated Income Statement Forecast")
print("==========================================")
print("Iterations: \(results.iterations.formatted())")
print("Compute Time: \(results.computeTime.formatted(.number.precision(.fractionLength(1)))) ms")
print("GPU Used: \(results.usedGPU ? "Yes" : "No")")
print()
print("Net Income After Tax:")
print("  Mean:     \(results.statistics.mean.currency(0))")
print("  Median:   \(results.percentiles.p50.currency(0))")
print("  Std Dev:  \(results.statistics.stdDev.currency(0))")
print("  95% CI:   [\(results.percentiles.p5.currency(0)), \(results.percentiles.p95.currency(0))]")
print()

// Risk metrics
let profitableCount = results.valuesArray.filter { $0 > 0 }.count
let profitabilityRate = Double(profitableCount) / Double(results.iterations)
print("Risk Metrics:")
print("  Probability of Profit: \(profitabilityRate.percent(1))")
print("  Value at Risk (5%):    \(results.percentiles.p5.currency(0))")
</code></pre><p><strong>Output:</strong></p><pre><code>GPU-Accelerated Income Statement Forecast
==========================================
Iterations: 100,000
Compute Time: 45.2 ms
GPU Used: Yes

Net Income After Tax:
  Mean:     $163,287
  Median:   $163,402
  Std Dev:  $66,148
  95% CI:   [$54,076, $278,331]

Risk Metrics:
  Probability of Profit: 99.2%
  Value at Risk (5%):    $54,076
</code></pre><p><strong>Performance comparison:</strong></p><table><thead><th>Approach</th><th>Iterations</th><th>Time</th><th>Memory</th><th>Speedup</th></thead><tbody><tr><td>Traditional loops</td><td>10,000</td><td>~850 ms</td><td>~15 MB</td><td>1Ã— (baseline)</td></tr><tr><td>GPU Expression Model</td><td>100,000</td><td>~45 ms</td><td>~8 MB</td><td><strong>~189Ã—</strong></td></tr></tbody></table><p><code>â˜… Insight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></p><p><strong>Understanding Constants vs Variables in Expression Models</strong></p><p>Expression models use a special DSL (domain-specific language) that compiles to GPU bytecode. This creates two distinct â€œworldsâ€:</p><p><strong>Swift World (outside the builder):</strong></p><pre><code class="language-swift">let taxRate = 0.21  // Regular Swift Double
let multiplier = pow(1.05, 10)  // Use Swift's pow() for constants
</code></pre><p><strong>DSL World (inside the builder):</strong></p><pre><code class="language-swift">let revenue = units * price  // ExpressionProxy objects
let afterTax = revenue * (1.0 - taxRate)  // Use pre-computed constant
</code></pre><p><strong>Critical Rule</strong>: Pre-compute all constants outside the builder using Swift Foundationâ€™s standard functions (<code>pow()</code>, <code>sqrt()</code>, <code>exp()</code>, etc.). Inside the builder, only use DSL methods (<code>.exp()</code>, <code>.sqrt()</code>, <code>.power()</code>) on variables that depend on random inputs.</p><p><strong>Why?</strong> GPU methods have to be pre-compiled for the GPU to do itâ€™s magic and optimize calculation. The builder creates an expression tree that gets compiled to bytecode and sent to the GPU. Constants should be baked into the bytecode, not recomputed millions of times.</p><pre><code class="language-swift">// âŒ WRONG: Computing constants inside builder
let wrongModel = MonteCarloExpressionModel { builder in
    let rate = 0.05
    let years = 10.0
    let multiplier = (1.0 + rate).power(years)  // ERROR! Can't call .power() on Double
    return builder[0] * multiplier
}

// âœ“ CORRECT: Pre-compute constants outside
let rate = 0.05
let years = 10.0
let growthFactor = pow(1.0 + rate, years)  // Swift's pow() for constants

let correctModel = MonteCarloExpressionModel { builder in
    let principal = builder[0]
    return principal * growthFactor  // Use pre-computed constant
}
</code></pre><p>This design enables the GPU to run at maximum speed - constants are embedded in the bytecode, and only the randomized variables are computed per iteration.</p><p><code>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></p><p><strong>When Expression Models Arenâ€™t Appropriate:</strong></p><p>The revenue growth forecast we showed earlier requires traditional loops:</p><pre><code class="language-swift">// This REQUIRES traditional loops (compounding across periods)
for _ in 0...(iterations - 1) {
    var currentRevenue = baseRevenue
    for period in periods {
        let growth = sampleGrowth()
        currentRevenue *= (1.0 + growth)  // State carries forward!
        record(period, currentRevenue)
    }
}
</code></pre><p><strong>Why?</strong> Each periodâ€™s value depends on the previous periodâ€™s outcome. Expression models excel at independent calculations but canâ€™t handle this kind of path-dependent compounding.</p><p><strong>The right tool for the job:</strong></p><ul><li><strong>Compounding forecasts</strong> â†’ Traditional loops</li><li><strong>Single-period high-throughput</strong> â†’ Expression models</li><li><strong>Complex multi-period dependencies</strong> â†’ Traditional loops</li><li><strong>Simple formulas with 100K+ iterations</strong> â†’ Expression models</li></ul><p>For comprehensive coverage of GPU-accelerated Monte Carlo, see the full guide: <a href="doc:4.3-MonteCarloExpressionModelsGuide">doc:4.3-MonteCarloExpressionModelsGuide</a></p><hr /><h2>Try It Yourself</h2><details>
<summary>Click to expand full playground code</summary>
<pre><code class="language-swift">import BusinessMath

	
// MARK: - Single Metric with Growth Uncertainty

// Historical revenue
let baseRevenue = 1_000_000.0  // $1M

// Growth rate uncertainty: mean 10%, std dev 5%
let growthDriver = ProbabilisticDriver<Double>.normal(
	name: "Quarterly Growth",
	mean: 0.10,      // Expected 10% per quarter
	stdDev: 0.05     // Â±5% uncertainty
)

// Project 4 quarters
let q1 = Period.quarter(year: 2025, quarter: 1)
let quarters = [q1, q1 + 1, q1 + 2, q1 + 3]

// Run Monte Carlo simulation (10,000 paths)
let iterations = 10_000

// Pre-allocate for performance
var allValues: [[Double]] = Array(repeating: [], count: quarters.count)
for i in 0...(quarters.count - 1) {
	allValues[i].reserveCapacity(iterations)
}

// Generate revenue paths with compounding
for _ in 0...(iterations - 1) {
	var currentRevenue = baseRevenue

	for (periodIndex, period) in quarters.enumerated() {
		let growth = growthDriver.sample(for: period)
		currentRevenue = currentRevenue * (1.0 + growth)  // Compound!
		allValues[periodIndex].append(currentRevenue)
	}
}

// Calculate statistics for each period
var statistics: [Period: SimulationStatistics] = [:]
var percentiles: [Period: Percentiles] = [:]

for (periodIndex, period) in quarters.enumerated() {
	let results = SimulationResults(values: allValues[periodIndex])
	statistics[period] = results.statistics
	percentiles[period] = results.percentiles
}

// Display results
print("Revenue Forecast with Compounding Growth")
print("=========================================")
print("Base Revenue: \(baseRevenue.currency(0))")
print("Quarterly Growth: 10% Â± 5% (compounding)")
print()
print("Quarter  Mean        Median      90% CI                    Growth")
print("-------  ----------  ----------  ------------------------  -------")

for quarter in quarters {
	let stats = statistics[quarter]!
	let pctiles = percentiles[quarter]!
	let growth = (stats.mean - baseRevenue) / baseRevenue

	print("\(quarter.label)  \(stats.mean.currency(0))  \(pctiles.p50.currency(0))  [\(pctiles.p5.currency(0)), \(pctiles.p95.currency(0))]  \(growth.percent(1))")
}


// MARK: - Extract Scenario Time Series

	// Build time series at different confidence levels
	let expectedValues = quarters.map { statistics[$0]!.mean }
	let medianValues = quarters.map { percentiles[$0]!.p50 }
	let p5Values = quarters.map { percentiles[$0]!.p5 }
	let p95Values = quarters.map { percentiles[$0]!.p95 }

	let expectedRevenue = TimeSeries(periods: quarters, values: expectedValues)
	let medianRevenue = TimeSeries(periods: quarters, values: medianValues)
	let conservativeRevenue = TimeSeries(periods: quarters, values: p5Values)
	let optimisticRevenue = TimeSeries(periods: quarters, values: p95Values)

	print("\nScenario Projections:")
	print("Conservative (P5):  \(conservativeRevenue.valuesArray.map { $0.currency(0) })")
	print("Median (P50):       \(medianRevenue.valuesArray.map { $0.currency(0) })")
	print("Expected (mean):    \(expectedRevenue.valuesArray.map { $0.currency(0) })")
	print("Optimistic (P95):   \(optimisticRevenue.valuesArray.map { $0.currency(0) })")

// MARK: - Complete Income Statement Forecast

	// Define probabilistic drivers
	struct IncomeStatementDrivers {
		let unitsSold: ProbabilisticDriver<Double>
		let averagePrice: ProbabilisticDriver<Double>
		let cogs: ProbabilisticDriver<Double>  // % of revenue
		let opex: ProbabilisticDriver<Double>

		init() {
			// Units: Normal distribution (mean 10K, std 1K)
			self.unitsSold = .normal(
				name: "Units Sold",
				mean: 10_000.0,
				stdDev: 1_000.0
			)

			// Price: Triangular distribution (most likely $100, range $95-$110)
			self.averagePrice = .triangular(
				name: "Average Price",
				low: 95.0,
				high: 110.0,
				base: 100.0
			)

			// COGS as % of revenue: Normal (mean 60%, std 3%)
			self.cogs = .normal(
				name: "COGS %",
				mean: 0.60,
				stdDev: 0.03
			)

			// OpEx: Normal (mean $200K, std $20K)
			self.opex = .normal(
				name: "Operating Expenses",
				mean: 200_000.0,
				stdDev: 20_000.0
			)
		}
	}

	let drivers = IncomeStatementDrivers()
	let periods = Period.year(2025).quarters()

	// Run simulation manually for full control
	var revenueValues: [[Double]] = Array(repeating: [], count: periods.count)
	var grossProfitValues: [[Double]] = Array(repeating: [], count: periods.count)
	var opIncomeValues: [[Double]] = Array(repeating: [], count: periods.count)

	for i in 0...(periods.count - 1) {
		revenueValues[i].reserveCapacity(iterations)
		grossProfitValues[i].reserveCapacity(iterations)
		opIncomeValues[i].reserveCapacity(iterations)
	}

	for _ in 0...(iterations - 1) {
		for (periodIndex, period) in periods.enumerated() {
			// Sample all drivers
			let units = drivers.unitsSold.sample(for: period)
			let price = drivers.averagePrice.sample(for: period)
			let cogsPercent = drivers.cogs.sample(for: period)
			let opexAmount = drivers.opex.sample(for: period)

			// Calculate P&L
			let revenue = units * price
			let grossProfit = revenue * (1.0 - cogsPercent)
			let operatingIncome = grossProfit - opexAmount

			// Record
			revenueValues[periodIndex].append(revenue)
			grossProfitValues[periodIndex].append(grossProfit)
			opIncomeValues[periodIndex].append(operatingIncome)
		}
	}

	// Calculate statistics
	var revenueStats: [Period: SimulationStatistics] = [:]
	var revenuePctiles: [Period: Percentiles] = [:]
	var gpStats: [Period: SimulationStatistics] = [:]
	var gpPctiles: [Period: Percentiles] = [:]
	var opStats: [Period: SimulationStatistics] = [:]
	var opPctiles: [Period: Percentiles] = [:]

	for (periodIndex, period) in periods.enumerated() {
		let revResults = SimulationResults(values: revenueValues[periodIndex])
		revenueStats[period] = revResults.statistics
		revenuePctiles[period] = revResults.percentiles

		let gpResults = SimulationResults(values: grossProfitValues[periodIndex])
		gpStats[period] = gpResults.statistics
		gpPctiles[period] = gpResults.percentiles

		let opResults = SimulationResults(values: opIncomeValues[periodIndex])
		opStats[period] = opResults.statistics
		opPctiles[period] = opResults.percentiles
	}

	// Display comprehensive forecast
	print("\nIncome Statement Forecast - 2025")
	print("==================================")

	for quarter in periods {
		print("\n\(quarter.label)")
		print(String(repeating: "-", count: 60))

		// Revenue
		let revS = revenueStats[quarter]!
		let revP = revenuePctiles[quarter]!
		print("Revenue")
		print("  Expected: \(revS.mean.currency(0))")
		print("  Std Dev:  \(revS.stdDev.currency(0)) (CoV: \((revS.stdDev / revS.mean).percent(1)))")
		print("  90% CI:   [\(revP.p5.currency(0)), \(revP.p95.currency(0))]")

		// Gross Profit
		let gpS = gpStats[quarter]!
		let gpP = gpPctiles[quarter]!
		let gpMargin = gpS.mean / revS.mean
		print("\nGross Profit")
		print("  Expected: \(gpS.mean.currency(0)) (\(gpMargin.percent(1)) margin)")
		print("  90% CI:   [\(gpP.p5.currency(0)), \(gpP.p95.currency(0))]")

		// Operating Income
		let opS = opStats[quarter]!
		let opP = opPctiles[quarter]!
		let opMargin = opS.mean / revS.mean
		print("\nOperating Income")
		print("  Expected: \(opS.mean.currency(0)) (\(opMargin.percent(1)) margin)")
		print("  90% CI:   [\(opP.p5.currency(0)), \(opP.p95.currency(0))]")

		// Risk assessment
		let profitProb = opP.p5 > 0 ? 100 : (opP.p25 > 0 ? 75 : (opP.p50 > 0 ? 50 : 25))
		print("\nRisk: Probability of profit ~\(profitProb)%")
	}

// MARK: - GPU-Accelerated Expression Models

	// Pre-compute any constants
	let taxRate = 0.21

	// Define the P&L model using expression builder
	let incomeStatementModel = MonteCarloExpressionModel { builder in
		// Inputs: units, price, cogsPercent, opex
		let units = builder[0]
		let price = builder[1]
		let cogsPercent = builder[2]
		let opex = builder[3]

		// Calculate revenue and costs
		let revenue = units * price
		let cogs = revenue * cogsPercent
		let grossProfit = revenue - cogs
		let ebitda = grossProfit - opex

		// Conditional tax (only pay tax if profitable)
		let isProfitable = ebitda.greaterThan(0.0)
		let tax = isProfitable.ifElse(
			then: ebitda * taxRate,
			else: 0.0
		)

		let netIncome = ebitda - tax

		return netIncome  // Return what we're simulating
	}

	// Set up high-performance simulation
	var gpuSimulation = MonteCarloSimulation(
		iterations: 100_000,  // 10Ã— more iterations than before
		enableGPU: true,
		expressionModel: incomeStatementModel
	)

	// Add input distributions (order matches builder[0], builder[1], etc.)
	gpuSimulation.addInput(SimulationInput(
		name: "Units Sold",
		distribution: DistributionNormal(mean: 10_000, stdDev: 1_000)
	))

	gpuSimulation.addInput(SimulationInput(
		name: "Average Price",
		distribution: DistributionTriangular(low: 95, high: 110, mode: 100)
	))

	gpuSimulation.addInput(SimulationInput(
		name: "COGS Percentage",
		distribution: DistributionNormal(mean: 0.60, stdDev: 0.03)
	))

	gpuSimulation.addInput(SimulationInput(
		name: "Operating Expenses",
		distribution: DistributionNormal(mean: 200_000, stdDev: 20_000)
	))

	// Run simulation
	let gpuResults = try gpuSimulation.run()

	// Display results
	print("\n\nGPU-Accelerated Income Statement Forecast")
	print("==========================================")
	print("Iterations: \(gpuResults.iterations.formatted())")
	print("Compute Time: \(gpuResults.computeTime.formatted(.number.precision(.fractionLength(1)))) ms")
	print("GPU Used: \(gpuResults.usedGPU ? "Yes" : "No")")
	print()
	print("Net Income After Tax:")
	print("  Mean:     \(gpuResults.statistics.mean.currency(0))")
	print("  Median:   \(gpuResults.percentiles.p50.currency(0))")
	print("  Std Dev:  \(gpuResults.statistics.stdDev.currency(0))")
	print("  95% CI:   [\(gpuResults.percentiles.p5.currency(0)), \(gpuResults.percentiles.p95.currency(0))]")
	print()

	// Risk metrics
	let profitableCount = gpuResults.valuesArray.filter { $0 > 0 }.count
	let profitabilityRate = Double(profitableCount) / Double(gpuResults.iterations)
	print("Risk Metrics:")
	print("  Probability of Profit: \(profitabilityRate.percent(1))")
	print("  Value at Risk (5%):    \(gpuResults.percentiles.p5.currency(0))")

</code></pre></details>
<p>â†’ Full API Reference: <a href="https://github.com/jpurnell/BusinessMath/blob/main/Sources/BusinessMath/BusinessMath.docc/4.1-MonteCarloTimeSeriesGuide.md">BusinessMath Docs â€“ 4.1 Monte Carlo Simulation</a></p><p><strong>Modifications to try</strong>:</p><ol><li>Add correlation between drivers (revenue and costs often move together)</li><li>Model mean-reverting growth (growth rate reverts to long-term average)</li><li>Add extreme event scenarios (5% chance of 50% revenue drop)</li><li>Build multi-year forecasts with changing distributions over time</li></ol><hr /><h2>Real-World Application</h2><p>Every CFO, risk manager, and strategic planner uses Monte Carlo:</p><ul><li><strong>Annual budgeting</strong>: â€œWhatâ€™s the 80% confidence interval for EBITDA?â€</li><li><strong>Capital allocation</strong>: â€œHow likely is ROI > 15%?â€</li><li><strong>Risk management</strong>: â€œWhatâ€™s the worst-case revenue in the bottom 5% of scenarios?â€</li><li><strong>Strategic planning</strong>: â€œIf we enter this market, whatâ€™s the probability of profitability by year 3?â€</li></ul><p><strong>CFO use case</strong>: â€œBuild me a 3-year revenue forecast with 10K Monte Carlo iterations. Show P10, P50, P90 scenarios. I need to present to the board with realistic uncertainty bounds.â€</p><p>BusinessMath makes Monte Carlo forecasting programmatic, reproducible, and fast.</p><hr /><p><code>â˜… Insight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></p><p><strong>Why Monte Carlo Beats Scenario Analysis</strong></p><p>Traditional approach: Build 3 scenarios (base, best, worst).</p><p><strong>Problems</strong>:</p><ol><li><strong>No probabilities</strong>: Is â€œbest caseâ€ 90th percentile or 99th?</li><li><strong>Arbitrary combinations</strong>: Best case has high revenue AND low costs (unlikely!)</li><li><strong>Missed interactions</strong>: When revenue is high, costs often are too (correlation ignored)</li></ol><p><strong>Monte Carlo fixes this</strong>:</p><ol><li><strong>Explicit probabilities</strong>: P90 means â€œexceeded 90% of the timeâ€</li><li><strong>Natural combinations</strong>: High revenue scenario automatically samples from the high end of the revenue distribution</li><li><strong>Captures correlation</strong>: Model correlated drivers with copulas or factor models</li></ol><p><strong>The lesson</strong>: Monte Carlo provides a <strong>complete probability distribution</strong>, not just 3 data points.</p><p><code>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></p><hr /><h3>ğŸ“ Development Note</h3><p>The biggest challenge here <strong>balancing ease-of-use with flexibility</strong>. We could have provided:</p><p><strong>Option A</strong>: High-level <code>forecastRevenue(baseAmount, growthDist, periods)</code></p><ul><li>Pro: Very easy to use</li><li>Con: Inflexible (what if growth depends on prior period revenue?)</li></ul><p><strong>Option B</strong>: Low-level sampling with manual loops</p><ul><li>Pro: Maximum flexibility</li><li>Con: Users must write boilerplate for every forecast</li></ul><p>We chose <strong>Option B with helper types</strong> (<code>ProbabilisticDriver</code>, <code>SimulationResults</code>) that handle the tedious parts (sampling, statistics) while leaving control over the simulation logic. Even though itâ€™s a step away from the expressiveness of pure swift functions, the power boost is massive, and while still retaining the benefits of reusability.</p><p><strong>Related Methodology</strong>: <a href="../week-01/02-tue-test-first-development">Test-First Development</a> (Week 1) - We wrote tests comparing Monte Carlo results to analytical solutions (e.g., normal distribution revenue forecast) before implementing.</p><hr /><h2>Next Steps</h2><p><strong>Coming up Wednesday</strong>: <a href="../week-06/02-wed-scenario-analysis">Scenario Analysis - Building discrete scenarios, sensitivity analysis, and tornado diagrams</a>.</p><p><strong>Friday</strong>: Case Study #3 - <a href="../week-06/03-fri-case-study-option-pricing">Option Pricing with Monte Carlo</a>.</p><hr /><p><strong>Series Progress</strong>:</p><ul><li>Week: 6/12</li><li>Posts Published: 20/~48</li><li>Topics Covered: Foundation + Analysis + Operational + Financial Statements + Advanced Modeling + <strong>Simulation (starting)</strong></li><li>Playgrounds: 19 available</li></ul></p><hr /><div style="margin-top: 2em"><p class="blurb" style="font-style: italic">Tagged with: businessmath, swift, monte-carlo, simulation, forecasting, uncertainty, risk-analysis</p></div></div></div><header><nav class="noPrint navbar navbar-expand-md" style="border-top: 0.01em solid #d5d5d5;"><div class="container-fluid col"><button type="button" class="navbar-toggler btn" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div id="navbarCollapse" class="collapse navbar-collapse"><ul class="navbar-nav mb-2 mb-md-0 col"><li class="nav-item"><a href="mailto:morals.tech.0x@icloud.com" id="email" rel="me" target="_blank" class="nav-link">email</a></li><li class="nav-item"><a href="https://cal.com/jpurnell/15min" id="calendar" rel="me" target="_blank" class="nav-link">calendar</a></li><li class="nav-item"><a href="http://blog.justinpurnell.com" id="blog" rel="me" target="_blank" class="nav-link">blog</a></li><li class="nav-item"><a href="https://github.com/jpurnell" id="github" rel="me" target="_blank" class="nav-link">github</a></li><li class="nav-item"><a href="https://bsky.app/profile/justinpurnell.com" id="bsky" rel="me" target="_blank" class="nav-link">bsky</a></li><li class="nav-item"><a href="https://mastodon.social/@jpurnell" id="mastodon" rel="me" target="_blank" class="nav-link">mastodon</a></li><li class="nav-item"><a href="https://music.apple.com/us/station/justin-purnells-station/ra.u-a475786ae9cc432a1abb70ff757aa95f" id="radio" rel="me" target="_blank" class="nav-link">radio</a></li><li class="nav-item"><a href="https://www.justinpurnell.com/feed.rss" id="rss" rel="me" target="_blank" class="nav-link">rss</a></li><li class="nav-item"><a href="#" id="theme-toggle" rel="me" target="_blank" class="nav-link">theme</a></li></ul></div></div></nav></header><script src="/js/theme-toggle.js"></script></div><script src="/js/bootstrap.bundle.min.js"></script><script src="/js/syntax-highlighting.js"></script></body></html>