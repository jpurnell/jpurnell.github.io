<!doctype html><html lang="en" data-bs-theme="light"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Part 21 of 12-Week BusinessMath Series"><meta name="author" content="Justin Purnell"><meta name="generator" content="Ignite v0.2.1"><title>GPU-Accelerated Monte Carlo: Expression Models and Performance</title><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/prism-default-dark.css" rel="stylesheet"><link href="/css/bootstrap-icons.min.css" rel="stylesheet"><link href="https://www.justinpurnell.com/BusinessMath/week-06/02-mon-gpu-acceleration" rel="canonical"><link href="/feed.rss" rel="alternate" type="application/rss+xml" title="Justin Purnell"><meta property="og:site_name" content="Justin Purnell"><meta property="og:title" content="GPU-Accelerated Monte Carlo: Expression Models and Performance"><meta property="twitter:title" content="GPU-Accelerated Monte Carlo: Expression Models and Performance"><meta property="og:description" content="GPU-Accelerated Monte Carlo: Expression Models and Performance"><meta name="twitter:description" content="GPU-Accelerated Monte Carlo: Expression Models and Performance"><meta property="og:url" content="https://www.justinpurnell.com/BusinessMath/week-06/02-mon-gpu-acceleration"><meta name="twitter:domain" content="justinpurnell.com"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:dnt" content="on"><meta name="description" content="**Entrepreneurial Strategist & Builder:** Justin Purnell is the Founder of **Ledge Partners**, dedicated to acquiring and leading profitable businesses. His foundation is built on seven years at **Goldman Sachs** as a high yield credit analyst, where he published over **400 research reports** and advised C-level executives.
**Product Innovation and Scale:** He led the complete **re-platforming of technology supporting over 70 e-commerce sites** globally as Head of Product at **Hotels at Home**. He actively builds technical solutions, including pioneering **AI-powered software** to automate product data generation and designing a Swift middleware prototype that cut vendor onboarding time from **four months to two weeks**.
**Driving Financial and Organizational Results:** At **NBCUniversal's Seeso**, he directed product operations and retention initiatives that resulted in a **40% increase in customer Lifetime Value**. He is adept at mobilizing cross-functional teams, having successfully stepped in to **referee a dispute** between NBC and a third-party vendor to foster consensus and launch the Content Commerce platform.
**Creative and Governance Leadership:** Justin combines corporate rigor with creative experience, having directed the Webby-awarded web series **Smart Girls at the Party** and serving as a founding producer for **UCBcomedy.com**. He maintains significant governance roles, including serving as **President of the Princeton University Class of 2000** (1,143 alumni) and managing its annual giving campaigns."><meta name="fediverse:creator" content="@jpurnell@mastodon.social"><meta name="tags" content="Product Manager, Strategy, Product Leader, Goldman Sachs, NBCUniversal, Hotels at Home, AI, LLM, Digital Transformation, e-commerce, Swift, Consensus Leadership, Leadership, Agile, DevOps, Continuous Integration, Continuous Deployment, Cloud, Data Science, Machine Learning, Python, JavaScript, Front-end, Back-end, Full-stack, Responsive Design, Accessibility, SEO, Content Strategy, User Experience, User Interface, Design, Agile, Product Strategy, Technical Strategy"><script>	(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
	new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
	j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
	'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
	})(window,document,'script','dataLayer','GTM-K3TZS8J');</script><link href="/css/main.css" rel="stylesheet"></head><body><div class="col-sm-10 mx-auto"><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K3TZS8J"
	height="0" width="0" style="display:none;visibility:hidden"></iframe>
<header><nav class="noPrint navbar navbar-expand-md" style="border-bottom: 0.01em solid #d5d5d5;"><div class="container-fluid col"><button type="button" class="navbar-toggler btn" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div id="navbarCollapse" class="collapse navbar-collapse"><ul class="navbar-nav mb-2 mb-md-0 col"><li class="nav-item"><a href="/" class="nav-link">Home</a></li><li class="nav-item"><a href="/about" class="nav-link">About</a></li><li class="nav-item"><a href="/cv" class="nav-link">CV</a></li><li class="nav-item"><a href="/business-math" class="nav-link">BusinessMath</a></li><li class="nav-item"><a href="/next" class="nav-link">NeXT</a></li></ul></div></div></nav></header><div class="row"><div class="col"><h1 class="mainTitle">GPU-Accelerated Monte Carlo: Expression Models and Performance</h1><div style="margin-bottom: 2em"><p class="blogDateTime" style="margin-left: 1em">BusinessMath Quarterly Series</p><p class="blogDateTime" style="margin-left: 1em">20 min read</p></div><p class="mx-auto blurb" style="width: 70%; max-width: 800px"><p><strong>Part 21 of 12-Week BusinessMath Series</strong></p><hr /><h2>What You‚Äôll Learn</h2><ul><li>Understanding GPU acceleration for Monte Carlo simulations (10-100√ó speedup)</li><li>What can and cannot be modeled with <code>MonteCarloExpressionModel</code></li><li>Converting closure-based models to GPU-compatible expression models</li><li>When to use CPU vs GPU execution</li><li>Expression builder DSL for natural mathematical syntax</li><li>Practical patterns for financial models</li></ul><hr /><h2>The Problem</h2><p>You‚Äôve built a Monte Carlo simulation with custom logic:</p><pre><code class="language-swift">var simulation = MonteCarloSimulation(iterations: 100_000) { inputs in
    let returns = simulatePortfolioYear(
        targetReturn: inputs[0],
        riskTolerance: inputs[1],
        marketScenario: inputs[2]
    )
    return returns
}
</code></pre><p><strong>Result</strong>: ‚ö†Ô∏è Warning: ‚ÄúCould not compile model for GPU (model uses unsupported operations or is closure-based)‚Äù</p><p>Your simulation runs on CPU, taking 45 seconds for 100,000 iterations. <strong>You want GPU acceleration for 10√ó speedup</strong>, but the API has non-obvious limitations.</p><hr /><h2>The Solution</h2><p>BusinessMath provides two Monte Carlo APIs:</p><ol><li><strong>Closure-Based Models</strong> (CPU only)<ul><li>Natural Swift closures with any custom logic</li><li>Calls external functions, uses loops, conditionals</li><li>Flexible but cannot compile to GPU bytecode</li></ul></li><li><strong>Expression-Based Models</strong> (GPU-accelerated)<ul><li>Uses <code>MonteCarloExpressionModel</code> DSL</li><li>Restricted to mathematical expressions</li><li>Compiles to Metal GPU shaders for 10-100√ó speedup</li></ul></li></ol><p><strong>The key insight</strong>: GPU shaders require static, compilable operations. Custom functions like <code>simulatePortfolioYear()</code> cannot run on GPU‚Äîthey must be rewritten as mathematical expressions.</p><hr /><h2>What CAN Be Modeled (GPU-Compatible)</h2><h3>Core Supported Operations</h3><p><code>MonteCarloExpressionModel</code> supports all standard mathematical operations:</p><h4>1. Arithmetic Operations</h4><pre><code class="language-swift">let model = MonteCarloExpressionModel { builder in
    let revenue = builder[0]
    let costs = builder[1]
    let taxRate = builder[2]

    // +, -, *, /
    let profit = revenue - costs
    let netProfit = profit * (1.0 - taxRate)

    return netProfit
}
</code></pre><h4>2. Mathematical Functions</h4><pre><code class="language-swift">let model = MonteCarloExpressionModel { builder in
    let stockPrice = builder[0]
    let volatility = builder[1]
    let time = builder[2]

    // sqrt, log, exp, abs, power
    let drift = stockPrice.exp()
    let diffusion = volatility * time.sqrt()
    let finalPrice = (drift + diffusion).abs()

    return finalPrice
}
</code></pre><h4>3. Trigonometric Functions</h4><pre><code class="language-swift">let model = MonteCarloExpressionModel { builder in
    let angle = builder[0]
    let amplitude = builder[1]

    // sin, cos, tan
    let wave = amplitude * angle.sin()

    return wave
}
</code></pre><h4>4. Comparison Operations</h4><pre><code class="language-swift">let model = MonteCarloExpressionModel { builder in
    let price = builder[0]
    let strike = builder[1]

    // greaterThan, lessThan, equal, etc.
    // Returns 1.0 (true) or 0.0 (false)
    let isInTheMoney = price.greaterThan(strike)

    return isInTheMoney
}
</code></pre><h4>5. Conditional Expressions (Ternary)</h4><pre><code class="language-swift">let model = MonteCarloExpressionModel { builder in
    let demand = builder[0]
    let capacity = builder[1]
    let price = builder[2]

    // condition.ifElse(then: value1, else: value2)
    let exceedsCapacity = demand.greaterThan(capacity)
    let actualSales = exceedsCapacity.ifElse(then: capacity, else: demand)
    let revenue = actualSales * price

    return revenue
}
</code></pre><h4>6. Min/Max Operations</h4><pre><code class="language-swift">let model = MonteCarloExpressionModel { builder in
    let profit = builder[0]
    let targetProfit = builder[1]

    // min, max
    let cappedProfit = profit.min(targetProfit)
    let nonNegative = profit.max(0.0)

    return nonNegative
}
</code></pre><h3>Complete Example: Option Pricing</h3><pre><code class="language-swift">// Black-Scholes call option payoff (GPU-compatible!)
let callOption = MonteCarloExpressionModel { builder in
    let spotPrice = builder[0]
    let strike = builder[1]
    let riskFreeRate = builder[2]
    let volatility = builder[3]
    let time = builder[4]
    let randomNormal = builder[5]

    // Geometric Brownian Motion
    let drift = (riskFreeRate - volatility * volatility * 0.5) * time
    let diffusion = volatility * time.sqrt() * randomNormal
    let finalPrice = spotPrice * (drift + diffusion).exp()

    // Call option payoff: max(S - K, 0)
    let payoff = (finalPrice - strike).max(0.0)

    return payoff
}

var simulation = MonteCarloSimulation(
    iterations: 100_000,
    enableGPU: true,
    expressionModel: callOption
)

simulation.addInput(SimulationInput(name: "SpotPrice", distribution: DistributionNormal(100, 0)))
simulation.addInput(SimulationInput(name: "Strike", distribution: DistributionNormal(100, 0)))
simulation.addInput(SimulationInput(name: "RiskFreeRate", distribution: DistributionNormal(0.05, 0)))
simulation.addInput(SimulationInput(name: "Volatility", distribution: DistributionNormal(0.20, 0)))
simulation.addInput(SimulationInput(name: "Time", distribution: DistributionNormal(1.0, 0)))
simulation.addInput(SimulationInput(name: "RandomNormal", distribution: DistributionNormal(0, 1)))

let results = try simulation.run()

print("Call Option Value: $\(results.statistics.mean.number(2))")
print("Executed on: \(results.usedGPU ? "GPU ‚ö°" : "CPU")")
// Output: Call Option Value: $10.45
//         Executed on: GPU ‚ö°
</code></pre><hr /><h2>Reusable Expression Functions</h2><h3>The Solution to ‚ÄúExternal Functions‚Äù</h3><p>While arbitrary Swift functions can‚Äôt compile to GPU, you <strong>can</strong> define reusable expression functions using the same DSL:</p><pre><code class="language-swift">import BusinessMath

// Define a reusable tax calculation function
let calculateTax = ExpressionFunction(inputs: 2) { builder in
    let income = builder[0]
    let rate = builder[1]
    return income * rate
}

// Use it in a model (compiles to GPU!)
let profitModel = MonteCarloExpressionModel { builder in
    let revenue = builder[0]
    let costs = builder[1]
    let taxRate = builder[2]

    let profit = revenue - costs
    let taxes = calculateTax.call(profit, taxRate)  // ‚úì Reusable!

    return profit - taxes
}
</code></pre><p><strong>Key Benefit</strong>: Code reuse with GPU compatibility. The function is ‚Äúinlined‚Äù during expression tree construction.</p><h3>Built-In Financial Function Library</h3><p>BusinessMath includes common financial functions:</p><pre><code class="language-swift">let model = MonteCarloExpressionModel { builder in
    let initialInvestment = builder[0]
    let annualReturn = builder[1]
    let taxRate = builder[2]
    let years = builder[3]

    // Use pre-built financial functions
    let futureValue = FinancialFunctions.compoundGrowth.call(
        initialInvestment,
        annualReturn,
        years
    )

    let afterTaxValue = FinancialFunctions.afterTax.call(
        futureValue,
        taxRate
    )

    return afterTaxValue
}
</code></pre><p><strong>Available Functions</strong>:</p><ul><li><code>FinancialFunctions.percentChange(old, new)</code></li><li><code>FinancialFunctions.compoundGrowth(principal, rate, periods)</code></li><li><code>FinancialFunctions.presentValue(futureValue, rate, periods)</code></li><li><code>FinancialFunctions.afterTax(amount, taxRate)</code></li><li><code>FinancialFunctions.blackScholesDrift(r, œÉ, t)</code></li><li><code>FinancialFunctions.blackScholesDiffusion(œÉ, t, Z)</code></li><li><code>FinancialFunctions.sharpeRatio(return, riskFree, volatility)</code></li><li><code>FinancialFunctions.valueAtRisk(mean, stdDev, zScore)</code></li><li><code>FinancialFunctions.portfolioVariance2Asset(w1, w2, var1, var2, covar)</code></li><li><code>FinancialFunctions.diversificationRatio2Asset(...)</code></li></ul><hr /><h2>Advanced GPU Features (NEW!) üöÄ</h2><p>The following advanced features enable sophisticated financial models while maintaining GPU compatibility:</p><h3>1. Fixed-Size Array Operations</h3><p><strong>Use fixed-size arrays for portfolio calculations</strong>:</p><pre><code class="language-swift">let portfolioModel = MonteCarloExpressionModel { builder in
    // 5-asset portfolio
    let weights = builder.array([0, 1, 2, 3, 4])

    // Expected returns
    let returns = builder.array([0.08, 0.10, 0.12, 0.09, 0.11])

    // Portfolio return: dot product
    let portfolioReturn = weights.dot(returns)

    // Validation: weights sum to 1
    let totalWeight = weights.sum()

    return portfolioReturn
}
</code></pre><p><strong>Supported Array Operations</strong>:</p><ul><li><strong>Reduction</strong>: <code>sum()</code>, <code>product()</code>, <code>min()</code>, <code>max()</code>, <code>mean()</code></li><li><strong>Element-wise</strong>: <code>map()</code>, <code>zipWith()</code></li><li><strong>Linear algebra</strong>: <code>dot()</code>, <code>norm()</code>, <code>normalize()</code></li><li><strong>Statistical</strong>: <code>variance()</code>, <code>stdDev()</code></li></ul><p><strong>Example - Weighted Average</strong>:</p><pre><code class="language-swift">let model = MonteCarloExpressionModel { builder in
    let values = builder.array([0, 1, 2, 3, 4])
    let weights = builder.array([0.1, 0.2, 0.3, 0.2, 0.2])

    let weightedAvg = values.zipWith(weights) { v, w in v * w }.sum()

    return weightedAvg
}
</code></pre><hr /><h3>2. Loop Unrolling (Fixed-Size Loops)</h3><p><strong>Multi-period calculations with compile-time unrolling</strong>:</p><pre><code class="language-swift">let compoundingModel = MonteCarloExpressionModel { builder in
    let principal = builder[0]
    let annualRate = builder[1]

    // Compound for 10 years (unrolled at compile time)
    let finalValue = builder.forEach(0..<10, initial: principal) { year, value in
        return value * (1.0 + annualRate)
    }

    return finalValue
}
</code></pre><p><strong>How It Works</strong>:</p><ul><li>Loop is <strong>completely unrolled</strong> at compile time</li><li>Generates 10 explicit operations (no runtime iteration)</li><li>Compiles to GPU bytecode</li><li><strong>Zero performance overhead</strong> vs inline code</li></ul><p><strong>Example - NPV with Growing Cash Flows</strong>:</p><pre><code class="language-swift">let npvModel = MonteCarloExpressionModel { builder in
    let initialCost = builder[0]
    let annualCashFlow = builder[1]
    let discountRate = builder[2]
    let growthRate = builder[3]

    // Calculate NPV for 5 years
    let npv = builder.forEach(1...5, initial: -initialCost) { year, accumulated in
        let cf = annualCashFlow * (1.0 + growthRate).power(Double(year - 1))
        let pv = cf / (1.0 + discountRate).power(Double(year))
        return accumulated + pv
    }

    return npv
}
</code></pre><p><strong>Practical Limit</strong>: Up to ~20 iterations recommended (compile time grows linearly)</p><hr /><h3>3. Matrix Operations (Portfolio Optimization)</h3><p><strong>Fixed-size matrices for covariance calculations</strong>:</p><pre><code class="language-swift">let portfolioVarianceModel = MonteCarloExpressionModel { builder in
    let w1 = builder[0]
    let w2 = builder[1]
    let w3 = 1.0 - w1 - w2  // Budget constraint

    let weights = builder.array([w1, w2, w3])

    // 3√ó3 covariance matrix
    let covariance = builder.matrix(rows: 3, cols: 3, values: [
        [0.04, 0.01, 0.02],
        [0.01, 0.05, 0.015],
        [0.02, 0.015, 0.03]
    ])

    // Portfolio variance: w^T Œ£ w (quadratic form)
    let variance = covariance.quadraticForm(weights)

    return variance.sqrt()  // Return volatility
}
</code></pre><p><strong>Supported Matrix Operations</strong>:</p><ul><li><strong>Matrix-vector</strong>: <code>multiply(vector)</code>, <code>quadraticForm(vector)</code></li><li><strong>Matrix-matrix</strong>: <code>multiply(matrix)</code>, <code>add(matrix)</code>, <code>transpose()</code></li><li><strong>Statistical</strong>: <code>trace()</code>, <code>diagonal()</code></li><li><strong>Accessors</strong>: <code>matrix[row, col]</code></li></ul><p><strong>Example - Portfolio Diversification</strong>:</p><pre><code class="language-swift">let diversificationModel = MonteCarloExpressionModel { builder in
    let weights = builder.array([0, 1, 2])

    let covariance = builder.matrix(rows: 3, cols: 3, values: [ ... ])

    // Portfolio variance
    let portfolioVar = covariance.quadraticForm(weights)

    // Individual asset variances
    let assetVars = covariance.diagonal()

    // Weighted sum of individual variances
    let undiversifiedVar = weights.zipWith(assetVars) { w, v in w * w * v }.sum()

    // Diversification benefit
    let diversificationBenefit = (undiversifiedVar - portfolioVar) / undiversifiedVar

    return diversificationBenefit
}
</code></pre><hr /><h3>4. Complete Example: All Features Combined</h3><p><strong>Realistic portfolio model using arrays, loops, and matrices</strong>:</p><pre><code class="language-swift">let completeModel = MonteCarloExpressionModel { builder in
    // Inputs: 5 asset weights
    let weights = builder.array([0, 1, 2, 3, 4])

    // Expected returns
    let returns = builder.array([0.08, 0.10, 0.12, 0.09, 0.11])

    // 5√ó5 covariance matrix
    let covariance = builder.matrix(rows: 5, cols: 5, values: [
        [0.0400, 0.0100, 0.0150, 0.0080, 0.0120],
        [0.0100, 0.0625, 0.0200, 0.0100, 0.0150],
        [0.0150, 0.0200, 0.0900, 0.0180, 0.0220],
        [0.0080, 0.0100, 0.0180, 0.0361, 0.0100],
        [0.0120, 0.0150, 0.0220, 0.0100, 0.0484]
    ])

    // 1. Portfolio return (array operation)
    let portfolioReturn = weights.dot(returns)

    // 2. Portfolio volatility (matrix operation)
    let portfolioVol = covariance.quadraticForm(weights).sqrt()

    // 3. Sharpe ratio
    let riskFreeRate = 0.03
    let sharpe = (portfolioReturn - riskFreeRate) / portfolioVol

    // 4. 10-year wealth accumulation (loop unrolling)
    let initialInvestment = 1_000_000.0
    let finalWealth = builder.forEach(0..<10, initial: initialInvestment) { year, wealth in
        wealth * (1.0 + portfolioReturn)
    }

    return finalWealth
}
</code></pre><p><strong>Performance</strong>: 100,000 iterations in ~0.8s on M2 Max GPU ‚ö°</p><hr /><h2>What CANNOT Be Modeled (CPU Only)</h2><h3>Truly Unsupported Operations</h3><p>These patterns <strong>still cannot</strong> compile to GPU:</p><h4>1. ‚ùå Swift Functions (Closure-Based)</h4><pre><code class="language-swift">// WRONG: Cannot call closure-based Swift functions on GPU
func calculateTax(_ income: Double, _ rate: Double) -> Double {
    return income * rate
}

let model = MonteCarloExpressionModel { builder in
    let revenue = builder[0]
    let taxRate = builder[1]
    return calculateTax(revenue, taxRate)  // ‚ùå Won't compile!
}
</code></pre><p><strong>Fix Option 1</strong>: Inline the logic</p><pre><code class="language-swift">// CORRECT: Inline the calculation
let model = MonteCarloExpressionModel { builder in
    let revenue = builder[0]
    let taxRate = builder[1]
    return revenue * taxRate  // ‚úì GPU-compatible
}
</code></pre><p><strong>Fix Option 2 (Better)</strong>: Use ExpressionFunction for reusability</p><pre><code class="language-swift">// BEST: Define reusable expression function
let calculateTax = ExpressionFunction(inputs: 2) { builder in
    let income = builder[0]
    let rate = builder[1]
    return income * rate
}

let model = MonteCarloExpressionModel { builder in
    let revenue = builder[0]
    let taxRate = builder[1]
    let taxes = calculateTax.call(revenue, taxRate)  // ‚úì GPU-compatible!
    return revenue - taxes
}
</code></pre><h4>2. ‚úÖ Fixed-Size Loops</h4><pre><code class="language-swift">// OLD: Loops were not supported
// NEW: Fixed-size loops are unrolled at compile time!

// CORRECT: Use forEach for fixed-size loops
let model = MonteCarloExpressionModel { builder in
    let sum = builder.forEach(0..<10, initial: 0.0) { i, accumulated in
        accumulated + builder[i]
    }
    return sum
}

// Also works: array operations
let model2 = MonteCarloExpressionModel { builder in
    let values = builder.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
    return values.sum()
}
</code></pre><p><strong>Limitation</strong>: Loop bounds must be <strong>compile-time constants</strong>. Variable loop bounds still require CPU.</p><pre><code class="language-swift">// ‚ùå Still not supported: Variable loop bounds
let badModel = MonteCarloExpressionModel { builder in
    let n = Int(builder[0])  // Runtime value
    var sum = 0.0
    for i in 0...(n - 1) {  // ‚ùå n is not known at compile time!
        sum += builder[i + 1]
    }
    return sum
}
</code></pre><h4>3. ‚úÖ Fixed-Size Arrays</h4><pre><code class="language-swift">// OLD: Dynamic arrays were not supported
// NEW: Fixed-size arrays work with GPU!

// CORRECT: Use ExpressionArray
let model = MonteCarloExpressionModel { builder in
    let values = builder.array([0, 1, 2])
    return values.sum()  // ‚úì GPU-compatible!
}

// Supported operations: sum, product, min, max, mean, dot, etc.
let portfolioModel = MonteCarloExpressionModel { builder in
    let weights = builder.array([0, 1, 2])
    let returns = builder.array([0.08, 0.10, 0.12])
    return weights.dot(returns)  // ‚úì Portfolio return
}
</code></pre><p><strong>Limitation</strong>: Array size must be <strong>compile-time constant</strong>. Dynamic arrays still require CPU.</p><pre><code class="language-swift">// ‚ùå Still not supported: Dynamic arrays
let badModel = MonteCarloExpressionModel { builder in
    let n = Int(builder[0])  // Runtime value
    var values: [ExpressionProxy] = []
    for i in 0...(n - 1) {  // ‚ùå Cannot build array dynamically!
        values.append(builder[i])
    }
    return builder.array(values).sum()
}
</code></pre><h4>4. ‚ùå External State/Variables</h4><pre><code class="language-swift">// WRONG: Cannot access external variables
let globalTaxRate = 0.21

let model = MonteCarloExpressionModel { builder in
    let profit = builder[0]
    return profit * (1.0 - globalTaxRate)  // ‚ùå External reference!
}
</code></pre><p><strong>Fix</strong>: Pass as input</p><pre><code class="language-swift">// CORRECT: Pass as simulation input
let model = MonteCarloExpressionModel { builder in
    let profit = builder[0]
    let taxRate = builder[1]  // From simulation input
    return profit * (1.0 - taxRate)  // ‚úì GPU-compatible
}
</code></pre><h4>5. ‚ùå Complex Control Flow</h4><pre><code class="language-swift">// WRONG: Complex if-else chains
let model = MonteCarloExpressionModel { builder in
    let revenue = builder[0]

    if revenue < 100_000 {
        return revenue * 0.10
    } else if revenue < 500_000 {
        return revenue * 0.15
    } else {
        return revenue * 0.20
    }  // ‚ùå Cannot use if-else!
}
</code></pre><p><strong>Fix</strong>: Use nested ternary expressions</p><pre><code class="language-swift">// CORRECT: Nested ifElse
let model = MonteCarloExpressionModel { builder in
    let revenue = builder[0]

    let tier1 = revenue.lessThan(100_000)
    let tier2 = revenue.lessThan(500_000)

    let rate = tier1.ifElse(
        then: 0.10,
        else: tier2.ifElse(then: 0.15, else: 0.20)
    )

    return revenue * rate  // ‚úì GPU-compatible
}
</code></pre><hr /><h2>Converting Closure-Based to Expression-Based</h2><h3>Pattern 1: Simple Calculation</h3><p><strong>Closure-Based (CPU only)</strong>:</p><pre><code class="language-swift">var simulation = MonteCarloSimulation(iterations: 100_000, enableGPU: false) { inputs in
    let revenue = inputs[0]
    let costs = inputs[1]
    let profit = revenue - costs
    return profit
}
</code></pre><p><strong>Expression-Based (GPU-accelerated)</strong>:</p><pre><code class="language-swift">let profitModel = MonteCarloExpressionModel { builder in
    let revenue = builder[0]
    let costs = builder[1]
    return revenue - costs
}

var simulation = MonteCarloSimulation(
    iterations: 100_000,
    enableGPU: true,
    expressionModel: profitModel
)
</code></pre><p><strong>Speedup</strong>: 2-3√ó for simple models</p><hr /><h3>Pattern 2: Conditional Logic</h3><p><strong>Closure-Based (CPU only)</strong>:</p><pre><code class="language-swift">var simulation = MonteCarloSimulation(iterations: 100_000, enableGPU: false) { inputs in
    let demand = inputs[0]
    let capacity = inputs[1]
    let price = inputs[2]

    let actualSales = demand > capacity ? capacity : demand
    return actualSales * price
}
</code></pre><p><strong>Expression-Based (GPU-accelerated)</strong>:</p><pre><code class="language-swift">let revenueModel = MonteCarloExpressionModel { builder in
    let demand = builder[0]
    let capacity = builder[1]
    let price = builder[2]

    let exceedsCapacity = demand.greaterThan(capacity)
    let actualSales = exceedsCapacity.ifElse(then: capacity, else: demand)

    return actualSales * price
}

var simulation = MonteCarloSimulation(
    iterations: 100_000,
    enableGPU: true,
    expressionModel: revenueModel
)
</code></pre><p><strong>Speedup</strong>: 5-10√ó for models with conditionals</p><hr /><h3>Pattern 3: Multi-Period Compounding</h3><p><strong>Closure-Based (CPU only)</strong> - Uses loop:</p><pre><code class="language-swift">var simulation = MonteCarloSimulation(iterations: 100_000, enableGPU: false) { inputs in
    let initialValue = inputs[0]
    let growthRate = inputs[1]
    let periods = 5

    var value = initialValue
    for _ in 0...(periods - 1) {
        value = value * (1.0 + growthRate)
    }
    return value
}
</code></pre><p><strong>Expression-Based (GPU-accelerated)</strong> - Explicit compounding:</p><pre><code class="language-swift">let compoundingModel = MonteCarloExpressionModel { builder in
    let initialValue = builder[0]
    let growthRate = builder[1]

    // Explicit 5-period compounding
    let growthFactor = (1.0 + growthRate)
    let finalValue = initialValue * growthFactor.power(5.0)

    return finalValue
}

var simulation = MonteCarloSimulation(
    iterations: 100_000,
    enableGPU: true,
    expressionModel: compoundingModel
)
</code></pre><p><strong>Speedup</strong>: 8-15√ó for mathematical models</p><hr /><h3>Pattern 4: Custom Function Library</h3><p><strong>Build Your Own Reusable Functions</strong>:</p><pre><code class="language-swift">// Define your business logic once
struct MyFinancialFunctions {
    static let grossProfit = ExpressionFunction(inputs: 3) { builder in
        let revenue = builder[0]
        let cogs = builder[1]
        let operatingExpenses = builder[2]
        return revenue - cogs - operatingExpenses
    }

    static let netProfit = ExpressionFunction(inputs: 2) { builder in
        let grossProfit = builder[0]
        let taxRate = builder[1]
        return grossProfit * (1.0 - taxRate)
    }

    static let returnOnEquity = ExpressionFunction(inputs: 2) { builder in
        let netIncome = builder[0]
        let equity = builder[1]
        return netIncome / equity
    }
}

// Use across multiple models (all GPU-compatible!)
let incomeStatementModel = MonteCarloExpressionModel { builder in
    let revenue = builder[0]
    let cogs = builder[1]
    let opex = builder[2]
    let taxRate = builder[3]

    let gross = MyFinancialFunctions.grossProfit.call(revenue, cogs, opex)
    let net = MyFinancialFunctions.netProfit.call(gross, taxRate)

    return net
}

let roeModel = MonteCarloExpressionModel { builder in
    let netIncome = builder[0]
    let equity = builder[1]

    let roe = MyFinancialFunctions.returnOnEquity.call(netIncome, equity)

    return roe
}
</code></pre><p><strong>Speedup</strong>: Same as inline code (functions are substituted at compile time)</p><hr /><hr /><h3>Pattern 5: Cannot Convert (Stay on CPU)</h3><p><strong>Closure-Based (CPU only)</strong> - Complex external function with dynamic logic:</p><pre><code class="language-swift">// External function with complex logic
func calculateProjectNPV(
    cashFlows: [Double],
    discountRate: Double,
    riskAdjustment: Double
) -> Double {
    var npv = 0.0
    for (year, cf) in cashFlows.enumerated() {
        let adjustedRate = discountRate + riskAdjustment * Double(year)
        npv += cf / pow(1.0 + adjustedRate, Double(year + 1))
    }
    return npv
}

var simulation = MonteCarloSimulation(iterations: 10_000, enableGPU: false) { inputs in
    let initialCost = inputs[0]
    let annualRevenue = inputs[1]
    let discountRate = inputs[2]

    let cashFlows = [
        -initialCost,
        annualRevenue,
        annualRevenue * 1.1,
        annualRevenue * 1.2,
        annualRevenue * 1.3
    ]

    return calculateProjectNPV(
        cashFlows: cashFlows,
        discountRate: discountRate,
        riskAdjustment: 0.02
    )
}
</code></pre><p><strong>Cannot convert</strong>: This requires dynamic arrays, loops with variable iteration counts, and external function calls. <strong>Solution</strong>: Accept CPU execution or redesign to use fixed expressions.</p><hr /><h2>Performance Comparison</h2><h3>Real-World Benchmarks (M2 Max, 100K iterations)</h3><table><thead><th>Model Complexity</th><th>Closure (CPU)</th><th>Expression (GPU)</th><th>Speedup</th></thead><tbody><tr><td>Simple (2-5 ops)</td><td>0.8s</td><td>0.4s</td><td><strong>2√ó</strong></td></tr><tr><td>Medium (10-15 ops)</td><td>3.2s</td><td>0.4s</td><td><strong>8√ó</strong></td></tr><tr><td>Complex (20+ ops)</td><td>12.5s</td><td>0.6s</td><td><strong>21√ó</strong></td></tr><tr><td>Option Pricing</td><td>8.7s</td><td>0.5s</td><td><strong>17√ó</strong></td></tr><tr><td>Portfolio VaR</td><td>45.2s</td><td>2.1s</td><td><strong>22√ó</strong></td></tr></tbody></table><p><strong>Key Insight</strong>: GPU overhead (buffer allocation, data transfer) is ~0.3s regardless of complexity. Simple models see modest gains, but complex models achieve dramatic speedups.</p><hr /><h2>When to Use Each Approach</h2><h3>Use Closure-Based (CPU) When:</h3><ol><li><strong>Small simulations</strong> (< 10,000 iterations)<ul><li>GPU overhead dominates, CPU is faster</li></ul></li><li><strong>Custom logic required</strong><ul><li>External functions</li><li>Loops with variable bounds</li><li>Array operations</li><li>Complex control flow</li></ul></li><li><strong>Rapid prototyping</strong><ul><li>Natural Swift syntax</li><li>Full language features</li><li>Easier debugging</li></ul></li><li><strong>Correlated inputs</strong><ul><li>GPU doesn‚Äôt support Iman-Conover correlation</li><li>CPU required for <code>correlationMatrix</code></li></ul></li></ol><h3>Use Expression-Based (GPU) When:</h3><ol><li><strong>Large simulations</strong> (‚â• 10,000 iterations)<ul><li>GPU parallelism shines</li></ul></li><li><strong>Mathematical models</strong><ul><li>Arithmetic, functions, comparisons</li><li>Fixed-size expressions</li><li>No external dependencies</li></ul></li><li><strong>Production performance critical</strong><ul><li>Real-time risk systems</li><li>High-frequency rebalancing</li><li>Large-scale backtests</li></ul></li><li><strong>Repeated execution</strong><ul><li>Model compiled once, reused</li><li>Amortize compilation cost</li></ul></li></ol><hr /><h2>Practical Example: Portfolio Sharpe Ratio</h2><h3>Closure-Based (Flexible, CPU)</h3><pre><code class="language-swift">import BusinessMath

func portfolioSharpe(
    weights: [Double],
    returns: [Double],
    covariance: [[Double]]
) -> Double {
    // Complex matrix operations, loops
    var portfolioReturn = 0.0
    for i in 0...(weights.count - 1) {
        portfolioReturn += weights[i] * returns[i]
    }

    var portfolioVar = 0.0
    for i in 0...(weights.count - 1) {
        for j in 0...(weights.count - 1) {
            portfolioVar += weights[i] * weights[j] * covariance[i][j]
        }
    }

    let portfolioStdDev = sqrt(portfolioVar)
    return portfolioReturn / portfolioStdDev
}

var simulation = MonteCarloSimulation(iterations: 10_000, enableGPU: false) { inputs in
    let asset1Weight = inputs[0]
    let asset2Weight = inputs[1]
    let asset3Weight = 1.0 - asset1Weight - asset2Weight

    let weights = [asset1Weight, asset2Weight, asset3Weight]
    let returns = [0.10, 0.12, 0.08]
    let cov = [
        [0.04, 0.01, 0.02],
        [0.01, 0.05, 0.015],
        [0.02, 0.015, 0.03]
    ]

    return portfolioSharpe(weights: weights, returns: returns, covariance: cov)
}
</code></pre><p><strong>Runtime</strong>: 4.2s for 10,000 iterations</p><h3>Expression-Based (Fast, GPU) - Simplified 2-Asset</h3><pre><code class="language-swift">// For 2-asset case, can express without loops
let sharpeModel = MonteCarloExpressionModel { builder in
    let weight1 = builder[0]
    let weight2 = 1.0 - weight1  // Budget constraint

    // Expected returns
    let return1 = 0.10
    let return2 = 0.12
    let portfolioReturn = weight1 * return1 + weight2 * return2

    // Variance (2√ó2 covariance)
    let var1 = 0.04
    let var2 = 0.05
    let cov12 = 0.01

    let term1 = weight1 * weight1 * var1
    let term2 = weight2 * weight2 * var2
    let term3 = 2.0 * weight1 * weight2 * cov12

    let portfolioVar = term1 + term2 + term3
    let portfolioStdDev = portfolioVar.sqrt()

    return portfolioReturn / portfolioStdDev
}

var simulation = MonteCarloSimulation(
    iterations: 100_000,  // 10√ó more iterations!
    enableGPU: true,
    expressionModel: sharpeModel
)
</code></pre><p><strong>Runtime</strong>: 0.5s for 100,000 iterations (84√ó faster, 10√ó more iterations!)</p><p><strong>Tradeoff</strong>: GPU version limited to 2-3 assets (fixed expressions). CPU version handles any number (dynamic loops).</p><hr /><h2>Best Practices</h2><h3>1. Start with Closures, Optimize to Expressions</h3><pre><code class="language-swift">// Phase 1: Prototype with closure (fast development)
var simulation = MonteCarloSimulation(iterations: 1_000, enableGPU: false) { inputs in
    // Your complex logic here
    return calculateSomething(inputs)
}

// Phase 2: Profile and identify bottlenecks
// Phase 3: Convert hot paths to expression models
</code></pre><h3>2. Use <code>evaluate()</code> for Testing</h3><pre><code class="language-swift">let model = MonteCarloExpressionModel { builder in
    let revenue = builder[0]
    let costs = builder[1]
    return revenue - costs
}

// Test model before running full simulation
let testResult = try model.evaluate(inputs: [1_000_000, 700_000])
print("Test result: $\(testResult)")  // $300,000
</code></pre><h3>3. Check GPU Usage</h3><pre><code class="language-swift">let results = try simulation.run()

if results.usedGPU {
    print("‚úì GPU acceleration active")
} else {
    print("‚ö†Ô∏è Running on CPU (check model compatibility)")
}
</code></pre><h3>4. Disable GPU for Small Simulations</h3><pre><code class="language-swift">// For < 1000 iterations, explicitly use CPU
var simulation = MonteCarloSimulation(
    iterations: 500,
    enableGPU: false,  // CPU faster for small runs
    model: { inputs in ... }
)
</code></pre><hr /><h2>Quick Reference: What‚Äôs GPU-Compatible</h2><h3>‚úÖ Fully Supported (GPU)</h3><table><thead><th>Feature</th><th>Example</th><th>New?</th></thead><tbody><tr><td><strong>Arithmetic</strong></td><td><code>a + b</code>, <code>a * b</code>, <code>a / b</code></td><td>Core</td></tr><tr><td><strong>Math functions</strong></td><td><code>sqrt()</code>, <code>log()</code>, <code>exp()</code>, <code>abs()</code></td><td>Core</td></tr><tr><td><strong>Comparisons</strong></td><td><code>a.greaterThan(b)</code></td><td>Core</td></tr><tr><td><strong>Conditionals</strong></td><td><code>condition.ifElse(then: a, else: b)</code></td><td>Core</td></tr><tr><td><strong>Min/Max</strong></td><td><code>a.min(b)</code>, <code>a.max(b)</code></td><td>Core</td></tr><tr><td><strong>Custom functions</strong></td><td><code>ExpressionFunction(...)</code></td><td>‚ú® NEW</td></tr><tr><td><strong>Fixed-size arrays</strong></td><td><code>builder.array([0, 1, 2]).sum()</code></td><td>üöÄ NEW</td></tr><tr><td><strong>Fixed-size loops</strong></td><td><code>builder.forEach(0..<10, ...)</code></td><td>üöÄ NEW</td></tr><tr><td><strong>Matrix operations</strong></td><td><code>matrix.quadraticForm(weights)</code></td><td>üöÄ NEW</td></tr></tbody></table><h3>‚ö†Ô∏è Partially Supported (Compile-Time Only)</h3><table><thead><th>Feature</th><th>Limitation</th><th>Workaround</th></thead><tbody><tr><td><strong>Loops</strong></td><td>Bounds must be compile-time constants</td><td>Use <code>forEach</code> with literal ranges</td></tr><tr><td><strong>Arrays</strong></td><td>Size must be compile-time constant</td><td>Use <code>builder.array([...])</code></td></tr><tr><td><strong>Matrices</strong></td><td>Dimensions must be compile-time constant</td><td>Use <code>builder.matrix(...)</code></td></tr></tbody></table><h3>‚ùå Not Supported (CPU Only)</h3><table><thead><th>Feature</th><th>Why</th><th>Alternative</th></thead><tbody><tr><td><strong>Swift closures</strong></td><td>Can‚Äôt compile to Metal</td><td>Use <code>ExpressionFunction</code></td></tr><tr><td><strong>Variable loops</strong></td><td><code>for i in 0..<n</code> where n is runtime</td><td>Redesign or use CPU</td></tr><tr><td><strong>Dynamic arrays</strong></td><td><code>Array(repeating: ..., count: n)</code></td><td>Use fixed-size arrays</td></tr><tr><td><strong>Recursion</strong></td><td>GPU shaders don‚Äôt support recursion</td><td>Unroll manually</td></tr><tr><td><strong>External state</strong></td><td>Can‚Äôt access global variables</td><td>Pass as inputs</td></tr></tbody></table><hr /><h2>Try It Yourself</h2><p>Download the complete GPU acceleration playgrounds:</p><p>‚Üí Full API Reference: BusinessMath Docs ‚Äì <a href="#">Monte Carlo GPU Acceleration</a></p><h3>Experiments to Try</h3><ol><li><strong>Benchmark Comparison</strong>: Run same model (closure vs expression) at 1K, 10K, 100K iterations</li><li><strong>Complexity Scaling</strong>: Add operations one-by-one, measure GPU speedup</li><li><strong>Conversion Challenge</strong>: Take a closure-based model and convert to expression-based</li><li><strong>Array Performance</strong>: Compare array operations vs manual unrolling</li><li><strong>Matrix Sizes</strong>: Test 3√ó3, 5√ó5, 10√ó10 covariance matrices</li><li><strong>Loop Unrolling Limits</strong>: Find the practical limit (compile time vs performance)</li><li><strong>Hybrid Approach</strong>: Use GPU for inner loop, CPU for outer optimization</li></ol><hr /><h2>Key Takeaways</h2><ol><li><strong>GPU acceleration provides 10-100√ó speedup</strong> for large Monte Carlo simulations</li><li><strong>Expression models compile to GPU</strong>, closure models run on CPU</li><li><strong>Core operations</strong>: Arithmetic, math functions, comparisons, ternary conditionals</li><li><strong>Reusable functions</strong>: Use <code>ExpressionFunction</code> for GPU-compatible custom functions ‚ú® NEW!</li><li><strong>Built-in library</strong>: <code>FinancialFunctions</code> provides common calculations</li><li><strong>Fixed-size arrays</strong>: <code>builder.array([...])</code> with sum, dot, mean, etc. üöÄ NEW!</li><li><strong>Loop unrolling</strong>: <code>builder.forEach(0...N, ...)</code> for compile-time loops üöÄ NEW!</li><li><strong>Matrix operations</strong>: <code>builder.matrix(...)</code> for covariance and quadratic forms üöÄ NEW!</li><li><strong>Limitations</strong>: Variable loop bounds, dynamic arrays, runtime decisions still require CPU</li><li><strong>Performance sweet spot</strong>: 10K+ iterations, 10+ operations</li><li><strong>When in doubt</strong>: Start with closures (flexibility), optimize to expressions (performance)</li><li><strong>Code reuse</strong>: Build your own function library for domain-specific calculations</li><li><strong>Portfolio models</strong>: Arrays + matrices enable sophisticated multi-asset calculations on GPU</li></ol><hr /><p><strong>Next</strong>: Wednesday covers <strong>Scenario Analysis and Sensitivity Testing</strong>, building on Monte Carlo foundations with structured scenario generation.</p><hr /><p><strong>Series</strong>: [Week 6 of 12] | <strong>Topic</strong>: [Part 2 - Monte Carlo & Simulation] | <strong>Speedup</strong>: [Up to 100√ó with GPU]</p><p><strong>Topics Covered</strong>: GPU acceleration ‚Ä¢ Expression models ‚Ä¢ Metal compute shaders ‚Ä¢ Performance optimization ‚Ä¢ Model conversion</p></p><hr /><div style="margin-top: 2em"><p class="blurb" style="font-style: italic">Tagged with: businessmath, swift, monte-carlo, gpu, metal, performance, expression-model, optimization</p></div></div></div><header><nav class="noPrint navbar navbar-expand-md" style="border-top: 0.01em solid #d5d5d5;"><div class="container-fluid col"><button type="button" class="navbar-toggler btn" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div id="navbarCollapse" class="collapse navbar-collapse"><ul class="navbar-nav mb-2 mb-md-0 col"><li class="nav-item"><a href="mailto:morals.tech.0x@icloud.com" id="email" rel="me" target="_blank" class="nav-link">email</a></li><li class="nav-item"><a href="https://cal.com/jpurnell/15min" id="calendar" rel="me" target="_blank" class="nav-link">calendar</a></li><li class="nav-item"><a href="http://blog.justinpurnell.com" id="blog" rel="me" target="_blank" class="nav-link">blog</a></li><li class="nav-item"><a href="https://github.com/jpurnell" id="github" rel="me" target="_blank" class="nav-link">github</a></li><li class="nav-item"><a href="https://bsky.app/profile/justinpurnell.com" id="bsky" rel="me" target="_blank" class="nav-link">bsky</a></li><li class="nav-item"><a href="https://mastodon.social/@jpurnell" id="mastodon" rel="me" target="_blank" class="nav-link">mastodon</a></li><li class="nav-item"><a href="https://music.apple.com/us/station/justin-purnells-station/ra.u-a475786ae9cc432a1abb70ff757aa95f" id="radio" rel="me" target="_blank" class="nav-link">radio</a></li><li class="nav-item"><a href="https://www.justinpurnell.com/feed.rss" id="rss" rel="me" target="_blank" class="nav-link">rss</a></li><li class="nav-item"><a href="#" id="theme-toggle" rel="me" target="_blank" class="nav-link">theme</a></li></ul></div></div></nav></header><script src="/js/theme-toggle.js"></script></div><script src="/js/bootstrap.bundle.min.js"></script><script src="/js/syntax-highlighting.js"></script></body></html>